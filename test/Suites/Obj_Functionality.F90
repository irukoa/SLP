
module Obj_Functionality

  use, intrinsic :: Iso_Fortran_ENV, only: stderr => error_unit
  use testdrive, only: new_unittest, unittest_type, error_type

  use SLP_kinds, only: sp, dp

  implicit none
  private

  real(sp), parameter :: tol_sp = 0.01_sp
  real(dp), parameter :: tol_dp = 1.0E-7_dp

  public :: collect_Obj_Functionality

contains

  subroutine collect_Obj_Functionality(testsuite)

    type(unittest_type), allocatable, intent(out) :: testsuite(:)

    testsuite = [ &
                  new_unittest("basic check", test_basic) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (sp) SLP: Dirichlet &
                &(&
                &)", &
                t_SLP_out_c1_sp_pp0_w0Dirichlet_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (sp) SLP: Dirichlet &
                &(&
                &Inp. sil )", &
                t_SLP_out_c1_sp_pp0_w0Dirichlet_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (sp) SLP: Dirichlet &
                &(&
                &Inp. sym )", &
                t_SLP_out_c1_sp_pp0_w0Dirichlet_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (sp) SLP: Dirichlet &
                &(&
                &Inp. sym Inp. sil )", &
                t_SLP_out_c1_sp_pp0_w0Dirichlet_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (sp) SLP: Dirichlet &
                &(Inp. w &
                &)", &
                t_SLP_out_c1_sp_pp0_w1Dirichlet_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (sp) SLP: Dirichlet &
                &(Inp. w &
                &Inp. sil )", &
                t_SLP_out_c1_sp_pp0_w1Dirichlet_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (sp) SLP: Dirichlet &
                &(Inp. w &
                &Inp. sym )", &
                t_SLP_out_c1_sp_pp0_w1Dirichlet_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (sp) SLP: Dirichlet &
                &(Inp. w &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c1_sp_pp0_w1Dirichlet_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (sp) SLP: Dirichlet &
                &(Inp. pp &
                &)", &
                t_SLP_out_c1_sp_pp1_w0Dirichlet_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (sp) SLP: Dirichlet &
                &(Inp. pp &
                &Inp. sil )", &
                t_SLP_out_c1_sp_pp1_w0Dirichlet_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (sp) SLP: Dirichlet &
                &(Inp. pp &
                &Inp. sym )", &
                t_SLP_out_c1_sp_pp1_w0Dirichlet_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (sp) SLP: Dirichlet &
                &(Inp. pp &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c1_sp_pp1_w0Dirichlet_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (sp) SLP: Dirichlet &
                &(Inp. pp Inp. w &
                &)", &
                t_SLP_out_c1_sp_pp1_w1Dirichlet_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (sp) SLP: Dirichlet &
                &(Inp. pp Inp. w &
                &Inp. sil )", &
                t_SLP_out_c1_sp_pp1_w1Dirichlet_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (sp) SLP: Dirichlet &
                &(Inp. pp Inp. w &
                &Inp. sym )", &
                t_SLP_out_c1_sp_pp1_w1Dirichlet_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (sp) SLP: Dirichlet &
                &(Inp. pp Inp. w &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c1_sp_pp1_w1Dirichlet_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (sp) SLP: Neumann &
                &(&
                &)", &
                t_SLP_out_c1_sp_pp0_w0Neumann_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (sp) SLP: Neumann &
                &(&
                &Inp. sil )", &
                t_SLP_out_c1_sp_pp0_w0Neumann_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (sp) SLP: Neumann &
                &(&
                &Inp. sym )", &
                t_SLP_out_c1_sp_pp0_w0Neumann_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (sp) SLP: Neumann &
                &(&
                &Inp. sym Inp. sil )", &
                t_SLP_out_c1_sp_pp0_w0Neumann_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (sp) SLP: Neumann &
                &(Inp. w &
                &)", &
                t_SLP_out_c1_sp_pp0_w1Neumann_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (sp) SLP: Neumann &
                &(Inp. w &
                &Inp. sil )", &
                t_SLP_out_c1_sp_pp0_w1Neumann_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (sp) SLP: Neumann &
                &(Inp. w &
                &Inp. sym )", &
                t_SLP_out_c1_sp_pp0_w1Neumann_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (sp) SLP: Neumann &
                &(Inp. w &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c1_sp_pp0_w1Neumann_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (sp) SLP: Neumann &
                &(Inp. pp &
                &)", &
                t_SLP_out_c1_sp_pp1_w0Neumann_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (sp) SLP: Neumann &
                &(Inp. pp &
                &Inp. sil )", &
                t_SLP_out_c1_sp_pp1_w0Neumann_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (sp) SLP: Neumann &
                &(Inp. pp &
                &Inp. sym )", &
                t_SLP_out_c1_sp_pp1_w0Neumann_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (sp) SLP: Neumann &
                &(Inp. pp &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c1_sp_pp1_w0Neumann_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (sp) SLP: Neumann &
                &(Inp. pp Inp. w &
                &)", &
                t_SLP_out_c1_sp_pp1_w1Neumann_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (sp) SLP: Neumann &
                &(Inp. pp Inp. w &
                &Inp. sil )", &
                t_SLP_out_c1_sp_pp1_w1Neumann_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (sp) SLP: Neumann &
                &(Inp. pp Inp. w &
                &Inp. sym )", &
                t_SLP_out_c1_sp_pp1_w1Neumann_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (sp) SLP: Neumann &
                &(Inp. pp Inp. w &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c1_sp_pp1_w1Neumann_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (sp) SLP: Mixed &
                &(&
                &)", &
                t_SLP_out_c1_sp_pp0_w0Mixed_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (sp) SLP: Mixed &
                &(&
                &Inp. sil )", &
                t_SLP_out_c1_sp_pp0_w0Mixed_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (sp) SLP: Mixed &
                &(&
                &Inp. sym )", &
                t_SLP_out_c1_sp_pp0_w0Mixed_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (sp) SLP: Mixed &
                &(&
                &Inp. sym Inp. sil )", &
                t_SLP_out_c1_sp_pp0_w0Mixed_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (sp) SLP: Mixed &
                &(Inp. w &
                &)", &
                t_SLP_out_c1_sp_pp0_w1Mixed_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (sp) SLP: Mixed &
                &(Inp. w &
                &Inp. sil )", &
                t_SLP_out_c1_sp_pp0_w1Mixed_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (sp) SLP: Mixed &
                &(Inp. w &
                &Inp. sym )", &
                t_SLP_out_c1_sp_pp0_w1Mixed_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (sp) SLP: Mixed &
                &(Inp. w &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c1_sp_pp0_w1Mixed_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (sp) SLP: Mixed &
                &(Inp. pp &
                &)", &
                t_SLP_out_c1_sp_pp1_w0Mixed_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (sp) SLP: Mixed &
                &(Inp. pp &
                &Inp. sil )", &
                t_SLP_out_c1_sp_pp1_w0Mixed_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (sp) SLP: Mixed &
                &(Inp. pp &
                &Inp. sym )", &
                t_SLP_out_c1_sp_pp1_w0Mixed_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (sp) SLP: Mixed &
                &(Inp. pp &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c1_sp_pp1_w0Mixed_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (sp) SLP: Mixed &
                &(Inp. pp Inp. w &
                &)", &
                t_SLP_out_c1_sp_pp1_w1Mixed_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (sp) SLP: Mixed &
                &(Inp. pp Inp. w &
                &Inp. sil )", &
                t_SLP_out_c1_sp_pp1_w1Mixed_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (sp) SLP: Mixed &
                &(Inp. pp Inp. w &
                &Inp. sym )", &
                t_SLP_out_c1_sp_pp1_w1Mixed_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (sp) SLP: Mixed &
                &(Inp. pp Inp. w &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c1_sp_pp1_w1Mixed_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (sp) SLP: Periodic &
                &(&
                &)", &
                t_SLP_out_c1_sp_pp0_w0Periodic_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (sp) SLP: Periodic &
                &(&
                &Inp. sil )", &
                t_SLP_out_c1_sp_pp0_w0Periodic_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (sp) SLP: Periodic &
                &(&
                &Inp. sym )", &
                t_SLP_out_c1_sp_pp0_w0Periodic_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (sp) SLP: Periodic &
                &(&
                &Inp. sym Inp. sil )", &
                t_SLP_out_c1_sp_pp0_w0Periodic_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (sp) SLP: Periodic &
                &(Inp. w &
                &)", &
                t_SLP_out_c1_sp_pp0_w1Periodic_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (sp) SLP: Periodic &
                &(Inp. w &
                &Inp. sil )", &
                t_SLP_out_c1_sp_pp0_w1Periodic_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (sp) SLP: Periodic &
                &(Inp. w &
                &Inp. sym )", &
                t_SLP_out_c1_sp_pp0_w1Periodic_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (sp) SLP: Periodic &
                &(Inp. w &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c1_sp_pp0_w1Periodic_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (sp) SLP: Periodic &
                &(Inp. pp &
                &)", &
                t_SLP_out_c1_sp_pp1_w0Periodic_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (sp) SLP: Periodic &
                &(Inp. pp &
                &Inp. sil )", &
                t_SLP_out_c1_sp_pp1_w0Periodic_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (sp) SLP: Periodic &
                &(Inp. pp &
                &Inp. sym )", &
                t_SLP_out_c1_sp_pp1_w0Periodic_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (sp) SLP: Periodic &
                &(Inp. pp &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c1_sp_pp1_w0Periodic_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (sp) SLP: Periodic &
                &(Inp. pp Inp. w &
                &)", &
                t_SLP_out_c1_sp_pp1_w1Periodic_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (sp) SLP: Periodic &
                &(Inp. pp Inp. w &
                &Inp. sil )", &
                t_SLP_out_c1_sp_pp1_w1Periodic_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (sp) SLP: Periodic &
                &(Inp. pp Inp. w &
                &Inp. sym )", &
                t_SLP_out_c1_sp_pp1_w1Periodic_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (sp) SLP: Periodic &
                &(Inp. pp Inp. w &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c1_sp_pp1_w1Periodic_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (sp) SLP: Free &
                &(&
                &)", &
                t_SLP_out_c1_sp_pp0_w0Free_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (sp) SLP: Free &
                &(&
                &Inp. sil )", &
                t_SLP_out_c1_sp_pp0_w0Free_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (sp) SLP: Free &
                &(&
                &Inp. sym )", &
                t_SLP_out_c1_sp_pp0_w0Free_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (sp) SLP: Free &
                &(&
                &Inp. sym Inp. sil )", &
                t_SLP_out_c1_sp_pp0_w0Free_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (sp) SLP: Free &
                &(Inp. w &
                &)", &
                t_SLP_out_c1_sp_pp0_w1Free_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (sp) SLP: Free &
                &(Inp. w &
                &Inp. sil )", &
                t_SLP_out_c1_sp_pp0_w1Free_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (sp) SLP: Free &
                &(Inp. w &
                &Inp. sym )", &
                t_SLP_out_c1_sp_pp0_w1Free_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (sp) SLP: Free &
                &(Inp. w &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c1_sp_pp0_w1Free_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (sp) SLP: Free &
                &(Inp. pp &
                &)", &
                t_SLP_out_c1_sp_pp1_w0Free_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (sp) SLP: Free &
                &(Inp. pp &
                &Inp. sil )", &
                t_SLP_out_c1_sp_pp1_w0Free_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (sp) SLP: Free &
                &(Inp. pp &
                &Inp. sym )", &
                t_SLP_out_c1_sp_pp1_w0Free_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (sp) SLP: Free &
                &(Inp. pp &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c1_sp_pp1_w0Free_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (sp) SLP: Free &
                &(Inp. pp Inp. w &
                &)", &
                t_SLP_out_c1_sp_pp1_w1Free_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (sp) SLP: Free &
                &(Inp. pp Inp. w &
                &Inp. sil )", &
                t_SLP_out_c1_sp_pp1_w1Free_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (sp) SLP: Free &
                &(Inp. pp Inp. w &
                &Inp. sym )", &
                t_SLP_out_c1_sp_pp1_w1Free_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (sp) SLP: Free &
                &(Inp. pp Inp. w &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c1_sp_pp1_w1Free_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (sp) SLP: Singular &
                &(&
                &)", &
                t_SLP_out_c1_sp_pp0_w0Singular_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (sp) SLP: Singular &
                &(&
                &Inp. sil )", &
                t_SLP_out_c1_sp_pp0_w0Singular_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (sp) SLP: Singular &
                &(&
                &Inp. sym )", &
                t_SLP_out_c1_sp_pp0_w0Singular_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (sp) SLP: Singular &
                &(&
                &Inp. sym Inp. sil )", &
                t_SLP_out_c1_sp_pp0_w0Singular_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (sp) SLP: Singular &
                &(Inp. w &
                &)", &
                t_SLP_out_c1_sp_pp0_w1Singular_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (sp) SLP: Singular &
                &(Inp. w &
                &Inp. sil )", &
                t_SLP_out_c1_sp_pp0_w1Singular_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (sp) SLP: Singular &
                &(Inp. w &
                &Inp. sym )", &
                t_SLP_out_c1_sp_pp0_w1Singular_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (sp) SLP: Singular &
                &(Inp. w &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c1_sp_pp0_w1Singular_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (sp) SLP: Singular &
                &(Inp. pp &
                &)", &
                t_SLP_out_c1_sp_pp1_w0Singular_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (sp) SLP: Singular &
                &(Inp. pp &
                &Inp. sil )", &
                t_SLP_out_c1_sp_pp1_w0Singular_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (sp) SLP: Singular &
                &(Inp. pp &
                &Inp. sym )", &
                t_SLP_out_c1_sp_pp1_w0Singular_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (sp) SLP: Singular &
                &(Inp. pp &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c1_sp_pp1_w0Singular_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (sp) SLP: Singular &
                &(Inp. pp Inp. w &
                &)", &
                t_SLP_out_c1_sp_pp1_w1Singular_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (sp) SLP: Singular &
                &(Inp. pp Inp. w &
                &Inp. sil )", &
                t_SLP_out_c1_sp_pp1_w1Singular_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (sp) SLP: Singular &
                &(Inp. pp Inp. w &
                &Inp. sym )", &
                t_SLP_out_c1_sp_pp1_w1Singular_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (sp) SLP: Singular &
                &(Inp. pp Inp. w &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c1_sp_pp1_w1Singular_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (dp) SLP: Dirichlet &
                &(&
                &)", &
                t_SLP_out_c1_dp_pp0_w0Dirichlet_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (dp) SLP: Dirichlet &
                &(&
                &Inp. sil )", &
                t_SLP_out_c1_dp_pp0_w0Dirichlet_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (dp) SLP: Dirichlet &
                &(&
                &Inp. sym )", &
                t_SLP_out_c1_dp_pp0_w0Dirichlet_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (dp) SLP: Dirichlet &
                &(&
                &Inp. sym Inp. sil )", &
                t_SLP_out_c1_dp_pp0_w0Dirichlet_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (dp) SLP: Dirichlet &
                &(Inp. w &
                &)", &
                t_SLP_out_c1_dp_pp0_w1Dirichlet_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (dp) SLP: Dirichlet &
                &(Inp. w &
                &Inp. sil )", &
                t_SLP_out_c1_dp_pp0_w1Dirichlet_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (dp) SLP: Dirichlet &
                &(Inp. w &
                &Inp. sym )", &
                t_SLP_out_c1_dp_pp0_w1Dirichlet_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (dp) SLP: Dirichlet &
                &(Inp. w &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c1_dp_pp0_w1Dirichlet_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (dp) SLP: Dirichlet &
                &(Inp. pp &
                &)", &
                t_SLP_out_c1_dp_pp1_w0Dirichlet_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (dp) SLP: Dirichlet &
                &(Inp. pp &
                &Inp. sil )", &
                t_SLP_out_c1_dp_pp1_w0Dirichlet_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (dp) SLP: Dirichlet &
                &(Inp. pp &
                &Inp. sym )", &
                t_SLP_out_c1_dp_pp1_w0Dirichlet_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (dp) SLP: Dirichlet &
                &(Inp. pp &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c1_dp_pp1_w0Dirichlet_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (dp) SLP: Dirichlet &
                &(Inp. pp Inp. w &
                &)", &
                t_SLP_out_c1_dp_pp1_w1Dirichlet_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (dp) SLP: Dirichlet &
                &(Inp. pp Inp. w &
                &Inp. sil )", &
                t_SLP_out_c1_dp_pp1_w1Dirichlet_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (dp) SLP: Dirichlet &
                &(Inp. pp Inp. w &
                &Inp. sym )", &
                t_SLP_out_c1_dp_pp1_w1Dirichlet_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (dp) SLP: Dirichlet &
                &(Inp. pp Inp. w &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c1_dp_pp1_w1Dirichlet_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (dp) SLP: Neumann &
                &(&
                &)", &
                t_SLP_out_c1_dp_pp0_w0Neumann_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (dp) SLP: Neumann &
                &(&
                &Inp. sil )", &
                t_SLP_out_c1_dp_pp0_w0Neumann_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (dp) SLP: Neumann &
                &(&
                &Inp. sym )", &
                t_SLP_out_c1_dp_pp0_w0Neumann_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (dp) SLP: Neumann &
                &(&
                &Inp. sym Inp. sil )", &
                t_SLP_out_c1_dp_pp0_w0Neumann_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (dp) SLP: Neumann &
                &(Inp. w &
                &)", &
                t_SLP_out_c1_dp_pp0_w1Neumann_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (dp) SLP: Neumann &
                &(Inp. w &
                &Inp. sil )", &
                t_SLP_out_c1_dp_pp0_w1Neumann_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (dp) SLP: Neumann &
                &(Inp. w &
                &Inp. sym )", &
                t_SLP_out_c1_dp_pp0_w1Neumann_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (dp) SLP: Neumann &
                &(Inp. w &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c1_dp_pp0_w1Neumann_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (dp) SLP: Neumann &
                &(Inp. pp &
                &)", &
                t_SLP_out_c1_dp_pp1_w0Neumann_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (dp) SLP: Neumann &
                &(Inp. pp &
                &Inp. sil )", &
                t_SLP_out_c1_dp_pp1_w0Neumann_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (dp) SLP: Neumann &
                &(Inp. pp &
                &Inp. sym )", &
                t_SLP_out_c1_dp_pp1_w0Neumann_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (dp) SLP: Neumann &
                &(Inp. pp &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c1_dp_pp1_w0Neumann_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (dp) SLP: Neumann &
                &(Inp. pp Inp. w &
                &)", &
                t_SLP_out_c1_dp_pp1_w1Neumann_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (dp) SLP: Neumann &
                &(Inp. pp Inp. w &
                &Inp. sil )", &
                t_SLP_out_c1_dp_pp1_w1Neumann_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (dp) SLP: Neumann &
                &(Inp. pp Inp. w &
                &Inp. sym )", &
                t_SLP_out_c1_dp_pp1_w1Neumann_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (dp) SLP: Neumann &
                &(Inp. pp Inp. w &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c1_dp_pp1_w1Neumann_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (dp) SLP: Mixed &
                &(&
                &)", &
                t_SLP_out_c1_dp_pp0_w0Mixed_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (dp) SLP: Mixed &
                &(&
                &Inp. sil )", &
                t_SLP_out_c1_dp_pp0_w0Mixed_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (dp) SLP: Mixed &
                &(&
                &Inp. sym )", &
                t_SLP_out_c1_dp_pp0_w0Mixed_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (dp) SLP: Mixed &
                &(&
                &Inp. sym Inp. sil )", &
                t_SLP_out_c1_dp_pp0_w0Mixed_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (dp) SLP: Mixed &
                &(Inp. w &
                &)", &
                t_SLP_out_c1_dp_pp0_w1Mixed_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (dp) SLP: Mixed &
                &(Inp. w &
                &Inp. sil )", &
                t_SLP_out_c1_dp_pp0_w1Mixed_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (dp) SLP: Mixed &
                &(Inp. w &
                &Inp. sym )", &
                t_SLP_out_c1_dp_pp0_w1Mixed_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (dp) SLP: Mixed &
                &(Inp. w &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c1_dp_pp0_w1Mixed_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (dp) SLP: Mixed &
                &(Inp. pp &
                &)", &
                t_SLP_out_c1_dp_pp1_w0Mixed_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (dp) SLP: Mixed &
                &(Inp. pp &
                &Inp. sil )", &
                t_SLP_out_c1_dp_pp1_w0Mixed_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (dp) SLP: Mixed &
                &(Inp. pp &
                &Inp. sym )", &
                t_SLP_out_c1_dp_pp1_w0Mixed_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (dp) SLP: Mixed &
                &(Inp. pp &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c1_dp_pp1_w0Mixed_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (dp) SLP: Mixed &
                &(Inp. pp Inp. w &
                &)", &
                t_SLP_out_c1_dp_pp1_w1Mixed_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (dp) SLP: Mixed &
                &(Inp. pp Inp. w &
                &Inp. sil )", &
                t_SLP_out_c1_dp_pp1_w1Mixed_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (dp) SLP: Mixed &
                &(Inp. pp Inp. w &
                &Inp. sym )", &
                t_SLP_out_c1_dp_pp1_w1Mixed_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (dp) SLP: Mixed &
                &(Inp. pp Inp. w &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c1_dp_pp1_w1Mixed_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (dp) SLP: Periodic &
                &(&
                &)", &
                t_SLP_out_c1_dp_pp0_w0Periodic_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (dp) SLP: Periodic &
                &(&
                &Inp. sil )", &
                t_SLP_out_c1_dp_pp0_w0Periodic_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (dp) SLP: Periodic &
                &(&
                &Inp. sym )", &
                t_SLP_out_c1_dp_pp0_w0Periodic_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (dp) SLP: Periodic &
                &(&
                &Inp. sym Inp. sil )", &
                t_SLP_out_c1_dp_pp0_w0Periodic_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (dp) SLP: Periodic &
                &(Inp. w &
                &)", &
                t_SLP_out_c1_dp_pp0_w1Periodic_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (dp) SLP: Periodic &
                &(Inp. w &
                &Inp. sil )", &
                t_SLP_out_c1_dp_pp0_w1Periodic_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (dp) SLP: Periodic &
                &(Inp. w &
                &Inp. sym )", &
                t_SLP_out_c1_dp_pp0_w1Periodic_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (dp) SLP: Periodic &
                &(Inp. w &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c1_dp_pp0_w1Periodic_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (dp) SLP: Periodic &
                &(Inp. pp &
                &)", &
                t_SLP_out_c1_dp_pp1_w0Periodic_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (dp) SLP: Periodic &
                &(Inp. pp &
                &Inp. sil )", &
                t_SLP_out_c1_dp_pp1_w0Periodic_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (dp) SLP: Periodic &
                &(Inp. pp &
                &Inp. sym )", &
                t_SLP_out_c1_dp_pp1_w0Periodic_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (dp) SLP: Periodic &
                &(Inp. pp &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c1_dp_pp1_w0Periodic_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (dp) SLP: Periodic &
                &(Inp. pp Inp. w &
                &)", &
                t_SLP_out_c1_dp_pp1_w1Periodic_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (dp) SLP: Periodic &
                &(Inp. pp Inp. w &
                &Inp. sil )", &
                t_SLP_out_c1_dp_pp1_w1Periodic_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (dp) SLP: Periodic &
                &(Inp. pp Inp. w &
                &Inp. sym )", &
                t_SLP_out_c1_dp_pp1_w1Periodic_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (dp) SLP: Periodic &
                &(Inp. pp Inp. w &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c1_dp_pp1_w1Periodic_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (dp) SLP: Free &
                &(&
                &)", &
                t_SLP_out_c1_dp_pp0_w0Free_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (dp) SLP: Free &
                &(&
                &Inp. sil )", &
                t_SLP_out_c1_dp_pp0_w0Free_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (dp) SLP: Free &
                &(&
                &Inp. sym )", &
                t_SLP_out_c1_dp_pp0_w0Free_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (dp) SLP: Free &
                &(&
                &Inp. sym Inp. sil )", &
                t_SLP_out_c1_dp_pp0_w0Free_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (dp) SLP: Free &
                &(Inp. w &
                &)", &
                t_SLP_out_c1_dp_pp0_w1Free_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (dp) SLP: Free &
                &(Inp. w &
                &Inp. sil )", &
                t_SLP_out_c1_dp_pp0_w1Free_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (dp) SLP: Free &
                &(Inp. w &
                &Inp. sym )", &
                t_SLP_out_c1_dp_pp0_w1Free_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (dp) SLP: Free &
                &(Inp. w &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c1_dp_pp0_w1Free_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (dp) SLP: Free &
                &(Inp. pp &
                &)", &
                t_SLP_out_c1_dp_pp1_w0Free_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (dp) SLP: Free &
                &(Inp. pp &
                &Inp. sil )", &
                t_SLP_out_c1_dp_pp1_w0Free_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (dp) SLP: Free &
                &(Inp. pp &
                &Inp. sym )", &
                t_SLP_out_c1_dp_pp1_w0Free_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (dp) SLP: Free &
                &(Inp. pp &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c1_dp_pp1_w0Free_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (dp) SLP: Free &
                &(Inp. pp Inp. w &
                &)", &
                t_SLP_out_c1_dp_pp1_w1Free_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (dp) SLP: Free &
                &(Inp. pp Inp. w &
                &Inp. sil )", &
                t_SLP_out_c1_dp_pp1_w1Free_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (dp) SLP: Free &
                &(Inp. pp Inp. w &
                &Inp. sym )", &
                t_SLP_out_c1_dp_pp1_w1Free_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (dp) SLP: Free &
                &(Inp. pp Inp. w &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c1_dp_pp1_w1Free_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (dp) SLP: Singular &
                &(&
                &)", &
                t_SLP_out_c1_dp_pp0_w0Singular_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (dp) SLP: Singular &
                &(&
                &Inp. sil )", &
                t_SLP_out_c1_dp_pp0_w0Singular_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (dp) SLP: Singular &
                &(&
                &Inp. sym )", &
                t_SLP_out_c1_dp_pp0_w0Singular_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (dp) SLP: Singular &
                &(&
                &Inp. sym Inp. sil )", &
                t_SLP_out_c1_dp_pp0_w0Singular_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (dp) SLP: Singular &
                &(Inp. w &
                &)", &
                t_SLP_out_c1_dp_pp0_w1Singular_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (dp) SLP: Singular &
                &(Inp. w &
                &Inp. sil )", &
                t_SLP_out_c1_dp_pp0_w1Singular_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (dp) SLP: Singular &
                &(Inp. w &
                &Inp. sym )", &
                t_SLP_out_c1_dp_pp0_w1Singular_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (dp) SLP: Singular &
                &(Inp. w &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c1_dp_pp0_w1Singular_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (dp) SLP: Singular &
                &(Inp. pp &
                &)", &
                t_SLP_out_c1_dp_pp1_w0Singular_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (dp) SLP: Singular &
                &(Inp. pp &
                &Inp. sil )", &
                t_SLP_out_c1_dp_pp1_w0Singular_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (dp) SLP: Singular &
                &(Inp. pp &
                &Inp. sym )", &
                t_SLP_out_c1_dp_pp1_w0Singular_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (dp) SLP: Singular &
                &(Inp. pp &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c1_dp_pp1_w0Singular_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (dp) SLP: Singular &
                &(Inp. pp Inp. w &
                &)", &
                t_SLP_out_c1_dp_pp1_w1Singular_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (dp) SLP: Singular &
                &(Inp. pp Inp. w &
                &Inp. sil )", &
                t_SLP_out_c1_dp_pp1_w1Singular_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (dp) SLP: Singular &
                &(Inp. pp Inp. w &
                &Inp. sym )", &
                t_SLP_out_c1_dp_pp1_w1Singular_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: same condition on both bounds &
                &real (dp) SLP: Singular &
                &(Inp. pp Inp. w &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c1_dp_pp1_w1Singular_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Dirichlet Dirichlet &
                &(&
                &)", &
                t_SLP_out_c2_sp_pp0_w0DirichletDirichlet_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Dirichlet Dirichlet &
                &(&
                &Inp. sil )", &
                t_SLP_out_c2_sp_pp0_w0DirichletDirichlet_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Dirichlet Dirichlet &
                &(&
                &Inp. sym )", &
                t_SLP_out_c2_sp_pp0_w0DirichletDirichlet_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Dirichlet Dirichlet &
                &(&
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_sp_pp0_w0DirichletDirichlet_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Dirichlet Neumann &
                &(&
                &)", &
                t_SLP_out_c2_sp_pp0_w0DirichletNeumann_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Dirichlet Neumann &
                &(&
                &Inp. sil )", &
                t_SLP_out_c2_sp_pp0_w0DirichletNeumann_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Dirichlet Neumann &
                &(&
                &Inp. sym )", &
                t_SLP_out_c2_sp_pp0_w0DirichletNeumann_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Dirichlet Neumann &
                &(&
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_sp_pp0_w0DirichletNeumann_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Dirichlet Mixed &
                &(&
                &)", &
                t_SLP_out_c2_sp_pp0_w0DirichletMixed_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Dirichlet Mixed &
                &(&
                &Inp. sil )", &
                t_SLP_out_c2_sp_pp0_w0DirichletMixed_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Dirichlet Mixed &
                &(&
                &Inp. sym )", &
                t_SLP_out_c2_sp_pp0_w0DirichletMixed_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Dirichlet Mixed &
                &(&
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_sp_pp0_w0DirichletMixed_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Dirichlet Free &
                &(&
                &)", &
                t_SLP_out_c2_sp_pp0_w0DirichletFree_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Dirichlet Free &
                &(&
                &Inp. sil )", &
                t_SLP_out_c2_sp_pp0_w0DirichletFree_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Dirichlet Free &
                &(&
                &Inp. sym )", &
                t_SLP_out_c2_sp_pp0_w0DirichletFree_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Dirichlet Free &
                &(&
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_sp_pp0_w0DirichletFree_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Dirichlet Singular &
                &(&
                &)", &
                t_SLP_out_c2_sp_pp0_w0DirichletSingular_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Dirichlet Singular &
                &(&
                &Inp. sil )", &
                t_SLP_out_c2_sp_pp0_w0DirichletSingular_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Dirichlet Singular &
                &(&
                &Inp. sym )", &
                t_SLP_out_c2_sp_pp0_w0DirichletSingular_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Dirichlet Singular &
                &(&
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_sp_pp0_w0DirichletSingular_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Neumann Dirichlet &
                &(&
                &)", &
                t_SLP_out_c2_sp_pp0_w0NeumannDirichlet_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Neumann Dirichlet &
                &(&
                &Inp. sil )", &
                t_SLP_out_c2_sp_pp0_w0NeumannDirichlet_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Neumann Dirichlet &
                &(&
                &Inp. sym )", &
                t_SLP_out_c2_sp_pp0_w0NeumannDirichlet_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Neumann Dirichlet &
                &(&
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_sp_pp0_w0NeumannDirichlet_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Neumann Neumann &
                &(&
                &)", &
                t_SLP_out_c2_sp_pp0_w0NeumannNeumann_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Neumann Neumann &
                &(&
                &Inp. sil )", &
                t_SLP_out_c2_sp_pp0_w0NeumannNeumann_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Neumann Neumann &
                &(&
                &Inp. sym )", &
                t_SLP_out_c2_sp_pp0_w0NeumannNeumann_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Neumann Neumann &
                &(&
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_sp_pp0_w0NeumannNeumann_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Neumann Mixed &
                &(&
                &)", &
                t_SLP_out_c2_sp_pp0_w0NeumannMixed_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Neumann Mixed &
                &(&
                &Inp. sil )", &
                t_SLP_out_c2_sp_pp0_w0NeumannMixed_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Neumann Mixed &
                &(&
                &Inp. sym )", &
                t_SLP_out_c2_sp_pp0_w0NeumannMixed_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Neumann Mixed &
                &(&
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_sp_pp0_w0NeumannMixed_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Neumann Free &
                &(&
                &)", &
                t_SLP_out_c2_sp_pp0_w0NeumannFree_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Neumann Free &
                &(&
                &Inp. sil )", &
                t_SLP_out_c2_sp_pp0_w0NeumannFree_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Neumann Free &
                &(&
                &Inp. sym )", &
                t_SLP_out_c2_sp_pp0_w0NeumannFree_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Neumann Free &
                &(&
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_sp_pp0_w0NeumannFree_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Neumann Singular &
                &(&
                &)", &
                t_SLP_out_c2_sp_pp0_w0NeumannSingular_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Neumann Singular &
                &(&
                &Inp. sil )", &
                t_SLP_out_c2_sp_pp0_w0NeumannSingular_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Neumann Singular &
                &(&
                &Inp. sym )", &
                t_SLP_out_c2_sp_pp0_w0NeumannSingular_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Neumann Singular &
                &(&
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_sp_pp0_w0NeumannSingular_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Mixed Dirichlet &
                &(&
                &)", &
                t_SLP_out_c2_sp_pp0_w0MixedDirichlet_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Mixed Dirichlet &
                &(&
                &Inp. sil )", &
                t_SLP_out_c2_sp_pp0_w0MixedDirichlet_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Mixed Dirichlet &
                &(&
                &Inp. sym )", &
                t_SLP_out_c2_sp_pp0_w0MixedDirichlet_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Mixed Dirichlet &
                &(&
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_sp_pp0_w0MixedDirichlet_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Mixed Neumann &
                &(&
                &)", &
                t_SLP_out_c2_sp_pp0_w0MixedNeumann_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Mixed Neumann &
                &(&
                &Inp. sil )", &
                t_SLP_out_c2_sp_pp0_w0MixedNeumann_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Mixed Neumann &
                &(&
                &Inp. sym )", &
                t_SLP_out_c2_sp_pp0_w0MixedNeumann_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Mixed Neumann &
                &(&
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_sp_pp0_w0MixedNeumann_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Mixed Mixed &
                &(&
                &)", &
                t_SLP_out_c2_sp_pp0_w0MixedMixed_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Mixed Mixed &
                &(&
                &Inp. sil )", &
                t_SLP_out_c2_sp_pp0_w0MixedMixed_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Mixed Mixed &
                &(&
                &Inp. sym )", &
                t_SLP_out_c2_sp_pp0_w0MixedMixed_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Mixed Mixed &
                &(&
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_sp_pp0_w0MixedMixed_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Mixed Free &
                &(&
                &)", &
                t_SLP_out_c2_sp_pp0_w0MixedFree_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Mixed Free &
                &(&
                &Inp. sil )", &
                t_SLP_out_c2_sp_pp0_w0MixedFree_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Mixed Free &
                &(&
                &Inp. sym )", &
                t_SLP_out_c2_sp_pp0_w0MixedFree_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Mixed Free &
                &(&
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_sp_pp0_w0MixedFree_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Mixed Singular &
                &(&
                &)", &
                t_SLP_out_c2_sp_pp0_w0MixedSingular_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Mixed Singular &
                &(&
                &Inp. sil )", &
                t_SLP_out_c2_sp_pp0_w0MixedSingular_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Mixed Singular &
                &(&
                &Inp. sym )", &
                t_SLP_out_c2_sp_pp0_w0MixedSingular_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Mixed Singular &
                &(&
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_sp_pp0_w0MixedSingular_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Free Dirichlet &
                &(&
                &)", &
                t_SLP_out_c2_sp_pp0_w0FreeDirichlet_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Free Dirichlet &
                &(&
                &Inp. sil )", &
                t_SLP_out_c2_sp_pp0_w0FreeDirichlet_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Free Dirichlet &
                &(&
                &Inp. sym )", &
                t_SLP_out_c2_sp_pp0_w0FreeDirichlet_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Free Dirichlet &
                &(&
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_sp_pp0_w0FreeDirichlet_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Free Neumann &
                &(&
                &)", &
                t_SLP_out_c2_sp_pp0_w0FreeNeumann_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Free Neumann &
                &(&
                &Inp. sil )", &
                t_SLP_out_c2_sp_pp0_w0FreeNeumann_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Free Neumann &
                &(&
                &Inp. sym )", &
                t_SLP_out_c2_sp_pp0_w0FreeNeumann_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Free Neumann &
                &(&
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_sp_pp0_w0FreeNeumann_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Free Mixed &
                &(&
                &)", &
                t_SLP_out_c2_sp_pp0_w0FreeMixed_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Free Mixed &
                &(&
                &Inp. sil )", &
                t_SLP_out_c2_sp_pp0_w0FreeMixed_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Free Mixed &
                &(&
                &Inp. sym )", &
                t_SLP_out_c2_sp_pp0_w0FreeMixed_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Free Mixed &
                &(&
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_sp_pp0_w0FreeMixed_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Free Free &
                &(&
                &)", &
                t_SLP_out_c2_sp_pp0_w0FreeFree_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Free Free &
                &(&
                &Inp. sil )", &
                t_SLP_out_c2_sp_pp0_w0FreeFree_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Free Free &
                &(&
                &Inp. sym )", &
                t_SLP_out_c2_sp_pp0_w0FreeFree_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Free Free &
                &(&
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_sp_pp0_w0FreeFree_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Free Singular &
                &(&
                &)", &
                t_SLP_out_c2_sp_pp0_w0FreeSingular_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Free Singular &
                &(&
                &Inp. sil )", &
                t_SLP_out_c2_sp_pp0_w0FreeSingular_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Free Singular &
                &(&
                &Inp. sym )", &
                t_SLP_out_c2_sp_pp0_w0FreeSingular_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Free Singular &
                &(&
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_sp_pp0_w0FreeSingular_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Singular Dirichlet &
                &(&
                &)", &
                t_SLP_out_c2_sp_pp0_w0SingularDirichlet_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Singular Dirichlet &
                &(&
                &Inp. sil )", &
                t_SLP_out_c2_sp_pp0_w0SingularDirichlet_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Singular Dirichlet &
                &(&
                &Inp. sym )", &
                t_SLP_out_c2_sp_pp0_w0SingularDirichlet_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Singular Dirichlet &
                &(&
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_sp_pp0_w0SingularDirichlet_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Singular Neumann &
                &(&
                &)", &
                t_SLP_out_c2_sp_pp0_w0SingularNeumann_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Singular Neumann &
                &(&
                &Inp. sil )", &
                t_SLP_out_c2_sp_pp0_w0SingularNeumann_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Singular Neumann &
                &(&
                &Inp. sym )", &
                t_SLP_out_c2_sp_pp0_w0SingularNeumann_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Singular Neumann &
                &(&
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_sp_pp0_w0SingularNeumann_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Singular Mixed &
                &(&
                &)", &
                t_SLP_out_c2_sp_pp0_w0SingularMixed_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Singular Mixed &
                &(&
                &Inp. sil )", &
                t_SLP_out_c2_sp_pp0_w0SingularMixed_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Singular Mixed &
                &(&
                &Inp. sym )", &
                t_SLP_out_c2_sp_pp0_w0SingularMixed_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Singular Mixed &
                &(&
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_sp_pp0_w0SingularMixed_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Singular Free &
                &(&
                &)", &
                t_SLP_out_c2_sp_pp0_w0SingularFree_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Singular Free &
                &(&
                &Inp. sil )", &
                t_SLP_out_c2_sp_pp0_w0SingularFree_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Singular Free &
                &(&
                &Inp. sym )", &
                t_SLP_out_c2_sp_pp0_w0SingularFree_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Singular Free &
                &(&
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_sp_pp0_w0SingularFree_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Singular Singular &
                &(&
                &)", &
                t_SLP_out_c2_sp_pp0_w0SingularSingular_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Singular Singular &
                &(&
                &Inp. sil )", &
                t_SLP_out_c2_sp_pp0_w0SingularSingular_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Singular Singular &
                &(&
                &Inp. sym )", &
                t_SLP_out_c2_sp_pp0_w0SingularSingular_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Singular Singular &
                &(&
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_sp_pp0_w0SingularSingular_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Dirichlet Dirichlet &
                &(Inp. w &
                &)", &
                t_SLP_out_c2_sp_pp0_w1DirichletDirichlet_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Dirichlet Dirichlet &
                &(Inp. w &
                &Inp. sil )", &
                t_SLP_out_c2_sp_pp0_w1DirichletDirichlet_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Dirichlet Dirichlet &
                &(Inp. w &
                &Inp. sym )", &
                t_SLP_out_c2_sp_pp0_w1DirichletDirichlet_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Dirichlet Dirichlet &
                &(Inp. w &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_sp_pp0_w1DirichletDirichlet_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Dirichlet Neumann &
                &(Inp. w &
                &)", &
                t_SLP_out_c2_sp_pp0_w1DirichletNeumann_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Dirichlet Neumann &
                &(Inp. w &
                &Inp. sil )", &
                t_SLP_out_c2_sp_pp0_w1DirichletNeumann_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Dirichlet Neumann &
                &(Inp. w &
                &Inp. sym )", &
                t_SLP_out_c2_sp_pp0_w1DirichletNeumann_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Dirichlet Neumann &
                &(Inp. w &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_sp_pp0_w1DirichletNeumann_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Dirichlet Mixed &
                &(Inp. w &
                &)", &
                t_SLP_out_c2_sp_pp0_w1DirichletMixed_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Dirichlet Mixed &
                &(Inp. w &
                &Inp. sil )", &
                t_SLP_out_c2_sp_pp0_w1DirichletMixed_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Dirichlet Mixed &
                &(Inp. w &
                &Inp. sym )", &
                t_SLP_out_c2_sp_pp0_w1DirichletMixed_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Dirichlet Mixed &
                &(Inp. w &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_sp_pp0_w1DirichletMixed_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Dirichlet Free &
                &(Inp. w &
                &)", &
                t_SLP_out_c2_sp_pp0_w1DirichletFree_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Dirichlet Free &
                &(Inp. w &
                &Inp. sil )", &
                t_SLP_out_c2_sp_pp0_w1DirichletFree_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Dirichlet Free &
                &(Inp. w &
                &Inp. sym )", &
                t_SLP_out_c2_sp_pp0_w1DirichletFree_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Dirichlet Free &
                &(Inp. w &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_sp_pp0_w1DirichletFree_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Dirichlet Singular &
                &(Inp. w &
                &)", &
                t_SLP_out_c2_sp_pp0_w1DirichletSingular_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Dirichlet Singular &
                &(Inp. w &
                &Inp. sil )", &
                t_SLP_out_c2_sp_pp0_w1DirichletSingular_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Dirichlet Singular &
                &(Inp. w &
                &Inp. sym )", &
                t_SLP_out_c2_sp_pp0_w1DirichletSingular_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Dirichlet Singular &
                &(Inp. w &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_sp_pp0_w1DirichletSingular_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Neumann Dirichlet &
                &(Inp. w &
                &)", &
                t_SLP_out_c2_sp_pp0_w1NeumannDirichlet_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Neumann Dirichlet &
                &(Inp. w &
                &Inp. sil )", &
                t_SLP_out_c2_sp_pp0_w1NeumannDirichlet_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Neumann Dirichlet &
                &(Inp. w &
                &Inp. sym )", &
                t_SLP_out_c2_sp_pp0_w1NeumannDirichlet_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Neumann Dirichlet &
                &(Inp. w &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_sp_pp0_w1NeumannDirichlet_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Neumann Neumann &
                &(Inp. w &
                &)", &
                t_SLP_out_c2_sp_pp0_w1NeumannNeumann_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Neumann Neumann &
                &(Inp. w &
                &Inp. sil )", &
                t_SLP_out_c2_sp_pp0_w1NeumannNeumann_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Neumann Neumann &
                &(Inp. w &
                &Inp. sym )", &
                t_SLP_out_c2_sp_pp0_w1NeumannNeumann_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Neumann Neumann &
                &(Inp. w &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_sp_pp0_w1NeumannNeumann_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Neumann Mixed &
                &(Inp. w &
                &)", &
                t_SLP_out_c2_sp_pp0_w1NeumannMixed_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Neumann Mixed &
                &(Inp. w &
                &Inp. sil )", &
                t_SLP_out_c2_sp_pp0_w1NeumannMixed_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Neumann Mixed &
                &(Inp. w &
                &Inp. sym )", &
                t_SLP_out_c2_sp_pp0_w1NeumannMixed_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Neumann Mixed &
                &(Inp. w &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_sp_pp0_w1NeumannMixed_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Neumann Free &
                &(Inp. w &
                &)", &
                t_SLP_out_c2_sp_pp0_w1NeumannFree_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Neumann Free &
                &(Inp. w &
                &Inp. sil )", &
                t_SLP_out_c2_sp_pp0_w1NeumannFree_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Neumann Free &
                &(Inp. w &
                &Inp. sym )", &
                t_SLP_out_c2_sp_pp0_w1NeumannFree_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Neumann Free &
                &(Inp. w &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_sp_pp0_w1NeumannFree_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Neumann Singular &
                &(Inp. w &
                &)", &
                t_SLP_out_c2_sp_pp0_w1NeumannSingular_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Neumann Singular &
                &(Inp. w &
                &Inp. sil )", &
                t_SLP_out_c2_sp_pp0_w1NeumannSingular_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Neumann Singular &
                &(Inp. w &
                &Inp. sym )", &
                t_SLP_out_c2_sp_pp0_w1NeumannSingular_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Neumann Singular &
                &(Inp. w &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_sp_pp0_w1NeumannSingular_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Mixed Dirichlet &
                &(Inp. w &
                &)", &
                t_SLP_out_c2_sp_pp0_w1MixedDirichlet_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Mixed Dirichlet &
                &(Inp. w &
                &Inp. sil )", &
                t_SLP_out_c2_sp_pp0_w1MixedDirichlet_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Mixed Dirichlet &
                &(Inp. w &
                &Inp. sym )", &
                t_SLP_out_c2_sp_pp0_w1MixedDirichlet_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Mixed Dirichlet &
                &(Inp. w &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_sp_pp0_w1MixedDirichlet_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Mixed Neumann &
                &(Inp. w &
                &)", &
                t_SLP_out_c2_sp_pp0_w1MixedNeumann_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Mixed Neumann &
                &(Inp. w &
                &Inp. sil )", &
                t_SLP_out_c2_sp_pp0_w1MixedNeumann_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Mixed Neumann &
                &(Inp. w &
                &Inp. sym )", &
                t_SLP_out_c2_sp_pp0_w1MixedNeumann_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Mixed Neumann &
                &(Inp. w &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_sp_pp0_w1MixedNeumann_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Mixed Mixed &
                &(Inp. w &
                &)", &
                t_SLP_out_c2_sp_pp0_w1MixedMixed_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Mixed Mixed &
                &(Inp. w &
                &Inp. sil )", &
                t_SLP_out_c2_sp_pp0_w1MixedMixed_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Mixed Mixed &
                &(Inp. w &
                &Inp. sym )", &
                t_SLP_out_c2_sp_pp0_w1MixedMixed_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Mixed Mixed &
                &(Inp. w &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_sp_pp0_w1MixedMixed_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Mixed Free &
                &(Inp. w &
                &)", &
                t_SLP_out_c2_sp_pp0_w1MixedFree_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Mixed Free &
                &(Inp. w &
                &Inp. sil )", &
                t_SLP_out_c2_sp_pp0_w1MixedFree_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Mixed Free &
                &(Inp. w &
                &Inp. sym )", &
                t_SLP_out_c2_sp_pp0_w1MixedFree_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Mixed Free &
                &(Inp. w &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_sp_pp0_w1MixedFree_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Mixed Singular &
                &(Inp. w &
                &)", &
                t_SLP_out_c2_sp_pp0_w1MixedSingular_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Mixed Singular &
                &(Inp. w &
                &Inp. sil )", &
                t_SLP_out_c2_sp_pp0_w1MixedSingular_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Mixed Singular &
                &(Inp. w &
                &Inp. sym )", &
                t_SLP_out_c2_sp_pp0_w1MixedSingular_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Mixed Singular &
                &(Inp. w &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_sp_pp0_w1MixedSingular_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Free Dirichlet &
                &(Inp. w &
                &)", &
                t_SLP_out_c2_sp_pp0_w1FreeDirichlet_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Free Dirichlet &
                &(Inp. w &
                &Inp. sil )", &
                t_SLP_out_c2_sp_pp0_w1FreeDirichlet_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Free Dirichlet &
                &(Inp. w &
                &Inp. sym )", &
                t_SLP_out_c2_sp_pp0_w1FreeDirichlet_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Free Dirichlet &
                &(Inp. w &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_sp_pp0_w1FreeDirichlet_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Free Neumann &
                &(Inp. w &
                &)", &
                t_SLP_out_c2_sp_pp0_w1FreeNeumann_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Free Neumann &
                &(Inp. w &
                &Inp. sil )", &
                t_SLP_out_c2_sp_pp0_w1FreeNeumann_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Free Neumann &
                &(Inp. w &
                &Inp. sym )", &
                t_SLP_out_c2_sp_pp0_w1FreeNeumann_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Free Neumann &
                &(Inp. w &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_sp_pp0_w1FreeNeumann_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Free Mixed &
                &(Inp. w &
                &)", &
                t_SLP_out_c2_sp_pp0_w1FreeMixed_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Free Mixed &
                &(Inp. w &
                &Inp. sil )", &
                t_SLP_out_c2_sp_pp0_w1FreeMixed_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Free Mixed &
                &(Inp. w &
                &Inp. sym )", &
                t_SLP_out_c2_sp_pp0_w1FreeMixed_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Free Mixed &
                &(Inp. w &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_sp_pp0_w1FreeMixed_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Free Free &
                &(Inp. w &
                &)", &
                t_SLP_out_c2_sp_pp0_w1FreeFree_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Free Free &
                &(Inp. w &
                &Inp. sil )", &
                t_SLP_out_c2_sp_pp0_w1FreeFree_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Free Free &
                &(Inp. w &
                &Inp. sym )", &
                t_SLP_out_c2_sp_pp0_w1FreeFree_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Free Free &
                &(Inp. w &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_sp_pp0_w1FreeFree_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Free Singular &
                &(Inp. w &
                &)", &
                t_SLP_out_c2_sp_pp0_w1FreeSingular_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Free Singular &
                &(Inp. w &
                &Inp. sil )", &
                t_SLP_out_c2_sp_pp0_w1FreeSingular_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Free Singular &
                &(Inp. w &
                &Inp. sym )", &
                t_SLP_out_c2_sp_pp0_w1FreeSingular_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Free Singular &
                &(Inp. w &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_sp_pp0_w1FreeSingular_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Singular Dirichlet &
                &(Inp. w &
                &)", &
                t_SLP_out_c2_sp_pp0_w1SingularDirichlet_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Singular Dirichlet &
                &(Inp. w &
                &Inp. sil )", &
                t_SLP_out_c2_sp_pp0_w1SingularDirichlet_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Singular Dirichlet &
                &(Inp. w &
                &Inp. sym )", &
                t_SLP_out_c2_sp_pp0_w1SingularDirichlet_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Singular Dirichlet &
                &(Inp. w &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_sp_pp0_w1SingularDirichlet_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Singular Neumann &
                &(Inp. w &
                &)", &
                t_SLP_out_c2_sp_pp0_w1SingularNeumann_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Singular Neumann &
                &(Inp. w &
                &Inp. sil )", &
                t_SLP_out_c2_sp_pp0_w1SingularNeumann_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Singular Neumann &
                &(Inp. w &
                &Inp. sym )", &
                t_SLP_out_c2_sp_pp0_w1SingularNeumann_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Singular Neumann &
                &(Inp. w &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_sp_pp0_w1SingularNeumann_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Singular Mixed &
                &(Inp. w &
                &)", &
                t_SLP_out_c2_sp_pp0_w1SingularMixed_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Singular Mixed &
                &(Inp. w &
                &Inp. sil )", &
                t_SLP_out_c2_sp_pp0_w1SingularMixed_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Singular Mixed &
                &(Inp. w &
                &Inp. sym )", &
                t_SLP_out_c2_sp_pp0_w1SingularMixed_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Singular Mixed &
                &(Inp. w &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_sp_pp0_w1SingularMixed_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Singular Free &
                &(Inp. w &
                &)", &
                t_SLP_out_c2_sp_pp0_w1SingularFree_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Singular Free &
                &(Inp. w &
                &Inp. sil )", &
                t_SLP_out_c2_sp_pp0_w1SingularFree_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Singular Free &
                &(Inp. w &
                &Inp. sym )", &
                t_SLP_out_c2_sp_pp0_w1SingularFree_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Singular Free &
                &(Inp. w &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_sp_pp0_w1SingularFree_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Singular Singular &
                &(Inp. w &
                &)", &
                t_SLP_out_c2_sp_pp0_w1SingularSingular_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Singular Singular &
                &(Inp. w &
                &Inp. sil )", &
                t_SLP_out_c2_sp_pp0_w1SingularSingular_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Singular Singular &
                &(Inp. w &
                &Inp. sym )", &
                t_SLP_out_c2_sp_pp0_w1SingularSingular_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Singular Singular &
                &(Inp. w &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_sp_pp0_w1SingularSingular_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Dirichlet Dirichlet &
                &(Inp. pp &
                &)", &
                t_SLP_out_c2_sp_pp1_w0DirichletDirichlet_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Dirichlet Dirichlet &
                &(Inp. pp &
                &Inp. sil )", &
                t_SLP_out_c2_sp_pp1_w0DirichletDirichlet_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Dirichlet Dirichlet &
                &(Inp. pp &
                &Inp. sym )", &
                t_SLP_out_c2_sp_pp1_w0DirichletDirichlet_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Dirichlet Dirichlet &
                &(Inp. pp &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_sp_pp1_w0DirichletDirichlet_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Dirichlet Neumann &
                &(Inp. pp &
                &)", &
                t_SLP_out_c2_sp_pp1_w0DirichletNeumann_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Dirichlet Neumann &
                &(Inp. pp &
                &Inp. sil )", &
                t_SLP_out_c2_sp_pp1_w0DirichletNeumann_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Dirichlet Neumann &
                &(Inp. pp &
                &Inp. sym )", &
                t_SLP_out_c2_sp_pp1_w0DirichletNeumann_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Dirichlet Neumann &
                &(Inp. pp &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_sp_pp1_w0DirichletNeumann_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Dirichlet Mixed &
                &(Inp. pp &
                &)", &
                t_SLP_out_c2_sp_pp1_w0DirichletMixed_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Dirichlet Mixed &
                &(Inp. pp &
                &Inp. sil )", &
                t_SLP_out_c2_sp_pp1_w0DirichletMixed_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Dirichlet Mixed &
                &(Inp. pp &
                &Inp. sym )", &
                t_SLP_out_c2_sp_pp1_w0DirichletMixed_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Dirichlet Mixed &
                &(Inp. pp &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_sp_pp1_w0DirichletMixed_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Dirichlet Free &
                &(Inp. pp &
                &)", &
                t_SLP_out_c2_sp_pp1_w0DirichletFree_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Dirichlet Free &
                &(Inp. pp &
                &Inp. sil )", &
                t_SLP_out_c2_sp_pp1_w0DirichletFree_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Dirichlet Free &
                &(Inp. pp &
                &Inp. sym )", &
                t_SLP_out_c2_sp_pp1_w0DirichletFree_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Dirichlet Free &
                &(Inp. pp &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_sp_pp1_w0DirichletFree_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Dirichlet Singular &
                &(Inp. pp &
                &)", &
                t_SLP_out_c2_sp_pp1_w0DirichletSingular_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Dirichlet Singular &
                &(Inp. pp &
                &Inp. sil )", &
                t_SLP_out_c2_sp_pp1_w0DirichletSingular_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Dirichlet Singular &
                &(Inp. pp &
                &Inp. sym )", &
                t_SLP_out_c2_sp_pp1_w0DirichletSingular_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Dirichlet Singular &
                &(Inp. pp &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_sp_pp1_w0DirichletSingular_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Neumann Dirichlet &
                &(Inp. pp &
                &)", &
                t_SLP_out_c2_sp_pp1_w0NeumannDirichlet_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Neumann Dirichlet &
                &(Inp. pp &
                &Inp. sil )", &
                t_SLP_out_c2_sp_pp1_w0NeumannDirichlet_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Neumann Dirichlet &
                &(Inp. pp &
                &Inp. sym )", &
                t_SLP_out_c2_sp_pp1_w0NeumannDirichlet_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Neumann Dirichlet &
                &(Inp. pp &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_sp_pp1_w0NeumannDirichlet_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Neumann Neumann &
                &(Inp. pp &
                &)", &
                t_SLP_out_c2_sp_pp1_w0NeumannNeumann_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Neumann Neumann &
                &(Inp. pp &
                &Inp. sil )", &
                t_SLP_out_c2_sp_pp1_w0NeumannNeumann_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Neumann Neumann &
                &(Inp. pp &
                &Inp. sym )", &
                t_SLP_out_c2_sp_pp1_w0NeumannNeumann_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Neumann Neumann &
                &(Inp. pp &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_sp_pp1_w0NeumannNeumann_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Neumann Mixed &
                &(Inp. pp &
                &)", &
                t_SLP_out_c2_sp_pp1_w0NeumannMixed_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Neumann Mixed &
                &(Inp. pp &
                &Inp. sil )", &
                t_SLP_out_c2_sp_pp1_w0NeumannMixed_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Neumann Mixed &
                &(Inp. pp &
                &Inp. sym )", &
                t_SLP_out_c2_sp_pp1_w0NeumannMixed_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Neumann Mixed &
                &(Inp. pp &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_sp_pp1_w0NeumannMixed_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Neumann Free &
                &(Inp. pp &
                &)", &
                t_SLP_out_c2_sp_pp1_w0NeumannFree_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Neumann Free &
                &(Inp. pp &
                &Inp. sil )", &
                t_SLP_out_c2_sp_pp1_w0NeumannFree_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Neumann Free &
                &(Inp. pp &
                &Inp. sym )", &
                t_SLP_out_c2_sp_pp1_w0NeumannFree_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Neumann Free &
                &(Inp. pp &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_sp_pp1_w0NeumannFree_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Neumann Singular &
                &(Inp. pp &
                &)", &
                t_SLP_out_c2_sp_pp1_w0NeumannSingular_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Neumann Singular &
                &(Inp. pp &
                &Inp. sil )", &
                t_SLP_out_c2_sp_pp1_w0NeumannSingular_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Neumann Singular &
                &(Inp. pp &
                &Inp. sym )", &
                t_SLP_out_c2_sp_pp1_w0NeumannSingular_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Neumann Singular &
                &(Inp. pp &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_sp_pp1_w0NeumannSingular_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Mixed Dirichlet &
                &(Inp. pp &
                &)", &
                t_SLP_out_c2_sp_pp1_w0MixedDirichlet_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Mixed Dirichlet &
                &(Inp. pp &
                &Inp. sil )", &
                t_SLP_out_c2_sp_pp1_w0MixedDirichlet_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Mixed Dirichlet &
                &(Inp. pp &
                &Inp. sym )", &
                t_SLP_out_c2_sp_pp1_w0MixedDirichlet_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Mixed Dirichlet &
                &(Inp. pp &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_sp_pp1_w0MixedDirichlet_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Mixed Neumann &
                &(Inp. pp &
                &)", &
                t_SLP_out_c2_sp_pp1_w0MixedNeumann_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Mixed Neumann &
                &(Inp. pp &
                &Inp. sil )", &
                t_SLP_out_c2_sp_pp1_w0MixedNeumann_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Mixed Neumann &
                &(Inp. pp &
                &Inp. sym )", &
                t_SLP_out_c2_sp_pp1_w0MixedNeumann_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Mixed Neumann &
                &(Inp. pp &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_sp_pp1_w0MixedNeumann_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Mixed Mixed &
                &(Inp. pp &
                &)", &
                t_SLP_out_c2_sp_pp1_w0MixedMixed_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Mixed Mixed &
                &(Inp. pp &
                &Inp. sil )", &
                t_SLP_out_c2_sp_pp1_w0MixedMixed_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Mixed Mixed &
                &(Inp. pp &
                &Inp. sym )", &
                t_SLP_out_c2_sp_pp1_w0MixedMixed_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Mixed Mixed &
                &(Inp. pp &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_sp_pp1_w0MixedMixed_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Mixed Free &
                &(Inp. pp &
                &)", &
                t_SLP_out_c2_sp_pp1_w0MixedFree_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Mixed Free &
                &(Inp. pp &
                &Inp. sil )", &
                t_SLP_out_c2_sp_pp1_w0MixedFree_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Mixed Free &
                &(Inp. pp &
                &Inp. sym )", &
                t_SLP_out_c2_sp_pp1_w0MixedFree_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Mixed Free &
                &(Inp. pp &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_sp_pp1_w0MixedFree_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Mixed Singular &
                &(Inp. pp &
                &)", &
                t_SLP_out_c2_sp_pp1_w0MixedSingular_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Mixed Singular &
                &(Inp. pp &
                &Inp. sil )", &
                t_SLP_out_c2_sp_pp1_w0MixedSingular_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Mixed Singular &
                &(Inp. pp &
                &Inp. sym )", &
                t_SLP_out_c2_sp_pp1_w0MixedSingular_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Mixed Singular &
                &(Inp. pp &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_sp_pp1_w0MixedSingular_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Free Dirichlet &
                &(Inp. pp &
                &)", &
                t_SLP_out_c2_sp_pp1_w0FreeDirichlet_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Free Dirichlet &
                &(Inp. pp &
                &Inp. sil )", &
                t_SLP_out_c2_sp_pp1_w0FreeDirichlet_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Free Dirichlet &
                &(Inp. pp &
                &Inp. sym )", &
                t_SLP_out_c2_sp_pp1_w0FreeDirichlet_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Free Dirichlet &
                &(Inp. pp &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_sp_pp1_w0FreeDirichlet_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Free Neumann &
                &(Inp. pp &
                &)", &
                t_SLP_out_c2_sp_pp1_w0FreeNeumann_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Free Neumann &
                &(Inp. pp &
                &Inp. sil )", &
                t_SLP_out_c2_sp_pp1_w0FreeNeumann_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Free Neumann &
                &(Inp. pp &
                &Inp. sym )", &
                t_SLP_out_c2_sp_pp1_w0FreeNeumann_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Free Neumann &
                &(Inp. pp &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_sp_pp1_w0FreeNeumann_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Free Mixed &
                &(Inp. pp &
                &)", &
                t_SLP_out_c2_sp_pp1_w0FreeMixed_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Free Mixed &
                &(Inp. pp &
                &Inp. sil )", &
                t_SLP_out_c2_sp_pp1_w0FreeMixed_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Free Mixed &
                &(Inp. pp &
                &Inp. sym )", &
                t_SLP_out_c2_sp_pp1_w0FreeMixed_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Free Mixed &
                &(Inp. pp &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_sp_pp1_w0FreeMixed_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Free Free &
                &(Inp. pp &
                &)", &
                t_SLP_out_c2_sp_pp1_w0FreeFree_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Free Free &
                &(Inp. pp &
                &Inp. sil )", &
                t_SLP_out_c2_sp_pp1_w0FreeFree_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Free Free &
                &(Inp. pp &
                &Inp. sym )", &
                t_SLP_out_c2_sp_pp1_w0FreeFree_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Free Free &
                &(Inp. pp &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_sp_pp1_w0FreeFree_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Free Singular &
                &(Inp. pp &
                &)", &
                t_SLP_out_c2_sp_pp1_w0FreeSingular_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Free Singular &
                &(Inp. pp &
                &Inp. sil )", &
                t_SLP_out_c2_sp_pp1_w0FreeSingular_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Free Singular &
                &(Inp. pp &
                &Inp. sym )", &
                t_SLP_out_c2_sp_pp1_w0FreeSingular_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Free Singular &
                &(Inp. pp &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_sp_pp1_w0FreeSingular_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Singular Dirichlet &
                &(Inp. pp &
                &)", &
                t_SLP_out_c2_sp_pp1_w0SingularDirichlet_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Singular Dirichlet &
                &(Inp. pp &
                &Inp. sil )", &
                t_SLP_out_c2_sp_pp1_w0SingularDirichlet_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Singular Dirichlet &
                &(Inp. pp &
                &Inp. sym )", &
                t_SLP_out_c2_sp_pp1_w0SingularDirichlet_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Singular Dirichlet &
                &(Inp. pp &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_sp_pp1_w0SingularDirichlet_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Singular Neumann &
                &(Inp. pp &
                &)", &
                t_SLP_out_c2_sp_pp1_w0SingularNeumann_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Singular Neumann &
                &(Inp. pp &
                &Inp. sil )", &
                t_SLP_out_c2_sp_pp1_w0SingularNeumann_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Singular Neumann &
                &(Inp. pp &
                &Inp. sym )", &
                t_SLP_out_c2_sp_pp1_w0SingularNeumann_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Singular Neumann &
                &(Inp. pp &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_sp_pp1_w0SingularNeumann_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Singular Mixed &
                &(Inp. pp &
                &)", &
                t_SLP_out_c2_sp_pp1_w0SingularMixed_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Singular Mixed &
                &(Inp. pp &
                &Inp. sil )", &
                t_SLP_out_c2_sp_pp1_w0SingularMixed_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Singular Mixed &
                &(Inp. pp &
                &Inp. sym )", &
                t_SLP_out_c2_sp_pp1_w0SingularMixed_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Singular Mixed &
                &(Inp. pp &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_sp_pp1_w0SingularMixed_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Singular Free &
                &(Inp. pp &
                &)", &
                t_SLP_out_c2_sp_pp1_w0SingularFree_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Singular Free &
                &(Inp. pp &
                &Inp. sil )", &
                t_SLP_out_c2_sp_pp1_w0SingularFree_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Singular Free &
                &(Inp. pp &
                &Inp. sym )", &
                t_SLP_out_c2_sp_pp1_w0SingularFree_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Singular Free &
                &(Inp. pp &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_sp_pp1_w0SingularFree_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Singular Singular &
                &(Inp. pp &
                &)", &
                t_SLP_out_c2_sp_pp1_w0SingularSingular_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Singular Singular &
                &(Inp. pp &
                &Inp. sil )", &
                t_SLP_out_c2_sp_pp1_w0SingularSingular_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Singular Singular &
                &(Inp. pp &
                &Inp. sym )", &
                t_SLP_out_c2_sp_pp1_w0SingularSingular_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Singular Singular &
                &(Inp. pp &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_sp_pp1_w0SingularSingular_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Dirichlet Dirichlet &
                &(Inp. pp Inp. w &
                &)", &
                t_SLP_out_c2_sp_pp1_w1DirichletDirichlet_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Dirichlet Dirichlet &
                &(Inp. pp Inp. w &
                &Inp. sil )", &
                t_SLP_out_c2_sp_pp1_w1DirichletDirichlet_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Dirichlet Dirichlet &
                &(Inp. pp Inp. w &
                &Inp. sym )", &
                t_SLP_out_c2_sp_pp1_w1DirichletDirichlet_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Dirichlet Dirichlet &
                &(Inp. pp Inp. w &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_sp_pp1_w1DirichletDirichlet_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Dirichlet Neumann &
                &(Inp. pp Inp. w &
                &)", &
                t_SLP_out_c2_sp_pp1_w1DirichletNeumann_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Dirichlet Neumann &
                &(Inp. pp Inp. w &
                &Inp. sil )", &
                t_SLP_out_c2_sp_pp1_w1DirichletNeumann_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Dirichlet Neumann &
                &(Inp. pp Inp. w &
                &Inp. sym )", &
                t_SLP_out_c2_sp_pp1_w1DirichletNeumann_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Dirichlet Neumann &
                &(Inp. pp Inp. w &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_sp_pp1_w1DirichletNeumann_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Dirichlet Mixed &
                &(Inp. pp Inp. w &
                &)", &
                t_SLP_out_c2_sp_pp1_w1DirichletMixed_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Dirichlet Mixed &
                &(Inp. pp Inp. w &
                &Inp. sil )", &
                t_SLP_out_c2_sp_pp1_w1DirichletMixed_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Dirichlet Mixed &
                &(Inp. pp Inp. w &
                &Inp. sym )", &
                t_SLP_out_c2_sp_pp1_w1DirichletMixed_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Dirichlet Mixed &
                &(Inp. pp Inp. w &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_sp_pp1_w1DirichletMixed_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Dirichlet Free &
                &(Inp. pp Inp. w &
                &)", &
                t_SLP_out_c2_sp_pp1_w1DirichletFree_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Dirichlet Free &
                &(Inp. pp Inp. w &
                &Inp. sil )", &
                t_SLP_out_c2_sp_pp1_w1DirichletFree_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Dirichlet Free &
                &(Inp. pp Inp. w &
                &Inp. sym )", &
                t_SLP_out_c2_sp_pp1_w1DirichletFree_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Dirichlet Free &
                &(Inp. pp Inp. w &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_sp_pp1_w1DirichletFree_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Dirichlet Singular &
                &(Inp. pp Inp. w &
                &)", &
                t_SLP_out_c2_sp_pp1_w1DirichletSingular_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Dirichlet Singular &
                &(Inp. pp Inp. w &
                &Inp. sil )", &
                t_SLP_out_c2_sp_pp1_w1DirichletSingular_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Dirichlet Singular &
                &(Inp. pp Inp. w &
                &Inp. sym )", &
                t_SLP_out_c2_sp_pp1_w1DirichletSingular_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Dirichlet Singular &
                &(Inp. pp Inp. w &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_sp_pp1_w1DirichletSingular_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Neumann Dirichlet &
                &(Inp. pp Inp. w &
                &)", &
                t_SLP_out_c2_sp_pp1_w1NeumannDirichlet_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Neumann Dirichlet &
                &(Inp. pp Inp. w &
                &Inp. sil )", &
                t_SLP_out_c2_sp_pp1_w1NeumannDirichlet_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Neumann Dirichlet &
                &(Inp. pp Inp. w &
                &Inp. sym )", &
                t_SLP_out_c2_sp_pp1_w1NeumannDirichlet_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Neumann Dirichlet &
                &(Inp. pp Inp. w &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_sp_pp1_w1NeumannDirichlet_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Neumann Neumann &
                &(Inp. pp Inp. w &
                &)", &
                t_SLP_out_c2_sp_pp1_w1NeumannNeumann_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Neumann Neumann &
                &(Inp. pp Inp. w &
                &Inp. sil )", &
                t_SLP_out_c2_sp_pp1_w1NeumannNeumann_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Neumann Neumann &
                &(Inp. pp Inp. w &
                &Inp. sym )", &
                t_SLP_out_c2_sp_pp1_w1NeumannNeumann_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Neumann Neumann &
                &(Inp. pp Inp. w &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_sp_pp1_w1NeumannNeumann_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Neumann Mixed &
                &(Inp. pp Inp. w &
                &)", &
                t_SLP_out_c2_sp_pp1_w1NeumannMixed_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Neumann Mixed &
                &(Inp. pp Inp. w &
                &Inp. sil )", &
                t_SLP_out_c2_sp_pp1_w1NeumannMixed_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Neumann Mixed &
                &(Inp. pp Inp. w &
                &Inp. sym )", &
                t_SLP_out_c2_sp_pp1_w1NeumannMixed_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Neumann Mixed &
                &(Inp. pp Inp. w &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_sp_pp1_w1NeumannMixed_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Neumann Free &
                &(Inp. pp Inp. w &
                &)", &
                t_SLP_out_c2_sp_pp1_w1NeumannFree_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Neumann Free &
                &(Inp. pp Inp. w &
                &Inp. sil )", &
                t_SLP_out_c2_sp_pp1_w1NeumannFree_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Neumann Free &
                &(Inp. pp Inp. w &
                &Inp. sym )", &
                t_SLP_out_c2_sp_pp1_w1NeumannFree_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Neumann Free &
                &(Inp. pp Inp. w &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_sp_pp1_w1NeumannFree_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Neumann Singular &
                &(Inp. pp Inp. w &
                &)", &
                t_SLP_out_c2_sp_pp1_w1NeumannSingular_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Neumann Singular &
                &(Inp. pp Inp. w &
                &Inp. sil )", &
                t_SLP_out_c2_sp_pp1_w1NeumannSingular_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Neumann Singular &
                &(Inp. pp Inp. w &
                &Inp. sym )", &
                t_SLP_out_c2_sp_pp1_w1NeumannSingular_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Neumann Singular &
                &(Inp. pp Inp. w &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_sp_pp1_w1NeumannSingular_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Mixed Dirichlet &
                &(Inp. pp Inp. w &
                &)", &
                t_SLP_out_c2_sp_pp1_w1MixedDirichlet_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Mixed Dirichlet &
                &(Inp. pp Inp. w &
                &Inp. sil )", &
                t_SLP_out_c2_sp_pp1_w1MixedDirichlet_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Mixed Dirichlet &
                &(Inp. pp Inp. w &
                &Inp. sym )", &
                t_SLP_out_c2_sp_pp1_w1MixedDirichlet_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Mixed Dirichlet &
                &(Inp. pp Inp. w &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_sp_pp1_w1MixedDirichlet_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Mixed Neumann &
                &(Inp. pp Inp. w &
                &)", &
                t_SLP_out_c2_sp_pp1_w1MixedNeumann_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Mixed Neumann &
                &(Inp. pp Inp. w &
                &Inp. sil )", &
                t_SLP_out_c2_sp_pp1_w1MixedNeumann_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Mixed Neumann &
                &(Inp. pp Inp. w &
                &Inp. sym )", &
                t_SLP_out_c2_sp_pp1_w1MixedNeumann_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Mixed Neumann &
                &(Inp. pp Inp. w &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_sp_pp1_w1MixedNeumann_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Mixed Mixed &
                &(Inp. pp Inp. w &
                &)", &
                t_SLP_out_c2_sp_pp1_w1MixedMixed_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Mixed Mixed &
                &(Inp. pp Inp. w &
                &Inp. sil )", &
                t_SLP_out_c2_sp_pp1_w1MixedMixed_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Mixed Mixed &
                &(Inp. pp Inp. w &
                &Inp. sym )", &
                t_SLP_out_c2_sp_pp1_w1MixedMixed_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Mixed Mixed &
                &(Inp. pp Inp. w &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_sp_pp1_w1MixedMixed_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Mixed Free &
                &(Inp. pp Inp. w &
                &)", &
                t_SLP_out_c2_sp_pp1_w1MixedFree_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Mixed Free &
                &(Inp. pp Inp. w &
                &Inp. sil )", &
                t_SLP_out_c2_sp_pp1_w1MixedFree_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Mixed Free &
                &(Inp. pp Inp. w &
                &Inp. sym )", &
                t_SLP_out_c2_sp_pp1_w1MixedFree_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Mixed Free &
                &(Inp. pp Inp. w &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_sp_pp1_w1MixedFree_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Mixed Singular &
                &(Inp. pp Inp. w &
                &)", &
                t_SLP_out_c2_sp_pp1_w1MixedSingular_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Mixed Singular &
                &(Inp. pp Inp. w &
                &Inp. sil )", &
                t_SLP_out_c2_sp_pp1_w1MixedSingular_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Mixed Singular &
                &(Inp. pp Inp. w &
                &Inp. sym )", &
                t_SLP_out_c2_sp_pp1_w1MixedSingular_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Mixed Singular &
                &(Inp. pp Inp. w &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_sp_pp1_w1MixedSingular_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Free Dirichlet &
                &(Inp. pp Inp. w &
                &)", &
                t_SLP_out_c2_sp_pp1_w1FreeDirichlet_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Free Dirichlet &
                &(Inp. pp Inp. w &
                &Inp. sil )", &
                t_SLP_out_c2_sp_pp1_w1FreeDirichlet_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Free Dirichlet &
                &(Inp. pp Inp. w &
                &Inp. sym )", &
                t_SLP_out_c2_sp_pp1_w1FreeDirichlet_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Free Dirichlet &
                &(Inp. pp Inp. w &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_sp_pp1_w1FreeDirichlet_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Free Neumann &
                &(Inp. pp Inp. w &
                &)", &
                t_SLP_out_c2_sp_pp1_w1FreeNeumann_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Free Neumann &
                &(Inp. pp Inp. w &
                &Inp. sil )", &
                t_SLP_out_c2_sp_pp1_w1FreeNeumann_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Free Neumann &
                &(Inp. pp Inp. w &
                &Inp. sym )", &
                t_SLP_out_c2_sp_pp1_w1FreeNeumann_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Free Neumann &
                &(Inp. pp Inp. w &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_sp_pp1_w1FreeNeumann_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Free Mixed &
                &(Inp. pp Inp. w &
                &)", &
                t_SLP_out_c2_sp_pp1_w1FreeMixed_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Free Mixed &
                &(Inp. pp Inp. w &
                &Inp. sil )", &
                t_SLP_out_c2_sp_pp1_w1FreeMixed_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Free Mixed &
                &(Inp. pp Inp. w &
                &Inp. sym )", &
                t_SLP_out_c2_sp_pp1_w1FreeMixed_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Free Mixed &
                &(Inp. pp Inp. w &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_sp_pp1_w1FreeMixed_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Free Free &
                &(Inp. pp Inp. w &
                &)", &
                t_SLP_out_c2_sp_pp1_w1FreeFree_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Free Free &
                &(Inp. pp Inp. w &
                &Inp. sil )", &
                t_SLP_out_c2_sp_pp1_w1FreeFree_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Free Free &
                &(Inp. pp Inp. w &
                &Inp. sym )", &
                t_SLP_out_c2_sp_pp1_w1FreeFree_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Free Free &
                &(Inp. pp Inp. w &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_sp_pp1_w1FreeFree_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Free Singular &
                &(Inp. pp Inp. w &
                &)", &
                t_SLP_out_c2_sp_pp1_w1FreeSingular_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Free Singular &
                &(Inp. pp Inp. w &
                &Inp. sil )", &
                t_SLP_out_c2_sp_pp1_w1FreeSingular_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Free Singular &
                &(Inp. pp Inp. w &
                &Inp. sym )", &
                t_SLP_out_c2_sp_pp1_w1FreeSingular_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Free Singular &
                &(Inp. pp Inp. w &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_sp_pp1_w1FreeSingular_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Singular Dirichlet &
                &(Inp. pp Inp. w &
                &)", &
                t_SLP_out_c2_sp_pp1_w1SingularDirichlet_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Singular Dirichlet &
                &(Inp. pp Inp. w &
                &Inp. sil )", &
                t_SLP_out_c2_sp_pp1_w1SingularDirichlet_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Singular Dirichlet &
                &(Inp. pp Inp. w &
                &Inp. sym )", &
                t_SLP_out_c2_sp_pp1_w1SingularDirichlet_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Singular Dirichlet &
                &(Inp. pp Inp. w &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_sp_pp1_w1SingularDirichlet_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Singular Neumann &
                &(Inp. pp Inp. w &
                &)", &
                t_SLP_out_c2_sp_pp1_w1SingularNeumann_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Singular Neumann &
                &(Inp. pp Inp. w &
                &Inp. sil )", &
                t_SLP_out_c2_sp_pp1_w1SingularNeumann_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Singular Neumann &
                &(Inp. pp Inp. w &
                &Inp. sym )", &
                t_SLP_out_c2_sp_pp1_w1SingularNeumann_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Singular Neumann &
                &(Inp. pp Inp. w &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_sp_pp1_w1SingularNeumann_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Singular Mixed &
                &(Inp. pp Inp. w &
                &)", &
                t_SLP_out_c2_sp_pp1_w1SingularMixed_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Singular Mixed &
                &(Inp. pp Inp. w &
                &Inp. sil )", &
                t_SLP_out_c2_sp_pp1_w1SingularMixed_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Singular Mixed &
                &(Inp. pp Inp. w &
                &Inp. sym )", &
                t_SLP_out_c2_sp_pp1_w1SingularMixed_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Singular Mixed &
                &(Inp. pp Inp. w &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_sp_pp1_w1SingularMixed_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Singular Free &
                &(Inp. pp Inp. w &
                &)", &
                t_SLP_out_c2_sp_pp1_w1SingularFree_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Singular Free &
                &(Inp. pp Inp. w &
                &Inp. sil )", &
                t_SLP_out_c2_sp_pp1_w1SingularFree_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Singular Free &
                &(Inp. pp Inp. w &
                &Inp. sym )", &
                t_SLP_out_c2_sp_pp1_w1SingularFree_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Singular Free &
                &(Inp. pp Inp. w &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_sp_pp1_w1SingularFree_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Singular Singular &
                &(Inp. pp Inp. w &
                &)", &
                t_SLP_out_c2_sp_pp1_w1SingularSingular_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Singular Singular &
                &(Inp. pp Inp. w &
                &Inp. sil )", &
                t_SLP_out_c2_sp_pp1_w1SingularSingular_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Singular Singular &
                &(Inp. pp Inp. w &
                &Inp. sym )", &
                t_SLP_out_c2_sp_pp1_w1SingularSingular_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (sp) SLP: Singular Singular &
                &(Inp. pp Inp. w &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_sp_pp1_w1SingularSingular_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Dirichlet Dirichlet &
                &(&
                &)", &
                t_SLP_out_c2_dp_pp0_w0DirichletDirichlet_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Dirichlet Dirichlet &
                &(&
                &Inp. sil )", &
                t_SLP_out_c2_dp_pp0_w0DirichletDirichlet_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Dirichlet Dirichlet &
                &(&
                &Inp. sym )", &
                t_SLP_out_c2_dp_pp0_w0DirichletDirichlet_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Dirichlet Dirichlet &
                &(&
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_dp_pp0_w0DirichletDirichlet_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Dirichlet Neumann &
                &(&
                &)", &
                t_SLP_out_c2_dp_pp0_w0DirichletNeumann_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Dirichlet Neumann &
                &(&
                &Inp. sil )", &
                t_SLP_out_c2_dp_pp0_w0DirichletNeumann_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Dirichlet Neumann &
                &(&
                &Inp. sym )", &
                t_SLP_out_c2_dp_pp0_w0DirichletNeumann_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Dirichlet Neumann &
                &(&
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_dp_pp0_w0DirichletNeumann_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Dirichlet Mixed &
                &(&
                &)", &
                t_SLP_out_c2_dp_pp0_w0DirichletMixed_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Dirichlet Mixed &
                &(&
                &Inp. sil )", &
                t_SLP_out_c2_dp_pp0_w0DirichletMixed_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Dirichlet Mixed &
                &(&
                &Inp. sym )", &
                t_SLP_out_c2_dp_pp0_w0DirichletMixed_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Dirichlet Mixed &
                &(&
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_dp_pp0_w0DirichletMixed_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Dirichlet Free &
                &(&
                &)", &
                t_SLP_out_c2_dp_pp0_w0DirichletFree_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Dirichlet Free &
                &(&
                &Inp. sil )", &
                t_SLP_out_c2_dp_pp0_w0DirichletFree_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Dirichlet Free &
                &(&
                &Inp. sym )", &
                t_SLP_out_c2_dp_pp0_w0DirichletFree_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Dirichlet Free &
                &(&
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_dp_pp0_w0DirichletFree_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Dirichlet Singular &
                &(&
                &)", &
                t_SLP_out_c2_dp_pp0_w0DirichletSingular_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Dirichlet Singular &
                &(&
                &Inp. sil )", &
                t_SLP_out_c2_dp_pp0_w0DirichletSingular_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Dirichlet Singular &
                &(&
                &Inp. sym )", &
                t_SLP_out_c2_dp_pp0_w0DirichletSingular_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Dirichlet Singular &
                &(&
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_dp_pp0_w0DirichletSingular_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Neumann Dirichlet &
                &(&
                &)", &
                t_SLP_out_c2_dp_pp0_w0NeumannDirichlet_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Neumann Dirichlet &
                &(&
                &Inp. sil )", &
                t_SLP_out_c2_dp_pp0_w0NeumannDirichlet_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Neumann Dirichlet &
                &(&
                &Inp. sym )", &
                t_SLP_out_c2_dp_pp0_w0NeumannDirichlet_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Neumann Dirichlet &
                &(&
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_dp_pp0_w0NeumannDirichlet_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Neumann Neumann &
                &(&
                &)", &
                t_SLP_out_c2_dp_pp0_w0NeumannNeumann_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Neumann Neumann &
                &(&
                &Inp. sil )", &
                t_SLP_out_c2_dp_pp0_w0NeumannNeumann_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Neumann Neumann &
                &(&
                &Inp. sym )", &
                t_SLP_out_c2_dp_pp0_w0NeumannNeumann_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Neumann Neumann &
                &(&
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_dp_pp0_w0NeumannNeumann_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Neumann Mixed &
                &(&
                &)", &
                t_SLP_out_c2_dp_pp0_w0NeumannMixed_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Neumann Mixed &
                &(&
                &Inp. sil )", &
                t_SLP_out_c2_dp_pp0_w0NeumannMixed_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Neumann Mixed &
                &(&
                &Inp. sym )", &
                t_SLP_out_c2_dp_pp0_w0NeumannMixed_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Neumann Mixed &
                &(&
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_dp_pp0_w0NeumannMixed_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Neumann Free &
                &(&
                &)", &
                t_SLP_out_c2_dp_pp0_w0NeumannFree_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Neumann Free &
                &(&
                &Inp. sil )", &
                t_SLP_out_c2_dp_pp0_w0NeumannFree_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Neumann Free &
                &(&
                &Inp. sym )", &
                t_SLP_out_c2_dp_pp0_w0NeumannFree_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Neumann Free &
                &(&
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_dp_pp0_w0NeumannFree_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Neumann Singular &
                &(&
                &)", &
                t_SLP_out_c2_dp_pp0_w0NeumannSingular_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Neumann Singular &
                &(&
                &Inp. sil )", &
                t_SLP_out_c2_dp_pp0_w0NeumannSingular_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Neumann Singular &
                &(&
                &Inp. sym )", &
                t_SLP_out_c2_dp_pp0_w0NeumannSingular_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Neumann Singular &
                &(&
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_dp_pp0_w0NeumannSingular_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Mixed Dirichlet &
                &(&
                &)", &
                t_SLP_out_c2_dp_pp0_w0MixedDirichlet_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Mixed Dirichlet &
                &(&
                &Inp. sil )", &
                t_SLP_out_c2_dp_pp0_w0MixedDirichlet_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Mixed Dirichlet &
                &(&
                &Inp. sym )", &
                t_SLP_out_c2_dp_pp0_w0MixedDirichlet_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Mixed Dirichlet &
                &(&
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_dp_pp0_w0MixedDirichlet_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Mixed Neumann &
                &(&
                &)", &
                t_SLP_out_c2_dp_pp0_w0MixedNeumann_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Mixed Neumann &
                &(&
                &Inp. sil )", &
                t_SLP_out_c2_dp_pp0_w0MixedNeumann_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Mixed Neumann &
                &(&
                &Inp. sym )", &
                t_SLP_out_c2_dp_pp0_w0MixedNeumann_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Mixed Neumann &
                &(&
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_dp_pp0_w0MixedNeumann_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Mixed Mixed &
                &(&
                &)", &
                t_SLP_out_c2_dp_pp0_w0MixedMixed_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Mixed Mixed &
                &(&
                &Inp. sil )", &
                t_SLP_out_c2_dp_pp0_w0MixedMixed_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Mixed Mixed &
                &(&
                &Inp. sym )", &
                t_SLP_out_c2_dp_pp0_w0MixedMixed_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Mixed Mixed &
                &(&
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_dp_pp0_w0MixedMixed_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Mixed Free &
                &(&
                &)", &
                t_SLP_out_c2_dp_pp0_w0MixedFree_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Mixed Free &
                &(&
                &Inp. sil )", &
                t_SLP_out_c2_dp_pp0_w0MixedFree_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Mixed Free &
                &(&
                &Inp. sym )", &
                t_SLP_out_c2_dp_pp0_w0MixedFree_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Mixed Free &
                &(&
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_dp_pp0_w0MixedFree_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Mixed Singular &
                &(&
                &)", &
                t_SLP_out_c2_dp_pp0_w0MixedSingular_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Mixed Singular &
                &(&
                &Inp. sil )", &
                t_SLP_out_c2_dp_pp0_w0MixedSingular_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Mixed Singular &
                &(&
                &Inp. sym )", &
                t_SLP_out_c2_dp_pp0_w0MixedSingular_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Mixed Singular &
                &(&
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_dp_pp0_w0MixedSingular_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Free Dirichlet &
                &(&
                &)", &
                t_SLP_out_c2_dp_pp0_w0FreeDirichlet_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Free Dirichlet &
                &(&
                &Inp. sil )", &
                t_SLP_out_c2_dp_pp0_w0FreeDirichlet_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Free Dirichlet &
                &(&
                &Inp. sym )", &
                t_SLP_out_c2_dp_pp0_w0FreeDirichlet_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Free Dirichlet &
                &(&
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_dp_pp0_w0FreeDirichlet_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Free Neumann &
                &(&
                &)", &
                t_SLP_out_c2_dp_pp0_w0FreeNeumann_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Free Neumann &
                &(&
                &Inp. sil )", &
                t_SLP_out_c2_dp_pp0_w0FreeNeumann_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Free Neumann &
                &(&
                &Inp. sym )", &
                t_SLP_out_c2_dp_pp0_w0FreeNeumann_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Free Neumann &
                &(&
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_dp_pp0_w0FreeNeumann_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Free Mixed &
                &(&
                &)", &
                t_SLP_out_c2_dp_pp0_w0FreeMixed_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Free Mixed &
                &(&
                &Inp. sil )", &
                t_SLP_out_c2_dp_pp0_w0FreeMixed_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Free Mixed &
                &(&
                &Inp. sym )", &
                t_SLP_out_c2_dp_pp0_w0FreeMixed_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Free Mixed &
                &(&
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_dp_pp0_w0FreeMixed_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Free Free &
                &(&
                &)", &
                t_SLP_out_c2_dp_pp0_w0FreeFree_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Free Free &
                &(&
                &Inp. sil )", &
                t_SLP_out_c2_dp_pp0_w0FreeFree_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Free Free &
                &(&
                &Inp. sym )", &
                t_SLP_out_c2_dp_pp0_w0FreeFree_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Free Free &
                &(&
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_dp_pp0_w0FreeFree_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Free Singular &
                &(&
                &)", &
                t_SLP_out_c2_dp_pp0_w0FreeSingular_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Free Singular &
                &(&
                &Inp. sil )", &
                t_SLP_out_c2_dp_pp0_w0FreeSingular_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Free Singular &
                &(&
                &Inp. sym )", &
                t_SLP_out_c2_dp_pp0_w0FreeSingular_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Free Singular &
                &(&
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_dp_pp0_w0FreeSingular_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Singular Dirichlet &
                &(&
                &)", &
                t_SLP_out_c2_dp_pp0_w0SingularDirichlet_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Singular Dirichlet &
                &(&
                &Inp. sil )", &
                t_SLP_out_c2_dp_pp0_w0SingularDirichlet_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Singular Dirichlet &
                &(&
                &Inp. sym )", &
                t_SLP_out_c2_dp_pp0_w0SingularDirichlet_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Singular Dirichlet &
                &(&
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_dp_pp0_w0SingularDirichlet_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Singular Neumann &
                &(&
                &)", &
                t_SLP_out_c2_dp_pp0_w0SingularNeumann_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Singular Neumann &
                &(&
                &Inp. sil )", &
                t_SLP_out_c2_dp_pp0_w0SingularNeumann_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Singular Neumann &
                &(&
                &Inp. sym )", &
                t_SLP_out_c2_dp_pp0_w0SingularNeumann_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Singular Neumann &
                &(&
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_dp_pp0_w0SingularNeumann_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Singular Mixed &
                &(&
                &)", &
                t_SLP_out_c2_dp_pp0_w0SingularMixed_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Singular Mixed &
                &(&
                &Inp. sil )", &
                t_SLP_out_c2_dp_pp0_w0SingularMixed_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Singular Mixed &
                &(&
                &Inp. sym )", &
                t_SLP_out_c2_dp_pp0_w0SingularMixed_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Singular Mixed &
                &(&
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_dp_pp0_w0SingularMixed_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Singular Free &
                &(&
                &)", &
                t_SLP_out_c2_dp_pp0_w0SingularFree_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Singular Free &
                &(&
                &Inp. sil )", &
                t_SLP_out_c2_dp_pp0_w0SingularFree_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Singular Free &
                &(&
                &Inp. sym )", &
                t_SLP_out_c2_dp_pp0_w0SingularFree_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Singular Free &
                &(&
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_dp_pp0_w0SingularFree_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Singular Singular &
                &(&
                &)", &
                t_SLP_out_c2_dp_pp0_w0SingularSingular_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Singular Singular &
                &(&
                &Inp. sil )", &
                t_SLP_out_c2_dp_pp0_w0SingularSingular_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Singular Singular &
                &(&
                &Inp. sym )", &
                t_SLP_out_c2_dp_pp0_w0SingularSingular_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Singular Singular &
                &(&
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_dp_pp0_w0SingularSingular_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Dirichlet Dirichlet &
                &(Inp. w &
                &)", &
                t_SLP_out_c2_dp_pp0_w1DirichletDirichlet_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Dirichlet Dirichlet &
                &(Inp. w &
                &Inp. sil )", &
                t_SLP_out_c2_dp_pp0_w1DirichletDirichlet_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Dirichlet Dirichlet &
                &(Inp. w &
                &Inp. sym )", &
                t_SLP_out_c2_dp_pp0_w1DirichletDirichlet_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Dirichlet Dirichlet &
                &(Inp. w &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_dp_pp0_w1DirichletDirichlet_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Dirichlet Neumann &
                &(Inp. w &
                &)", &
                t_SLP_out_c2_dp_pp0_w1DirichletNeumann_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Dirichlet Neumann &
                &(Inp. w &
                &Inp. sil )", &
                t_SLP_out_c2_dp_pp0_w1DirichletNeumann_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Dirichlet Neumann &
                &(Inp. w &
                &Inp. sym )", &
                t_SLP_out_c2_dp_pp0_w1DirichletNeumann_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Dirichlet Neumann &
                &(Inp. w &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_dp_pp0_w1DirichletNeumann_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Dirichlet Mixed &
                &(Inp. w &
                &)", &
                t_SLP_out_c2_dp_pp0_w1DirichletMixed_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Dirichlet Mixed &
                &(Inp. w &
                &Inp. sil )", &
                t_SLP_out_c2_dp_pp0_w1DirichletMixed_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Dirichlet Mixed &
                &(Inp. w &
                &Inp. sym )", &
                t_SLP_out_c2_dp_pp0_w1DirichletMixed_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Dirichlet Mixed &
                &(Inp. w &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_dp_pp0_w1DirichletMixed_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Dirichlet Free &
                &(Inp. w &
                &)", &
                t_SLP_out_c2_dp_pp0_w1DirichletFree_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Dirichlet Free &
                &(Inp. w &
                &Inp. sil )", &
                t_SLP_out_c2_dp_pp0_w1DirichletFree_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Dirichlet Free &
                &(Inp. w &
                &Inp. sym )", &
                t_SLP_out_c2_dp_pp0_w1DirichletFree_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Dirichlet Free &
                &(Inp. w &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_dp_pp0_w1DirichletFree_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Dirichlet Singular &
                &(Inp. w &
                &)", &
                t_SLP_out_c2_dp_pp0_w1DirichletSingular_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Dirichlet Singular &
                &(Inp. w &
                &Inp. sil )", &
                t_SLP_out_c2_dp_pp0_w1DirichletSingular_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Dirichlet Singular &
                &(Inp. w &
                &Inp. sym )", &
                t_SLP_out_c2_dp_pp0_w1DirichletSingular_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Dirichlet Singular &
                &(Inp. w &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_dp_pp0_w1DirichletSingular_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Neumann Dirichlet &
                &(Inp. w &
                &)", &
                t_SLP_out_c2_dp_pp0_w1NeumannDirichlet_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Neumann Dirichlet &
                &(Inp. w &
                &Inp. sil )", &
                t_SLP_out_c2_dp_pp0_w1NeumannDirichlet_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Neumann Dirichlet &
                &(Inp. w &
                &Inp. sym )", &
                t_SLP_out_c2_dp_pp0_w1NeumannDirichlet_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Neumann Dirichlet &
                &(Inp. w &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_dp_pp0_w1NeumannDirichlet_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Neumann Neumann &
                &(Inp. w &
                &)", &
                t_SLP_out_c2_dp_pp0_w1NeumannNeumann_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Neumann Neumann &
                &(Inp. w &
                &Inp. sil )", &
                t_SLP_out_c2_dp_pp0_w1NeumannNeumann_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Neumann Neumann &
                &(Inp. w &
                &Inp. sym )", &
                t_SLP_out_c2_dp_pp0_w1NeumannNeumann_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Neumann Neumann &
                &(Inp. w &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_dp_pp0_w1NeumannNeumann_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Neumann Mixed &
                &(Inp. w &
                &)", &
                t_SLP_out_c2_dp_pp0_w1NeumannMixed_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Neumann Mixed &
                &(Inp. w &
                &Inp. sil )", &
                t_SLP_out_c2_dp_pp0_w1NeumannMixed_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Neumann Mixed &
                &(Inp. w &
                &Inp. sym )", &
                t_SLP_out_c2_dp_pp0_w1NeumannMixed_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Neumann Mixed &
                &(Inp. w &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_dp_pp0_w1NeumannMixed_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Neumann Free &
                &(Inp. w &
                &)", &
                t_SLP_out_c2_dp_pp0_w1NeumannFree_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Neumann Free &
                &(Inp. w &
                &Inp. sil )", &
                t_SLP_out_c2_dp_pp0_w1NeumannFree_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Neumann Free &
                &(Inp. w &
                &Inp. sym )", &
                t_SLP_out_c2_dp_pp0_w1NeumannFree_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Neumann Free &
                &(Inp. w &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_dp_pp0_w1NeumannFree_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Neumann Singular &
                &(Inp. w &
                &)", &
                t_SLP_out_c2_dp_pp0_w1NeumannSingular_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Neumann Singular &
                &(Inp. w &
                &Inp. sil )", &
                t_SLP_out_c2_dp_pp0_w1NeumannSingular_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Neumann Singular &
                &(Inp. w &
                &Inp. sym )", &
                t_SLP_out_c2_dp_pp0_w1NeumannSingular_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Neumann Singular &
                &(Inp. w &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_dp_pp0_w1NeumannSingular_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Mixed Dirichlet &
                &(Inp. w &
                &)", &
                t_SLP_out_c2_dp_pp0_w1MixedDirichlet_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Mixed Dirichlet &
                &(Inp. w &
                &Inp. sil )", &
                t_SLP_out_c2_dp_pp0_w1MixedDirichlet_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Mixed Dirichlet &
                &(Inp. w &
                &Inp. sym )", &
                t_SLP_out_c2_dp_pp0_w1MixedDirichlet_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Mixed Dirichlet &
                &(Inp. w &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_dp_pp0_w1MixedDirichlet_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Mixed Neumann &
                &(Inp. w &
                &)", &
                t_SLP_out_c2_dp_pp0_w1MixedNeumann_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Mixed Neumann &
                &(Inp. w &
                &Inp. sil )", &
                t_SLP_out_c2_dp_pp0_w1MixedNeumann_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Mixed Neumann &
                &(Inp. w &
                &Inp. sym )", &
                t_SLP_out_c2_dp_pp0_w1MixedNeumann_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Mixed Neumann &
                &(Inp. w &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_dp_pp0_w1MixedNeumann_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Mixed Mixed &
                &(Inp. w &
                &)", &
                t_SLP_out_c2_dp_pp0_w1MixedMixed_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Mixed Mixed &
                &(Inp. w &
                &Inp. sil )", &
                t_SLP_out_c2_dp_pp0_w1MixedMixed_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Mixed Mixed &
                &(Inp. w &
                &Inp. sym )", &
                t_SLP_out_c2_dp_pp0_w1MixedMixed_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Mixed Mixed &
                &(Inp. w &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_dp_pp0_w1MixedMixed_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Mixed Free &
                &(Inp. w &
                &)", &
                t_SLP_out_c2_dp_pp0_w1MixedFree_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Mixed Free &
                &(Inp. w &
                &Inp. sil )", &
                t_SLP_out_c2_dp_pp0_w1MixedFree_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Mixed Free &
                &(Inp. w &
                &Inp. sym )", &
                t_SLP_out_c2_dp_pp0_w1MixedFree_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Mixed Free &
                &(Inp. w &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_dp_pp0_w1MixedFree_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Mixed Singular &
                &(Inp. w &
                &)", &
                t_SLP_out_c2_dp_pp0_w1MixedSingular_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Mixed Singular &
                &(Inp. w &
                &Inp. sil )", &
                t_SLP_out_c2_dp_pp0_w1MixedSingular_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Mixed Singular &
                &(Inp. w &
                &Inp. sym )", &
                t_SLP_out_c2_dp_pp0_w1MixedSingular_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Mixed Singular &
                &(Inp. w &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_dp_pp0_w1MixedSingular_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Free Dirichlet &
                &(Inp. w &
                &)", &
                t_SLP_out_c2_dp_pp0_w1FreeDirichlet_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Free Dirichlet &
                &(Inp. w &
                &Inp. sil )", &
                t_SLP_out_c2_dp_pp0_w1FreeDirichlet_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Free Dirichlet &
                &(Inp. w &
                &Inp. sym )", &
                t_SLP_out_c2_dp_pp0_w1FreeDirichlet_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Free Dirichlet &
                &(Inp. w &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_dp_pp0_w1FreeDirichlet_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Free Neumann &
                &(Inp. w &
                &)", &
                t_SLP_out_c2_dp_pp0_w1FreeNeumann_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Free Neumann &
                &(Inp. w &
                &Inp. sil )", &
                t_SLP_out_c2_dp_pp0_w1FreeNeumann_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Free Neumann &
                &(Inp. w &
                &Inp. sym )", &
                t_SLP_out_c2_dp_pp0_w1FreeNeumann_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Free Neumann &
                &(Inp. w &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_dp_pp0_w1FreeNeumann_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Free Mixed &
                &(Inp. w &
                &)", &
                t_SLP_out_c2_dp_pp0_w1FreeMixed_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Free Mixed &
                &(Inp. w &
                &Inp. sil )", &
                t_SLP_out_c2_dp_pp0_w1FreeMixed_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Free Mixed &
                &(Inp. w &
                &Inp. sym )", &
                t_SLP_out_c2_dp_pp0_w1FreeMixed_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Free Mixed &
                &(Inp. w &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_dp_pp0_w1FreeMixed_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Free Free &
                &(Inp. w &
                &)", &
                t_SLP_out_c2_dp_pp0_w1FreeFree_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Free Free &
                &(Inp. w &
                &Inp. sil )", &
                t_SLP_out_c2_dp_pp0_w1FreeFree_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Free Free &
                &(Inp. w &
                &Inp. sym )", &
                t_SLP_out_c2_dp_pp0_w1FreeFree_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Free Free &
                &(Inp. w &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_dp_pp0_w1FreeFree_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Free Singular &
                &(Inp. w &
                &)", &
                t_SLP_out_c2_dp_pp0_w1FreeSingular_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Free Singular &
                &(Inp. w &
                &Inp. sil )", &
                t_SLP_out_c2_dp_pp0_w1FreeSingular_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Free Singular &
                &(Inp. w &
                &Inp. sym )", &
                t_SLP_out_c2_dp_pp0_w1FreeSingular_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Free Singular &
                &(Inp. w &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_dp_pp0_w1FreeSingular_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Singular Dirichlet &
                &(Inp. w &
                &)", &
                t_SLP_out_c2_dp_pp0_w1SingularDirichlet_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Singular Dirichlet &
                &(Inp. w &
                &Inp. sil )", &
                t_SLP_out_c2_dp_pp0_w1SingularDirichlet_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Singular Dirichlet &
                &(Inp. w &
                &Inp. sym )", &
                t_SLP_out_c2_dp_pp0_w1SingularDirichlet_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Singular Dirichlet &
                &(Inp. w &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_dp_pp0_w1SingularDirichlet_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Singular Neumann &
                &(Inp. w &
                &)", &
                t_SLP_out_c2_dp_pp0_w1SingularNeumann_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Singular Neumann &
                &(Inp. w &
                &Inp. sil )", &
                t_SLP_out_c2_dp_pp0_w1SingularNeumann_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Singular Neumann &
                &(Inp. w &
                &Inp. sym )", &
                t_SLP_out_c2_dp_pp0_w1SingularNeumann_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Singular Neumann &
                &(Inp. w &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_dp_pp0_w1SingularNeumann_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Singular Mixed &
                &(Inp. w &
                &)", &
                t_SLP_out_c2_dp_pp0_w1SingularMixed_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Singular Mixed &
                &(Inp. w &
                &Inp. sil )", &
                t_SLP_out_c2_dp_pp0_w1SingularMixed_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Singular Mixed &
                &(Inp. w &
                &Inp. sym )", &
                t_SLP_out_c2_dp_pp0_w1SingularMixed_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Singular Mixed &
                &(Inp. w &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_dp_pp0_w1SingularMixed_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Singular Free &
                &(Inp. w &
                &)", &
                t_SLP_out_c2_dp_pp0_w1SingularFree_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Singular Free &
                &(Inp. w &
                &Inp. sil )", &
                t_SLP_out_c2_dp_pp0_w1SingularFree_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Singular Free &
                &(Inp. w &
                &Inp. sym )", &
                t_SLP_out_c2_dp_pp0_w1SingularFree_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Singular Free &
                &(Inp. w &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_dp_pp0_w1SingularFree_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Singular Singular &
                &(Inp. w &
                &)", &
                t_SLP_out_c2_dp_pp0_w1SingularSingular_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Singular Singular &
                &(Inp. w &
                &Inp. sil )", &
                t_SLP_out_c2_dp_pp0_w1SingularSingular_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Singular Singular &
                &(Inp. w &
                &Inp. sym )", &
                t_SLP_out_c2_dp_pp0_w1SingularSingular_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Singular Singular &
                &(Inp. w &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_dp_pp0_w1SingularSingular_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Dirichlet Dirichlet &
                &(Inp. pp &
                &)", &
                t_SLP_out_c2_dp_pp1_w0DirichletDirichlet_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Dirichlet Dirichlet &
                &(Inp. pp &
                &Inp. sil )", &
                t_SLP_out_c2_dp_pp1_w0DirichletDirichlet_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Dirichlet Dirichlet &
                &(Inp. pp &
                &Inp. sym )", &
                t_SLP_out_c2_dp_pp1_w0DirichletDirichlet_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Dirichlet Dirichlet &
                &(Inp. pp &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_dp_pp1_w0DirichletDirichlet_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Dirichlet Neumann &
                &(Inp. pp &
                &)", &
                t_SLP_out_c2_dp_pp1_w0DirichletNeumann_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Dirichlet Neumann &
                &(Inp. pp &
                &Inp. sil )", &
                t_SLP_out_c2_dp_pp1_w0DirichletNeumann_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Dirichlet Neumann &
                &(Inp. pp &
                &Inp. sym )", &
                t_SLP_out_c2_dp_pp1_w0DirichletNeumann_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Dirichlet Neumann &
                &(Inp. pp &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_dp_pp1_w0DirichletNeumann_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Dirichlet Mixed &
                &(Inp. pp &
                &)", &
                t_SLP_out_c2_dp_pp1_w0DirichletMixed_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Dirichlet Mixed &
                &(Inp. pp &
                &Inp. sil )", &
                t_SLP_out_c2_dp_pp1_w0DirichletMixed_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Dirichlet Mixed &
                &(Inp. pp &
                &Inp. sym )", &
                t_SLP_out_c2_dp_pp1_w0DirichletMixed_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Dirichlet Mixed &
                &(Inp. pp &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_dp_pp1_w0DirichletMixed_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Dirichlet Free &
                &(Inp. pp &
                &)", &
                t_SLP_out_c2_dp_pp1_w0DirichletFree_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Dirichlet Free &
                &(Inp. pp &
                &Inp. sil )", &
                t_SLP_out_c2_dp_pp1_w0DirichletFree_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Dirichlet Free &
                &(Inp. pp &
                &Inp. sym )", &
                t_SLP_out_c2_dp_pp1_w0DirichletFree_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Dirichlet Free &
                &(Inp. pp &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_dp_pp1_w0DirichletFree_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Dirichlet Singular &
                &(Inp. pp &
                &)", &
                t_SLP_out_c2_dp_pp1_w0DirichletSingular_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Dirichlet Singular &
                &(Inp. pp &
                &Inp. sil )", &
                t_SLP_out_c2_dp_pp1_w0DirichletSingular_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Dirichlet Singular &
                &(Inp. pp &
                &Inp. sym )", &
                t_SLP_out_c2_dp_pp1_w0DirichletSingular_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Dirichlet Singular &
                &(Inp. pp &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_dp_pp1_w0DirichletSingular_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Neumann Dirichlet &
                &(Inp. pp &
                &)", &
                t_SLP_out_c2_dp_pp1_w0NeumannDirichlet_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Neumann Dirichlet &
                &(Inp. pp &
                &Inp. sil )", &
                t_SLP_out_c2_dp_pp1_w0NeumannDirichlet_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Neumann Dirichlet &
                &(Inp. pp &
                &Inp. sym )", &
                t_SLP_out_c2_dp_pp1_w0NeumannDirichlet_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Neumann Dirichlet &
                &(Inp. pp &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_dp_pp1_w0NeumannDirichlet_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Neumann Neumann &
                &(Inp. pp &
                &)", &
                t_SLP_out_c2_dp_pp1_w0NeumannNeumann_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Neumann Neumann &
                &(Inp. pp &
                &Inp. sil )", &
                t_SLP_out_c2_dp_pp1_w0NeumannNeumann_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Neumann Neumann &
                &(Inp. pp &
                &Inp. sym )", &
                t_SLP_out_c2_dp_pp1_w0NeumannNeumann_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Neumann Neumann &
                &(Inp. pp &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_dp_pp1_w0NeumannNeumann_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Neumann Mixed &
                &(Inp. pp &
                &)", &
                t_SLP_out_c2_dp_pp1_w0NeumannMixed_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Neumann Mixed &
                &(Inp. pp &
                &Inp. sil )", &
                t_SLP_out_c2_dp_pp1_w0NeumannMixed_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Neumann Mixed &
                &(Inp. pp &
                &Inp. sym )", &
                t_SLP_out_c2_dp_pp1_w0NeumannMixed_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Neumann Mixed &
                &(Inp. pp &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_dp_pp1_w0NeumannMixed_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Neumann Free &
                &(Inp. pp &
                &)", &
                t_SLP_out_c2_dp_pp1_w0NeumannFree_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Neumann Free &
                &(Inp. pp &
                &Inp. sil )", &
                t_SLP_out_c2_dp_pp1_w0NeumannFree_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Neumann Free &
                &(Inp. pp &
                &Inp. sym )", &
                t_SLP_out_c2_dp_pp1_w0NeumannFree_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Neumann Free &
                &(Inp. pp &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_dp_pp1_w0NeumannFree_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Neumann Singular &
                &(Inp. pp &
                &)", &
                t_SLP_out_c2_dp_pp1_w0NeumannSingular_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Neumann Singular &
                &(Inp. pp &
                &Inp. sil )", &
                t_SLP_out_c2_dp_pp1_w0NeumannSingular_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Neumann Singular &
                &(Inp. pp &
                &Inp. sym )", &
                t_SLP_out_c2_dp_pp1_w0NeumannSingular_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Neumann Singular &
                &(Inp. pp &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_dp_pp1_w0NeumannSingular_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Mixed Dirichlet &
                &(Inp. pp &
                &)", &
                t_SLP_out_c2_dp_pp1_w0MixedDirichlet_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Mixed Dirichlet &
                &(Inp. pp &
                &Inp. sil )", &
                t_SLP_out_c2_dp_pp1_w0MixedDirichlet_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Mixed Dirichlet &
                &(Inp. pp &
                &Inp. sym )", &
                t_SLP_out_c2_dp_pp1_w0MixedDirichlet_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Mixed Dirichlet &
                &(Inp. pp &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_dp_pp1_w0MixedDirichlet_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Mixed Neumann &
                &(Inp. pp &
                &)", &
                t_SLP_out_c2_dp_pp1_w0MixedNeumann_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Mixed Neumann &
                &(Inp. pp &
                &Inp. sil )", &
                t_SLP_out_c2_dp_pp1_w0MixedNeumann_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Mixed Neumann &
                &(Inp. pp &
                &Inp. sym )", &
                t_SLP_out_c2_dp_pp1_w0MixedNeumann_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Mixed Neumann &
                &(Inp. pp &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_dp_pp1_w0MixedNeumann_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Mixed Mixed &
                &(Inp. pp &
                &)", &
                t_SLP_out_c2_dp_pp1_w0MixedMixed_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Mixed Mixed &
                &(Inp. pp &
                &Inp. sil )", &
                t_SLP_out_c2_dp_pp1_w0MixedMixed_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Mixed Mixed &
                &(Inp. pp &
                &Inp. sym )", &
                t_SLP_out_c2_dp_pp1_w0MixedMixed_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Mixed Mixed &
                &(Inp. pp &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_dp_pp1_w0MixedMixed_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Mixed Free &
                &(Inp. pp &
                &)", &
                t_SLP_out_c2_dp_pp1_w0MixedFree_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Mixed Free &
                &(Inp. pp &
                &Inp. sil )", &
                t_SLP_out_c2_dp_pp1_w0MixedFree_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Mixed Free &
                &(Inp. pp &
                &Inp. sym )", &
                t_SLP_out_c2_dp_pp1_w0MixedFree_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Mixed Free &
                &(Inp. pp &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_dp_pp1_w0MixedFree_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Mixed Singular &
                &(Inp. pp &
                &)", &
                t_SLP_out_c2_dp_pp1_w0MixedSingular_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Mixed Singular &
                &(Inp. pp &
                &Inp. sil )", &
                t_SLP_out_c2_dp_pp1_w0MixedSingular_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Mixed Singular &
                &(Inp. pp &
                &Inp. sym )", &
                t_SLP_out_c2_dp_pp1_w0MixedSingular_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Mixed Singular &
                &(Inp. pp &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_dp_pp1_w0MixedSingular_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Free Dirichlet &
                &(Inp. pp &
                &)", &
                t_SLP_out_c2_dp_pp1_w0FreeDirichlet_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Free Dirichlet &
                &(Inp. pp &
                &Inp. sil )", &
                t_SLP_out_c2_dp_pp1_w0FreeDirichlet_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Free Dirichlet &
                &(Inp. pp &
                &Inp. sym )", &
                t_SLP_out_c2_dp_pp1_w0FreeDirichlet_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Free Dirichlet &
                &(Inp. pp &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_dp_pp1_w0FreeDirichlet_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Free Neumann &
                &(Inp. pp &
                &)", &
                t_SLP_out_c2_dp_pp1_w0FreeNeumann_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Free Neumann &
                &(Inp. pp &
                &Inp. sil )", &
                t_SLP_out_c2_dp_pp1_w0FreeNeumann_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Free Neumann &
                &(Inp. pp &
                &Inp. sym )", &
                t_SLP_out_c2_dp_pp1_w0FreeNeumann_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Free Neumann &
                &(Inp. pp &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_dp_pp1_w0FreeNeumann_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Free Mixed &
                &(Inp. pp &
                &)", &
                t_SLP_out_c2_dp_pp1_w0FreeMixed_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Free Mixed &
                &(Inp. pp &
                &Inp. sil )", &
                t_SLP_out_c2_dp_pp1_w0FreeMixed_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Free Mixed &
                &(Inp. pp &
                &Inp. sym )", &
                t_SLP_out_c2_dp_pp1_w0FreeMixed_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Free Mixed &
                &(Inp. pp &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_dp_pp1_w0FreeMixed_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Free Free &
                &(Inp. pp &
                &)", &
                t_SLP_out_c2_dp_pp1_w0FreeFree_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Free Free &
                &(Inp. pp &
                &Inp. sil )", &
                t_SLP_out_c2_dp_pp1_w0FreeFree_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Free Free &
                &(Inp. pp &
                &Inp. sym )", &
                t_SLP_out_c2_dp_pp1_w0FreeFree_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Free Free &
                &(Inp. pp &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_dp_pp1_w0FreeFree_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Free Singular &
                &(Inp. pp &
                &)", &
                t_SLP_out_c2_dp_pp1_w0FreeSingular_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Free Singular &
                &(Inp. pp &
                &Inp. sil )", &
                t_SLP_out_c2_dp_pp1_w0FreeSingular_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Free Singular &
                &(Inp. pp &
                &Inp. sym )", &
                t_SLP_out_c2_dp_pp1_w0FreeSingular_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Free Singular &
                &(Inp. pp &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_dp_pp1_w0FreeSingular_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Singular Dirichlet &
                &(Inp. pp &
                &)", &
                t_SLP_out_c2_dp_pp1_w0SingularDirichlet_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Singular Dirichlet &
                &(Inp. pp &
                &Inp. sil )", &
                t_SLP_out_c2_dp_pp1_w0SingularDirichlet_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Singular Dirichlet &
                &(Inp. pp &
                &Inp. sym )", &
                t_SLP_out_c2_dp_pp1_w0SingularDirichlet_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Singular Dirichlet &
                &(Inp. pp &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_dp_pp1_w0SingularDirichlet_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Singular Neumann &
                &(Inp. pp &
                &)", &
                t_SLP_out_c2_dp_pp1_w0SingularNeumann_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Singular Neumann &
                &(Inp. pp &
                &Inp. sil )", &
                t_SLP_out_c2_dp_pp1_w0SingularNeumann_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Singular Neumann &
                &(Inp. pp &
                &Inp. sym )", &
                t_SLP_out_c2_dp_pp1_w0SingularNeumann_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Singular Neumann &
                &(Inp. pp &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_dp_pp1_w0SingularNeumann_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Singular Mixed &
                &(Inp. pp &
                &)", &
                t_SLP_out_c2_dp_pp1_w0SingularMixed_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Singular Mixed &
                &(Inp. pp &
                &Inp. sil )", &
                t_SLP_out_c2_dp_pp1_w0SingularMixed_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Singular Mixed &
                &(Inp. pp &
                &Inp. sym )", &
                t_SLP_out_c2_dp_pp1_w0SingularMixed_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Singular Mixed &
                &(Inp. pp &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_dp_pp1_w0SingularMixed_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Singular Free &
                &(Inp. pp &
                &)", &
                t_SLP_out_c2_dp_pp1_w0SingularFree_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Singular Free &
                &(Inp. pp &
                &Inp. sil )", &
                t_SLP_out_c2_dp_pp1_w0SingularFree_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Singular Free &
                &(Inp. pp &
                &Inp. sym )", &
                t_SLP_out_c2_dp_pp1_w0SingularFree_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Singular Free &
                &(Inp. pp &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_dp_pp1_w0SingularFree_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Singular Singular &
                &(Inp. pp &
                &)", &
                t_SLP_out_c2_dp_pp1_w0SingularSingular_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Singular Singular &
                &(Inp. pp &
                &Inp. sil )", &
                t_SLP_out_c2_dp_pp1_w0SingularSingular_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Singular Singular &
                &(Inp. pp &
                &Inp. sym )", &
                t_SLP_out_c2_dp_pp1_w0SingularSingular_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Singular Singular &
                &(Inp. pp &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_dp_pp1_w0SingularSingular_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Dirichlet Dirichlet &
                &(Inp. pp Inp. w &
                &)", &
                t_SLP_out_c2_dp_pp1_w1DirichletDirichlet_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Dirichlet Dirichlet &
                &(Inp. pp Inp. w &
                &Inp. sil )", &
                t_SLP_out_c2_dp_pp1_w1DirichletDirichlet_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Dirichlet Dirichlet &
                &(Inp. pp Inp. w &
                &Inp. sym )", &
                t_SLP_out_c2_dp_pp1_w1DirichletDirichlet_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Dirichlet Dirichlet &
                &(Inp. pp Inp. w &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_dp_pp1_w1DirichletDirichlet_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Dirichlet Neumann &
                &(Inp. pp Inp. w &
                &)", &
                t_SLP_out_c2_dp_pp1_w1DirichletNeumann_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Dirichlet Neumann &
                &(Inp. pp Inp. w &
                &Inp. sil )", &
                t_SLP_out_c2_dp_pp1_w1DirichletNeumann_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Dirichlet Neumann &
                &(Inp. pp Inp. w &
                &Inp. sym )", &
                t_SLP_out_c2_dp_pp1_w1DirichletNeumann_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Dirichlet Neumann &
                &(Inp. pp Inp. w &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_dp_pp1_w1DirichletNeumann_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Dirichlet Mixed &
                &(Inp. pp Inp. w &
                &)", &
                t_SLP_out_c2_dp_pp1_w1DirichletMixed_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Dirichlet Mixed &
                &(Inp. pp Inp. w &
                &Inp. sil )", &
                t_SLP_out_c2_dp_pp1_w1DirichletMixed_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Dirichlet Mixed &
                &(Inp. pp Inp. w &
                &Inp. sym )", &
                t_SLP_out_c2_dp_pp1_w1DirichletMixed_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Dirichlet Mixed &
                &(Inp. pp Inp. w &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_dp_pp1_w1DirichletMixed_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Dirichlet Free &
                &(Inp. pp Inp. w &
                &)", &
                t_SLP_out_c2_dp_pp1_w1DirichletFree_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Dirichlet Free &
                &(Inp. pp Inp. w &
                &Inp. sil )", &
                t_SLP_out_c2_dp_pp1_w1DirichletFree_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Dirichlet Free &
                &(Inp. pp Inp. w &
                &Inp. sym )", &
                t_SLP_out_c2_dp_pp1_w1DirichletFree_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Dirichlet Free &
                &(Inp. pp Inp. w &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_dp_pp1_w1DirichletFree_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Dirichlet Singular &
                &(Inp. pp Inp. w &
                &)", &
                t_SLP_out_c2_dp_pp1_w1DirichletSingular_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Dirichlet Singular &
                &(Inp. pp Inp. w &
                &Inp. sil )", &
                t_SLP_out_c2_dp_pp1_w1DirichletSingular_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Dirichlet Singular &
                &(Inp. pp Inp. w &
                &Inp. sym )", &
                t_SLP_out_c2_dp_pp1_w1DirichletSingular_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Dirichlet Singular &
                &(Inp. pp Inp. w &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_dp_pp1_w1DirichletSingular_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Neumann Dirichlet &
                &(Inp. pp Inp. w &
                &)", &
                t_SLP_out_c2_dp_pp1_w1NeumannDirichlet_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Neumann Dirichlet &
                &(Inp. pp Inp. w &
                &Inp. sil )", &
                t_SLP_out_c2_dp_pp1_w1NeumannDirichlet_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Neumann Dirichlet &
                &(Inp. pp Inp. w &
                &Inp. sym )", &
                t_SLP_out_c2_dp_pp1_w1NeumannDirichlet_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Neumann Dirichlet &
                &(Inp. pp Inp. w &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_dp_pp1_w1NeumannDirichlet_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Neumann Neumann &
                &(Inp. pp Inp. w &
                &)", &
                t_SLP_out_c2_dp_pp1_w1NeumannNeumann_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Neumann Neumann &
                &(Inp. pp Inp. w &
                &Inp. sil )", &
                t_SLP_out_c2_dp_pp1_w1NeumannNeumann_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Neumann Neumann &
                &(Inp. pp Inp. w &
                &Inp. sym )", &
                t_SLP_out_c2_dp_pp1_w1NeumannNeumann_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Neumann Neumann &
                &(Inp. pp Inp. w &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_dp_pp1_w1NeumannNeumann_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Neumann Mixed &
                &(Inp. pp Inp. w &
                &)", &
                t_SLP_out_c2_dp_pp1_w1NeumannMixed_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Neumann Mixed &
                &(Inp. pp Inp. w &
                &Inp. sil )", &
                t_SLP_out_c2_dp_pp1_w1NeumannMixed_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Neumann Mixed &
                &(Inp. pp Inp. w &
                &Inp. sym )", &
                t_SLP_out_c2_dp_pp1_w1NeumannMixed_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Neumann Mixed &
                &(Inp. pp Inp. w &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_dp_pp1_w1NeumannMixed_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Neumann Free &
                &(Inp. pp Inp. w &
                &)", &
                t_SLP_out_c2_dp_pp1_w1NeumannFree_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Neumann Free &
                &(Inp. pp Inp. w &
                &Inp. sil )", &
                t_SLP_out_c2_dp_pp1_w1NeumannFree_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Neumann Free &
                &(Inp. pp Inp. w &
                &Inp. sym )", &
                t_SLP_out_c2_dp_pp1_w1NeumannFree_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Neumann Free &
                &(Inp. pp Inp. w &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_dp_pp1_w1NeumannFree_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Neumann Singular &
                &(Inp. pp Inp. w &
                &)", &
                t_SLP_out_c2_dp_pp1_w1NeumannSingular_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Neumann Singular &
                &(Inp. pp Inp. w &
                &Inp. sil )", &
                t_SLP_out_c2_dp_pp1_w1NeumannSingular_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Neumann Singular &
                &(Inp. pp Inp. w &
                &Inp. sym )", &
                t_SLP_out_c2_dp_pp1_w1NeumannSingular_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Neumann Singular &
                &(Inp. pp Inp. w &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_dp_pp1_w1NeumannSingular_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Mixed Dirichlet &
                &(Inp. pp Inp. w &
                &)", &
                t_SLP_out_c2_dp_pp1_w1MixedDirichlet_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Mixed Dirichlet &
                &(Inp. pp Inp. w &
                &Inp. sil )", &
                t_SLP_out_c2_dp_pp1_w1MixedDirichlet_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Mixed Dirichlet &
                &(Inp. pp Inp. w &
                &Inp. sym )", &
                t_SLP_out_c2_dp_pp1_w1MixedDirichlet_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Mixed Dirichlet &
                &(Inp. pp Inp. w &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_dp_pp1_w1MixedDirichlet_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Mixed Neumann &
                &(Inp. pp Inp. w &
                &)", &
                t_SLP_out_c2_dp_pp1_w1MixedNeumann_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Mixed Neumann &
                &(Inp. pp Inp. w &
                &Inp. sil )", &
                t_SLP_out_c2_dp_pp1_w1MixedNeumann_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Mixed Neumann &
                &(Inp. pp Inp. w &
                &Inp. sym )", &
                t_SLP_out_c2_dp_pp1_w1MixedNeumann_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Mixed Neumann &
                &(Inp. pp Inp. w &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_dp_pp1_w1MixedNeumann_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Mixed Mixed &
                &(Inp. pp Inp. w &
                &)", &
                t_SLP_out_c2_dp_pp1_w1MixedMixed_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Mixed Mixed &
                &(Inp. pp Inp. w &
                &Inp. sil )", &
                t_SLP_out_c2_dp_pp1_w1MixedMixed_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Mixed Mixed &
                &(Inp. pp Inp. w &
                &Inp. sym )", &
                t_SLP_out_c2_dp_pp1_w1MixedMixed_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Mixed Mixed &
                &(Inp. pp Inp. w &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_dp_pp1_w1MixedMixed_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Mixed Free &
                &(Inp. pp Inp. w &
                &)", &
                t_SLP_out_c2_dp_pp1_w1MixedFree_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Mixed Free &
                &(Inp. pp Inp. w &
                &Inp. sil )", &
                t_SLP_out_c2_dp_pp1_w1MixedFree_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Mixed Free &
                &(Inp. pp Inp. w &
                &Inp. sym )", &
                t_SLP_out_c2_dp_pp1_w1MixedFree_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Mixed Free &
                &(Inp. pp Inp. w &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_dp_pp1_w1MixedFree_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Mixed Singular &
                &(Inp. pp Inp. w &
                &)", &
                t_SLP_out_c2_dp_pp1_w1MixedSingular_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Mixed Singular &
                &(Inp. pp Inp. w &
                &Inp. sil )", &
                t_SLP_out_c2_dp_pp1_w1MixedSingular_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Mixed Singular &
                &(Inp. pp Inp. w &
                &Inp. sym )", &
                t_SLP_out_c2_dp_pp1_w1MixedSingular_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Mixed Singular &
                &(Inp. pp Inp. w &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_dp_pp1_w1MixedSingular_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Free Dirichlet &
                &(Inp. pp Inp. w &
                &)", &
                t_SLP_out_c2_dp_pp1_w1FreeDirichlet_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Free Dirichlet &
                &(Inp. pp Inp. w &
                &Inp. sil )", &
                t_SLP_out_c2_dp_pp1_w1FreeDirichlet_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Free Dirichlet &
                &(Inp. pp Inp. w &
                &Inp. sym )", &
                t_SLP_out_c2_dp_pp1_w1FreeDirichlet_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Free Dirichlet &
                &(Inp. pp Inp. w &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_dp_pp1_w1FreeDirichlet_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Free Neumann &
                &(Inp. pp Inp. w &
                &)", &
                t_SLP_out_c2_dp_pp1_w1FreeNeumann_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Free Neumann &
                &(Inp. pp Inp. w &
                &Inp. sil )", &
                t_SLP_out_c2_dp_pp1_w1FreeNeumann_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Free Neumann &
                &(Inp. pp Inp. w &
                &Inp. sym )", &
                t_SLP_out_c2_dp_pp1_w1FreeNeumann_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Free Neumann &
                &(Inp. pp Inp. w &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_dp_pp1_w1FreeNeumann_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Free Mixed &
                &(Inp. pp Inp. w &
                &)", &
                t_SLP_out_c2_dp_pp1_w1FreeMixed_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Free Mixed &
                &(Inp. pp Inp. w &
                &Inp. sil )", &
                t_SLP_out_c2_dp_pp1_w1FreeMixed_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Free Mixed &
                &(Inp. pp Inp. w &
                &Inp. sym )", &
                t_SLP_out_c2_dp_pp1_w1FreeMixed_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Free Mixed &
                &(Inp. pp Inp. w &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_dp_pp1_w1FreeMixed_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Free Free &
                &(Inp. pp Inp. w &
                &)", &
                t_SLP_out_c2_dp_pp1_w1FreeFree_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Free Free &
                &(Inp. pp Inp. w &
                &Inp. sil )", &
                t_SLP_out_c2_dp_pp1_w1FreeFree_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Free Free &
                &(Inp. pp Inp. w &
                &Inp. sym )", &
                t_SLP_out_c2_dp_pp1_w1FreeFree_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Free Free &
                &(Inp. pp Inp. w &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_dp_pp1_w1FreeFree_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Free Singular &
                &(Inp. pp Inp. w &
                &)", &
                t_SLP_out_c2_dp_pp1_w1FreeSingular_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Free Singular &
                &(Inp. pp Inp. w &
                &Inp. sil )", &
                t_SLP_out_c2_dp_pp1_w1FreeSingular_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Free Singular &
                &(Inp. pp Inp. w &
                &Inp. sym )", &
                t_SLP_out_c2_dp_pp1_w1FreeSingular_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Free Singular &
                &(Inp. pp Inp. w &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_dp_pp1_w1FreeSingular_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Singular Dirichlet &
                &(Inp. pp Inp. w &
                &)", &
                t_SLP_out_c2_dp_pp1_w1SingularDirichlet_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Singular Dirichlet &
                &(Inp. pp Inp. w &
                &Inp. sil )", &
                t_SLP_out_c2_dp_pp1_w1SingularDirichlet_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Singular Dirichlet &
                &(Inp. pp Inp. w &
                &Inp. sym )", &
                t_SLP_out_c2_dp_pp1_w1SingularDirichlet_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Singular Dirichlet &
                &(Inp. pp Inp. w &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_dp_pp1_w1SingularDirichlet_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Singular Neumann &
                &(Inp. pp Inp. w &
                &)", &
                t_SLP_out_c2_dp_pp1_w1SingularNeumann_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Singular Neumann &
                &(Inp. pp Inp. w &
                &Inp. sil )", &
                t_SLP_out_c2_dp_pp1_w1SingularNeumann_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Singular Neumann &
                &(Inp. pp Inp. w &
                &Inp. sym )", &
                t_SLP_out_c2_dp_pp1_w1SingularNeumann_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Singular Neumann &
                &(Inp. pp Inp. w &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_dp_pp1_w1SingularNeumann_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Singular Mixed &
                &(Inp. pp Inp. w &
                &)", &
                t_SLP_out_c2_dp_pp1_w1SingularMixed_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Singular Mixed &
                &(Inp. pp Inp. w &
                &Inp. sil )", &
                t_SLP_out_c2_dp_pp1_w1SingularMixed_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Singular Mixed &
                &(Inp. pp Inp. w &
                &Inp. sym )", &
                t_SLP_out_c2_dp_pp1_w1SingularMixed_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Singular Mixed &
                &(Inp. pp Inp. w &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_dp_pp1_w1SingularMixed_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Singular Free &
                &(Inp. pp Inp. w &
                &)", &
                t_SLP_out_c2_dp_pp1_w1SingularFree_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Singular Free &
                &(Inp. pp Inp. w &
                &Inp. sil )", &
                t_SLP_out_c2_dp_pp1_w1SingularFree_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Singular Free &
                &(Inp. pp Inp. w &
                &Inp. sym )", &
                t_SLP_out_c2_dp_pp1_w1SingularFree_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Singular Free &
                &(Inp. pp Inp. w &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_dp_pp1_w1SingularFree_s1_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Singular Singular &
                &(Inp. pp Inp. w &
                &)", &
                t_SLP_out_c2_dp_pp1_w1SingularSingular_s0_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Singular Singular &
                &(Inp. pp Inp. w &
                &Inp. sil )", &
                t_SLP_out_c2_dp_pp1_w1SingularSingular_s0_sil1) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Singular Singular &
                &(Inp. pp Inp. w &
                &Inp. sym )", &
                t_SLP_out_c2_dp_pp1_w1SingularSingular_s1_sil0) &
                , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
                &real (dp) SLP: Singular Singular &
                &(Inp. pp Inp. w &
                &Inp. sym Inp. sil )", &
                t_SLP_out_c2_dp_pp1_w1SingularSingular_s1_sil1) &
              , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
              &real (sp) SLP: Periodic Periodic &
              &(&
              &)", &
              t_SLP_out_c2_sp_pp0_w0PeriodicPeriodic_s0_sil0) &
              , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
              &real (sp) SLP: Periodic Periodic &
              &(&
              &Inp. sil )", &
              t_SLP_out_c2_sp_pp0_w0PeriodicPeriodic_s0_sil1) &
              , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
              &real (sp) SLP: Periodic Periodic &
              &(&
              &Inp. sym )", &
              t_SLP_out_c2_sp_pp0_w0PeriodicPeriodic_s1_sil0) &
              , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
              &real (sp) SLP: Periodic Periodic &
              &(&
              &Inp. sym Inp. sil )", &
              t_SLP_out_c2_sp_pp0_w0PeriodicPeriodic_s1_sil1) &
              , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
              &real (sp) SLP: Periodic Periodic &
              &(Inp. w &
              &)", &
              t_SLP_out_c2_sp_pp0_w1PeriodicPeriodic_s0_sil0) &
              , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
              &real (sp) SLP: Periodic Periodic &
              &(Inp. w &
              &Inp. sil )", &
              t_SLP_out_c2_sp_pp0_w1PeriodicPeriodic_s0_sil1) &
              , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
              &real (sp) SLP: Periodic Periodic &
              &(Inp. w &
              &Inp. sym )", &
              t_SLP_out_c2_sp_pp0_w1PeriodicPeriodic_s1_sil0) &
              , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
              &real (sp) SLP: Periodic Periodic &
              &(Inp. w &
              &Inp. sym Inp. sil )", &
              t_SLP_out_c2_sp_pp0_w1PeriodicPeriodic_s1_sil1) &
              , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
              &real (sp) SLP: Periodic Periodic &
              &(Inp. pp &
              &)", &
              t_SLP_out_c2_sp_pp1_w0PeriodicPeriodic_s0_sil0) &
              , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
              &real (sp) SLP: Periodic Periodic &
              &(Inp. pp &
              &Inp. sil )", &
              t_SLP_out_c2_sp_pp1_w0PeriodicPeriodic_s0_sil1) &
              , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
              &real (sp) SLP: Periodic Periodic &
              &(Inp. pp &
              &Inp. sym )", &
              t_SLP_out_c2_sp_pp1_w0PeriodicPeriodic_s1_sil0) &
              , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
              &real (sp) SLP: Periodic Periodic &
              &(Inp. pp &
              &Inp. sym Inp. sil )", &
              t_SLP_out_c2_sp_pp1_w0PeriodicPeriodic_s1_sil1) &
              , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
              &real (sp) SLP: Periodic Periodic &
              &(Inp. pp Inp. w &
              &)", &
              t_SLP_out_c2_sp_pp1_w1PeriodicPeriodic_s0_sil0) &
              , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
              &real (sp) SLP: Periodic Periodic &
              &(Inp. pp Inp. w &
              &Inp. sil )", &
              t_SLP_out_c2_sp_pp1_w1PeriodicPeriodic_s0_sil1) &
              , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
              &real (sp) SLP: Periodic Periodic &
              &(Inp. pp Inp. w &
              &Inp. sym )", &
              t_SLP_out_c2_sp_pp1_w1PeriodicPeriodic_s1_sil0) &
              , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
              &real (sp) SLP: Periodic Periodic &
              &(Inp. pp Inp. w &
              &Inp. sym Inp. sil )", &
              t_SLP_out_c2_sp_pp1_w1PeriodicPeriodic_s1_sil1) &
              , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
              &real (dp) SLP: Periodic Periodic &
              &(&
              &)", &
              t_SLP_out_c2_dp_pp0_w0PeriodicPeriodic_s0_sil0) &
              , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
              &real (dp) SLP: Periodic Periodic &
              &(&
              &Inp. sil )", &
              t_SLP_out_c2_dp_pp0_w0PeriodicPeriodic_s0_sil1) &
              , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
              &real (dp) SLP: Periodic Periodic &
              &(&
              &Inp. sym )", &
              t_SLP_out_c2_dp_pp0_w0PeriodicPeriodic_s1_sil0) &
              , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
              &real (dp) SLP: Periodic Periodic &
              &(&
              &Inp. sym Inp. sil )", &
              t_SLP_out_c2_dp_pp0_w0PeriodicPeriodic_s1_sil1) &
              , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
              &real (dp) SLP: Periodic Periodic &
              &(Inp. w &
              &)", &
              t_SLP_out_c2_dp_pp0_w1PeriodicPeriodic_s0_sil0) &
              , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
              &real (dp) SLP: Periodic Periodic &
              &(Inp. w &
              &Inp. sil )", &
              t_SLP_out_c2_dp_pp0_w1PeriodicPeriodic_s0_sil1) &
              , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
              &real (dp) SLP: Periodic Periodic &
              &(Inp. w &
              &Inp. sym )", &
              t_SLP_out_c2_dp_pp0_w1PeriodicPeriodic_s1_sil0) &
              , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
              &real (dp) SLP: Periodic Periodic &
              &(Inp. w &
              &Inp. sym Inp. sil )", &
              t_SLP_out_c2_dp_pp0_w1PeriodicPeriodic_s1_sil1) &
              , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
              &real (dp) SLP: Periodic Periodic &
              &(Inp. pp &
              &)", &
              t_SLP_out_c2_dp_pp1_w0PeriodicPeriodic_s0_sil0) &
              , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
              &real (dp) SLP: Periodic Periodic &
              &(Inp. pp &
              &Inp. sil )", &
              t_SLP_out_c2_dp_pp1_w0PeriodicPeriodic_s0_sil1) &
              , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
              &real (dp) SLP: Periodic Periodic &
              &(Inp. pp &
              &Inp. sym )", &
              t_SLP_out_c2_dp_pp1_w0PeriodicPeriodic_s1_sil0) &
              , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
              &real (dp) SLP: Periodic Periodic &
              &(Inp. pp &
              &Inp. sym Inp. sil )", &
              t_SLP_out_c2_dp_pp1_w0PeriodicPeriodic_s1_sil1) &
              , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
              &real (dp) SLP: Periodic Periodic &
              &(Inp. pp Inp. w &
              &)", &
              t_SLP_out_c2_dp_pp1_w1PeriodicPeriodic_s0_sil0) &
              , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
              &real (dp) SLP: Periodic Periodic &
              &(Inp. pp Inp. w &
              &Inp. sil )", &
              t_SLP_out_c2_dp_pp1_w1PeriodicPeriodic_s0_sil1) &
              , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
              &real (dp) SLP: Periodic Periodic &
              &(Inp. pp Inp. w &
              &Inp. sym )", &
              t_SLP_out_c2_dp_pp1_w1PeriodicPeriodic_s1_sil0) &
              , new_unittest("check constructor, functionality and solver: different conditions on both bounds &
              &real (dp) SLP: Periodic Periodic &
              &(Inp. pp Inp. w &
              &Inp. sym Inp. sil )", &
              t_SLP_out_c2_dp_pp1_w1PeriodicPeriodic_s1_sil1) &
                ]

  end subroutine collect_Obj_Functionality

  subroutine test_basic(error)
    use SLP_obj, only: SLP_sp, SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb_sp
    type(SLP_dp) :: prb_dp
    if (prb_sp%initialized()) then
      allocate (error)
      return
    endif
    if (prb_dp%initialized()) then
      allocate (error)
      return
    endif
  end subroutine test_basic

  !For each type, precision, optional argument...

  subroutine t_SLP_out_c1_sp_pp0_w0Dirichlet_s0_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_sp, b=1.0_sp, N=N, &
                    p=p, &
                    q=q, &
                    bound_cond="Dirichlet" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(1, 1:N - 3)) > tol_sp)) then
      allocate (error)
      return
    endif
    if (any(abs(vl(N, 1:N - 3)) > tol_sp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c1_sp_pp0_w0Dirichlet_s0_sil0

  subroutine t_SLP_out_c1_sp_pp0_w0Dirichlet_s0_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond="Dirichlet" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c1_sp_pp0_w0Dirichlet_s0_sil1

  subroutine t_SLP_out_c1_sp_pp0_w0Dirichlet_s1_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond="Dirichlet" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c1_sp_pp0_w0Dirichlet_s1_sil0

  subroutine t_SLP_out_c1_sp_pp0_w0Dirichlet_s1_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond="Dirichlet" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c1_sp_pp0_w0Dirichlet_s1_sil1

  subroutine t_SLP_out_c1_sp_pp0_w0Neumann_s0_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_sp, b=1.0_sp, N=N, &
                    p=p, &
                    q=q, &
                    bound_cond="Neumann" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_sp)) then
      allocate (error)
      return
    endif
    if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_sp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c1_sp_pp0_w0Neumann_s0_sil0

  subroutine t_SLP_out_c1_sp_pp0_w0Neumann_s0_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond="Neumann" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c1_sp_pp0_w0Neumann_s0_sil1

  subroutine t_SLP_out_c1_sp_pp0_w0Neumann_s1_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond="Neumann" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c1_sp_pp0_w0Neumann_s1_sil0

  subroutine t_SLP_out_c1_sp_pp0_w0Neumann_s1_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond="Neumann" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c1_sp_pp0_w0Neumann_s1_sil1

  subroutine t_SLP_out_c1_sp_pp0_w0Mixed_s0_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_sp, b=1.0_sp, N=N, &
                    p=p, &
                    q=q, &
                    bound_cond="Mixed" &
                    , mixing_param=1.0_sp &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(1, 1:N - 3) - 1.0_sp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_sp)) then
      allocate (error)
      return
    endif
    if (any(abs(vl(N, 1:N - 3) + 1.0_sp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_sp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c1_sp_pp0_w0Mixed_s0_sil0

  subroutine t_SLP_out_c1_sp_pp0_w0Mixed_s0_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond="Mixed" &
                      , mixing_param=1.0_sp &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - 1.0_sp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) + 1.0_sp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c1_sp_pp0_w0Mixed_s0_sil1

  subroutine t_SLP_out_c1_sp_pp0_w0Mixed_s1_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond="Mixed" &
                      , mixing_param=1.0_sp &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - 1.0_sp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) + 1.0_sp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c1_sp_pp0_w0Mixed_s1_sil0

  subroutine t_SLP_out_c1_sp_pp0_w0Mixed_s1_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond="Mixed" &
                      , mixing_param=1.0_sp &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - 1.0_sp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) + 1.0_sp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c1_sp_pp0_w0Mixed_s1_sil1

  subroutine t_SLP_out_c1_sp_pp0_w0Periodic_s0_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_sp, b=1.0_sp, N=N, &
                    p=p, &
                    q=q, &
                    bound_cond="Periodic" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(1, 1:N - 3) - vl(N, 1:N - 3)) > tol_sp)) then
      allocate (error)
      return
    endif
    if (any(abs(vl(1, 1:N - 3) + vl(N, 1:N - 3) - (vl(2, 1:N - 3) + vl(N - 1, 1:N - 3))) > tol_sp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c1_sp_pp0_w0Periodic_s0_sil0

  subroutine t_SLP_out_c1_sp_pp0_w0Periodic_s0_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond="Periodic" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(N, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(1, 1:N - 3) + vl(N, 1:N - 3) - (vl(2, 1:N - 3) + vl(N - 1, 1:N - 3))) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c1_sp_pp0_w0Periodic_s0_sil1

  subroutine t_SLP_out_c1_sp_pp0_w0Periodic_s1_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond="Periodic" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(N, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(1, 1:N - 3) + vl(N, 1:N - 3) - (vl(2, 1:N - 3) + vl(N - 1, 1:N - 3))) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c1_sp_pp0_w0Periodic_s1_sil0

  subroutine t_SLP_out_c1_sp_pp0_w0Periodic_s1_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond="Periodic" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(N, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(1, 1:N - 3) + vl(N, 1:N - 3) - (vl(2, 1:N - 3) + vl(N - 1, 1:N - 3))) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c1_sp_pp0_w0Periodic_s1_sil1

  subroutine t_SLP_out_c1_sp_pp0_w0Free_s0_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_sp, b=1.0_sp, N=N, &
                    p=p, &
                    q=q, &
                    bound_cond="Free" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
  end subroutine t_SLP_out_c1_sp_pp0_w0Free_s0_sil0

  subroutine t_SLP_out_c1_sp_pp0_w0Free_s0_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond="Free" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
  end subroutine t_SLP_out_c1_sp_pp0_w0Free_s0_sil1

  subroutine t_SLP_out_c1_sp_pp0_w0Free_s1_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond="Free" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
  end subroutine t_SLP_out_c1_sp_pp0_w0Free_s1_sil0

  subroutine t_SLP_out_c1_sp_pp0_w0Free_s1_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond="Free" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
    enddo
  end subroutine t_SLP_out_c1_sp_pp0_w0Free_s1_sil1

  subroutine t_SLP_out_c1_sp_pp0_w0Singular_s0_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_sp, b=1.0_sp, N=N, &
                    p=p, &
                    q=q, &
                    bound_cond="Singular" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
  end subroutine t_SLP_out_c1_sp_pp0_w0Singular_s0_sil0

  subroutine t_SLP_out_c1_sp_pp0_w0Singular_s0_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond="Singular" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
  end subroutine t_SLP_out_c1_sp_pp0_w0Singular_s0_sil1

  subroutine t_SLP_out_c1_sp_pp0_w0Singular_s1_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond="Singular" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
  end subroutine t_SLP_out_c1_sp_pp0_w0Singular_s1_sil0

  subroutine t_SLP_out_c1_sp_pp0_w0Singular_s1_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond="Singular" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
    enddo
  end subroutine t_SLP_out_c1_sp_pp0_w0Singular_s1_sil1

  subroutine t_SLP_out_c1_sp_pp0_w1Dirichlet_s0_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_sp, b=1.0_sp, N=N, &
                    p=p, &
                    q=q, &
                    w=w, &
                    bound_cond="Dirichlet" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(1, 1:N - 3)) > tol_sp)) then
      allocate (error)
      return
    endif
    if (any(abs(vl(N, 1:N - 3)) > tol_sp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c1_sp_pp0_w1Dirichlet_s0_sil0

  subroutine t_SLP_out_c1_sp_pp0_w1Dirichlet_s0_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond="Dirichlet" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c1_sp_pp0_w1Dirichlet_s0_sil1

  subroutine t_SLP_out_c1_sp_pp0_w1Dirichlet_s1_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond="Dirichlet" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c1_sp_pp0_w1Dirichlet_s1_sil0

  subroutine t_SLP_out_c1_sp_pp0_w1Dirichlet_s1_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond="Dirichlet" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c1_sp_pp0_w1Dirichlet_s1_sil1

  subroutine t_SLP_out_c1_sp_pp0_w1Neumann_s0_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_sp, b=1.0_sp, N=N, &
                    p=p, &
                    q=q, &
                    w=w, &
                    bound_cond="Neumann" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_sp)) then
      allocate (error)
      return
    endif
    if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_sp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c1_sp_pp0_w1Neumann_s0_sil0

  subroutine t_SLP_out_c1_sp_pp0_w1Neumann_s0_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond="Neumann" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c1_sp_pp0_w1Neumann_s0_sil1

  subroutine t_SLP_out_c1_sp_pp0_w1Neumann_s1_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond="Neumann" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c1_sp_pp0_w1Neumann_s1_sil0

  subroutine t_SLP_out_c1_sp_pp0_w1Neumann_s1_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond="Neumann" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c1_sp_pp0_w1Neumann_s1_sil1

  subroutine t_SLP_out_c1_sp_pp0_w1Mixed_s0_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_sp, b=1.0_sp, N=N, &
                    p=p, &
                    q=q, &
                    w=w, &
                    bound_cond="Mixed" &
                    , mixing_param=1.0_sp &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(1, 1:N - 3) - 1.0_sp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_sp)) then
      allocate (error)
      return
    endif
    if (any(abs(vl(N, 1:N - 3) + 1.0_sp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_sp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c1_sp_pp0_w1Mixed_s0_sil0

  subroutine t_SLP_out_c1_sp_pp0_w1Mixed_s0_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond="Mixed" &
                      , mixing_param=1.0_sp &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - 1.0_sp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) + 1.0_sp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c1_sp_pp0_w1Mixed_s0_sil1

  subroutine t_SLP_out_c1_sp_pp0_w1Mixed_s1_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond="Mixed" &
                      , mixing_param=1.0_sp &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - 1.0_sp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) + 1.0_sp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c1_sp_pp0_w1Mixed_s1_sil0

  subroutine t_SLP_out_c1_sp_pp0_w1Mixed_s1_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond="Mixed" &
                      , mixing_param=1.0_sp &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - 1.0_sp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) + 1.0_sp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c1_sp_pp0_w1Mixed_s1_sil1

  subroutine t_SLP_out_c1_sp_pp0_w1Periodic_s0_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_sp, b=1.0_sp, N=N, &
                    p=p, &
                    q=q, &
                    w=w, &
                    bound_cond="Periodic" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(1, 1:N - 3) - vl(N, 1:N - 3)) > tol_sp)) then
      allocate (error)
      return
    endif
    if (any(abs(vl(1, 1:N - 3) + vl(N, 1:N - 3) - (vl(2, 1:N - 3) + vl(N - 1, 1:N - 3))) > tol_sp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c1_sp_pp0_w1Periodic_s0_sil0

  subroutine t_SLP_out_c1_sp_pp0_w1Periodic_s0_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond="Periodic" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(N, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(1, 1:N - 3) + vl(N, 1:N - 3) - (vl(2, 1:N - 3) + vl(N - 1, 1:N - 3))) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c1_sp_pp0_w1Periodic_s0_sil1

  subroutine t_SLP_out_c1_sp_pp0_w1Periodic_s1_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond="Periodic" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(N, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(1, 1:N - 3) + vl(N, 1:N - 3) - (vl(2, 1:N - 3) + vl(N - 1, 1:N - 3))) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c1_sp_pp0_w1Periodic_s1_sil0

  subroutine t_SLP_out_c1_sp_pp0_w1Periodic_s1_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond="Periodic" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(N, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(1, 1:N - 3) + vl(N, 1:N - 3) - (vl(2, 1:N - 3) + vl(N - 1, 1:N - 3))) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c1_sp_pp0_w1Periodic_s1_sil1

  subroutine t_SLP_out_c1_sp_pp0_w1Free_s0_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_sp, b=1.0_sp, N=N, &
                    p=p, &
                    q=q, &
                    w=w, &
                    bound_cond="Free" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
  end subroutine t_SLP_out_c1_sp_pp0_w1Free_s0_sil0

  subroutine t_SLP_out_c1_sp_pp0_w1Free_s0_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond="Free" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
  end subroutine t_SLP_out_c1_sp_pp0_w1Free_s0_sil1

  subroutine t_SLP_out_c1_sp_pp0_w1Free_s1_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond="Free" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
  end subroutine t_SLP_out_c1_sp_pp0_w1Free_s1_sil0

  subroutine t_SLP_out_c1_sp_pp0_w1Free_s1_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond="Free" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
    enddo
  end subroutine t_SLP_out_c1_sp_pp0_w1Free_s1_sil1

  subroutine t_SLP_out_c1_sp_pp0_w1Singular_s0_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_sp, b=1.0_sp, N=N, &
                    p=p, &
                    q=q, &
                    w=w, &
                    bound_cond="Singular" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
  end subroutine t_SLP_out_c1_sp_pp0_w1Singular_s0_sil0

  subroutine t_SLP_out_c1_sp_pp0_w1Singular_s0_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond="Singular" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
  end subroutine t_SLP_out_c1_sp_pp0_w1Singular_s0_sil1

  subroutine t_SLP_out_c1_sp_pp0_w1Singular_s1_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond="Singular" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
  end subroutine t_SLP_out_c1_sp_pp0_w1Singular_s1_sil0

  subroutine t_SLP_out_c1_sp_pp0_w1Singular_s1_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond="Singular" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
    enddo
  end subroutine t_SLP_out_c1_sp_pp0_w1Singular_s1_sil1

  subroutine t_SLP_out_c1_sp_pp1_w0Dirichlet_s0_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_sp, b=1.0_sp, N=N, &
                    p=p, &
                    pp=pp, &
                    q=q, &
                    bound_cond="Dirichlet" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(1, 1:N - 3)) > tol_sp)) then
      allocate (error)
      return
    endif
    if (any(abs(vl(N, 1:N - 3)) > tol_sp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c1_sp_pp1_w0Dirichlet_s0_sil0

  subroutine t_SLP_out_c1_sp_pp1_w0Dirichlet_s0_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond="Dirichlet" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c1_sp_pp1_w0Dirichlet_s0_sil1

  subroutine t_SLP_out_c1_sp_pp1_w0Dirichlet_s1_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond="Dirichlet" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c1_sp_pp1_w0Dirichlet_s1_sil0

  subroutine t_SLP_out_c1_sp_pp1_w0Dirichlet_s1_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond="Dirichlet" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c1_sp_pp1_w0Dirichlet_s1_sil1

  subroutine t_SLP_out_c1_sp_pp1_w0Neumann_s0_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_sp, b=1.0_sp, N=N, &
                    p=p, &
                    pp=pp, &
                    q=q, &
                    bound_cond="Neumann" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_sp)) then
      allocate (error)
      return
    endif
    if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_sp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c1_sp_pp1_w0Neumann_s0_sil0

  subroutine t_SLP_out_c1_sp_pp1_w0Neumann_s0_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond="Neumann" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c1_sp_pp1_w0Neumann_s0_sil1

  subroutine t_SLP_out_c1_sp_pp1_w0Neumann_s1_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond="Neumann" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c1_sp_pp1_w0Neumann_s1_sil0

  subroutine t_SLP_out_c1_sp_pp1_w0Neumann_s1_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond="Neumann" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c1_sp_pp1_w0Neumann_s1_sil1

  subroutine t_SLP_out_c1_sp_pp1_w0Mixed_s0_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_sp, b=1.0_sp, N=N, &
                    p=p, &
                    pp=pp, &
                    q=q, &
                    bound_cond="Mixed" &
                    , mixing_param=1.0_sp &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(1, 1:N - 3) - 1.0_sp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_sp)) then
      allocate (error)
      return
    endif
    if (any(abs(vl(N, 1:N - 3) + 1.0_sp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_sp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c1_sp_pp1_w0Mixed_s0_sil0

  subroutine t_SLP_out_c1_sp_pp1_w0Mixed_s0_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond="Mixed" &
                      , mixing_param=1.0_sp &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - 1.0_sp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) + 1.0_sp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c1_sp_pp1_w0Mixed_s0_sil1

  subroutine t_SLP_out_c1_sp_pp1_w0Mixed_s1_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond="Mixed" &
                      , mixing_param=1.0_sp &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - 1.0_sp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) + 1.0_sp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c1_sp_pp1_w0Mixed_s1_sil0

  subroutine t_SLP_out_c1_sp_pp1_w0Mixed_s1_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond="Mixed" &
                      , mixing_param=1.0_sp &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - 1.0_sp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) + 1.0_sp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c1_sp_pp1_w0Mixed_s1_sil1

  subroutine t_SLP_out_c1_sp_pp1_w0Periodic_s0_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_sp, b=1.0_sp, N=N, &
                    p=p, &
                    pp=pp, &
                    q=q, &
                    bound_cond="Periodic" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(1, 1:N - 3) - vl(N, 1:N - 3)) > tol_sp)) then
      allocate (error)
      return
    endif
    if (any(abs(vl(1, 1:N - 3) + vl(N, 1:N - 3) - (vl(2, 1:N - 3) + vl(N - 1, 1:N - 3))) > tol_sp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c1_sp_pp1_w0Periodic_s0_sil0

  subroutine t_SLP_out_c1_sp_pp1_w0Periodic_s0_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond="Periodic" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(N, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(1, 1:N - 3) + vl(N, 1:N - 3) - (vl(2, 1:N - 3) + vl(N - 1, 1:N - 3))) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c1_sp_pp1_w0Periodic_s0_sil1

  subroutine t_SLP_out_c1_sp_pp1_w0Periodic_s1_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond="Periodic" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(N, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(1, 1:N - 3) + vl(N, 1:N - 3) - (vl(2, 1:N - 3) + vl(N - 1, 1:N - 3))) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c1_sp_pp1_w0Periodic_s1_sil0

  subroutine t_SLP_out_c1_sp_pp1_w0Periodic_s1_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond="Periodic" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(N, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(1, 1:N - 3) + vl(N, 1:N - 3) - (vl(2, 1:N - 3) + vl(N - 1, 1:N - 3))) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c1_sp_pp1_w0Periodic_s1_sil1

  subroutine t_SLP_out_c1_sp_pp1_w0Free_s0_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_sp, b=1.0_sp, N=N, &
                    p=p, &
                    pp=pp, &
                    q=q, &
                    bound_cond="Free" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
  end subroutine t_SLP_out_c1_sp_pp1_w0Free_s0_sil0

  subroutine t_SLP_out_c1_sp_pp1_w0Free_s0_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond="Free" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
  end subroutine t_SLP_out_c1_sp_pp1_w0Free_s0_sil1

  subroutine t_SLP_out_c1_sp_pp1_w0Free_s1_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond="Free" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
  end subroutine t_SLP_out_c1_sp_pp1_w0Free_s1_sil0

  subroutine t_SLP_out_c1_sp_pp1_w0Free_s1_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond="Free" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
    enddo
  end subroutine t_SLP_out_c1_sp_pp1_w0Free_s1_sil1

  subroutine t_SLP_out_c1_sp_pp1_w0Singular_s0_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_sp, b=1.0_sp, N=N, &
                    p=p, &
                    pp=pp, &
                    q=q, &
                    bound_cond="Singular" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
  end subroutine t_SLP_out_c1_sp_pp1_w0Singular_s0_sil0

  subroutine t_SLP_out_c1_sp_pp1_w0Singular_s0_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond="Singular" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
  end subroutine t_SLP_out_c1_sp_pp1_w0Singular_s0_sil1

  subroutine t_SLP_out_c1_sp_pp1_w0Singular_s1_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond="Singular" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
  end subroutine t_SLP_out_c1_sp_pp1_w0Singular_s1_sil0

  subroutine t_SLP_out_c1_sp_pp1_w0Singular_s1_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond="Singular" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
    enddo
  end subroutine t_SLP_out_c1_sp_pp1_w0Singular_s1_sil1

  subroutine t_SLP_out_c1_sp_pp1_w1Dirichlet_s0_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_sp, b=1.0_sp, N=N, &
                    p=p, &
                    pp=pp, &
                    q=q, &
                    w=w, &
                    bound_cond="Dirichlet" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(1, 1:N - 3)) > tol_sp)) then
      allocate (error)
      return
    endif
    if (any(abs(vl(N, 1:N - 3)) > tol_sp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c1_sp_pp1_w1Dirichlet_s0_sil0

  subroutine t_SLP_out_c1_sp_pp1_w1Dirichlet_s0_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond="Dirichlet" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c1_sp_pp1_w1Dirichlet_s0_sil1

  subroutine t_SLP_out_c1_sp_pp1_w1Dirichlet_s1_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond="Dirichlet" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c1_sp_pp1_w1Dirichlet_s1_sil0

  subroutine t_SLP_out_c1_sp_pp1_w1Dirichlet_s1_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond="Dirichlet" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c1_sp_pp1_w1Dirichlet_s1_sil1

  subroutine t_SLP_out_c1_sp_pp1_w1Neumann_s0_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_sp, b=1.0_sp, N=N, &
                    p=p, &
                    pp=pp, &
                    q=q, &
                    w=w, &
                    bound_cond="Neumann" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_sp)) then
      allocate (error)
      return
    endif
    if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_sp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c1_sp_pp1_w1Neumann_s0_sil0

  subroutine t_SLP_out_c1_sp_pp1_w1Neumann_s0_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond="Neumann" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c1_sp_pp1_w1Neumann_s0_sil1

  subroutine t_SLP_out_c1_sp_pp1_w1Neumann_s1_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond="Neumann" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c1_sp_pp1_w1Neumann_s1_sil0

  subroutine t_SLP_out_c1_sp_pp1_w1Neumann_s1_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond="Neumann" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c1_sp_pp1_w1Neumann_s1_sil1

  subroutine t_SLP_out_c1_sp_pp1_w1Mixed_s0_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_sp, b=1.0_sp, N=N, &
                    p=p, &
                    pp=pp, &
                    q=q, &
                    w=w, &
                    bound_cond="Mixed" &
                    , mixing_param=1.0_sp &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(1, 1:N - 3) - 1.0_sp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_sp)) then
      allocate (error)
      return
    endif
    if (any(abs(vl(N, 1:N - 3) + 1.0_sp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_sp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c1_sp_pp1_w1Mixed_s0_sil0

  subroutine t_SLP_out_c1_sp_pp1_w1Mixed_s0_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond="Mixed" &
                      , mixing_param=1.0_sp &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - 1.0_sp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) + 1.0_sp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c1_sp_pp1_w1Mixed_s0_sil1

  subroutine t_SLP_out_c1_sp_pp1_w1Mixed_s1_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond="Mixed" &
                      , mixing_param=1.0_sp &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - 1.0_sp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) + 1.0_sp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c1_sp_pp1_w1Mixed_s1_sil0

  subroutine t_SLP_out_c1_sp_pp1_w1Mixed_s1_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond="Mixed" &
                      , mixing_param=1.0_sp &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - 1.0_sp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) + 1.0_sp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c1_sp_pp1_w1Mixed_s1_sil1

  subroutine t_SLP_out_c1_sp_pp1_w1Periodic_s0_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_sp, b=1.0_sp, N=N, &
                    p=p, &
                    pp=pp, &
                    q=q, &
                    w=w, &
                    bound_cond="Periodic" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(1, 1:N - 3) - vl(N, 1:N - 3)) > tol_sp)) then
      allocate (error)
      return
    endif
    if (any(abs(vl(1, 1:N - 3) + vl(N, 1:N - 3) - (vl(2, 1:N - 3) + vl(N - 1, 1:N - 3))) > tol_sp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c1_sp_pp1_w1Periodic_s0_sil0

  subroutine t_SLP_out_c1_sp_pp1_w1Periodic_s0_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond="Periodic" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(N, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(1, 1:N - 3) + vl(N, 1:N - 3) - (vl(2, 1:N - 3) + vl(N - 1, 1:N - 3))) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c1_sp_pp1_w1Periodic_s0_sil1

  subroutine t_SLP_out_c1_sp_pp1_w1Periodic_s1_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond="Periodic" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(N, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(1, 1:N - 3) + vl(N, 1:N - 3) - (vl(2, 1:N - 3) + vl(N - 1, 1:N - 3))) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c1_sp_pp1_w1Periodic_s1_sil0

  subroutine t_SLP_out_c1_sp_pp1_w1Periodic_s1_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond="Periodic" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(N, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(1, 1:N - 3) + vl(N, 1:N - 3) - (vl(2, 1:N - 3) + vl(N - 1, 1:N - 3))) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c1_sp_pp1_w1Periodic_s1_sil1

  subroutine t_SLP_out_c1_sp_pp1_w1Free_s0_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_sp, b=1.0_sp, N=N, &
                    p=p, &
                    pp=pp, &
                    q=q, &
                    w=w, &
                    bound_cond="Free" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
  end subroutine t_SLP_out_c1_sp_pp1_w1Free_s0_sil0

  subroutine t_SLP_out_c1_sp_pp1_w1Free_s0_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond="Free" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
  end subroutine t_SLP_out_c1_sp_pp1_w1Free_s0_sil1

  subroutine t_SLP_out_c1_sp_pp1_w1Free_s1_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond="Free" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
  end subroutine t_SLP_out_c1_sp_pp1_w1Free_s1_sil0

  subroutine t_SLP_out_c1_sp_pp1_w1Free_s1_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond="Free" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
    enddo
  end subroutine t_SLP_out_c1_sp_pp1_w1Free_s1_sil1

  subroutine t_SLP_out_c1_sp_pp1_w1Singular_s0_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_sp, b=1.0_sp, N=N, &
                    p=p, &
                    pp=pp, &
                    q=q, &
                    w=w, &
                    bound_cond="Singular" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
  end subroutine t_SLP_out_c1_sp_pp1_w1Singular_s0_sil0

  subroutine t_SLP_out_c1_sp_pp1_w1Singular_s0_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond="Singular" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
  end subroutine t_SLP_out_c1_sp_pp1_w1Singular_s0_sil1

  subroutine t_SLP_out_c1_sp_pp1_w1Singular_s1_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond="Singular" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
  end subroutine t_SLP_out_c1_sp_pp1_w1Singular_s1_sil0

  subroutine t_SLP_out_c1_sp_pp1_w1Singular_s1_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond="Singular" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
    enddo
  end subroutine t_SLP_out_c1_sp_pp1_w1Singular_s1_sil1

  subroutine t_SLP_out_c1_dp_pp0_w0Dirichlet_s0_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_dp, b=1.0_dp, N=N, &
                    p=p, &
                    q=q, &
                    bound_cond="Dirichlet" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(1, 1:N - 3)) > tol_dp)) then
      allocate (error)
      return
    endif
    if (any(abs(vl(N, 1:N - 3)) > tol_dp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c1_dp_pp0_w0Dirichlet_s0_sil0

  subroutine t_SLP_out_c1_dp_pp0_w0Dirichlet_s0_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond="Dirichlet" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c1_dp_pp0_w0Dirichlet_s0_sil1

  subroutine t_SLP_out_c1_dp_pp0_w0Dirichlet_s1_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond="Dirichlet" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c1_dp_pp0_w0Dirichlet_s1_sil0

  subroutine t_SLP_out_c1_dp_pp0_w0Dirichlet_s1_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond="Dirichlet" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c1_dp_pp0_w0Dirichlet_s1_sil1

  subroutine t_SLP_out_c1_dp_pp0_w0Neumann_s0_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_dp, b=1.0_dp, N=N, &
                    p=p, &
                    q=q, &
                    bound_cond="Neumann" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_dp)) then
      allocate (error)
      return
    endif
    if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_dp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c1_dp_pp0_w0Neumann_s0_sil0

  subroutine t_SLP_out_c1_dp_pp0_w0Neumann_s0_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond="Neumann" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c1_dp_pp0_w0Neumann_s0_sil1

  subroutine t_SLP_out_c1_dp_pp0_w0Neumann_s1_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond="Neumann" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c1_dp_pp0_w0Neumann_s1_sil0

  subroutine t_SLP_out_c1_dp_pp0_w0Neumann_s1_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond="Neumann" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c1_dp_pp0_w0Neumann_s1_sil1

  subroutine t_SLP_out_c1_dp_pp0_w0Mixed_s0_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_dp, b=1.0_dp, N=N, &
                    p=p, &
                    q=q, &
                    bound_cond="Mixed" &
                    , mixing_param=1.0_dp &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(1, 1:N - 3) - 1.0_dp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_dp)) then
      allocate (error)
      return
    endif
    if (any(abs(vl(N, 1:N - 3) + 1.0_dp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_dp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c1_dp_pp0_w0Mixed_s0_sil0

  subroutine t_SLP_out_c1_dp_pp0_w0Mixed_s0_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond="Mixed" &
                      , mixing_param=1.0_dp &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - 1.0_dp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) + 1.0_dp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c1_dp_pp0_w0Mixed_s0_sil1

  subroutine t_SLP_out_c1_dp_pp0_w0Mixed_s1_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond="Mixed" &
                      , mixing_param=1.0_dp &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - 1.0_dp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) + 1.0_dp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c1_dp_pp0_w0Mixed_s1_sil0

  subroutine t_SLP_out_c1_dp_pp0_w0Mixed_s1_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond="Mixed" &
                      , mixing_param=1.0_dp &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - 1.0_dp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) + 1.0_dp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c1_dp_pp0_w0Mixed_s1_sil1

  subroutine t_SLP_out_c1_dp_pp0_w0Periodic_s0_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_dp, b=1.0_dp, N=N, &
                    p=p, &
                    q=q, &
                    bound_cond="Periodic" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(1, 1:N - 3) - vl(N, 1:N - 3)) > tol_dp)) then
      allocate (error)
      return
    endif
    if (any(abs(vl(1, 1:N - 3) + vl(N, 1:N - 3) - (vl(2, 1:N - 3) + vl(N - 1, 1:N - 3))) > tol_dp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c1_dp_pp0_w0Periodic_s0_sil0

  subroutine t_SLP_out_c1_dp_pp0_w0Periodic_s0_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond="Periodic" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(N, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(1, 1:N - 3) + vl(N, 1:N - 3) - (vl(2, 1:N - 3) + vl(N - 1, 1:N - 3))) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c1_dp_pp0_w0Periodic_s0_sil1

  subroutine t_SLP_out_c1_dp_pp0_w0Periodic_s1_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond="Periodic" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(N, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(1, 1:N - 3) + vl(N, 1:N - 3) - (vl(2, 1:N - 3) + vl(N - 1, 1:N - 3))) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c1_dp_pp0_w0Periodic_s1_sil0

  subroutine t_SLP_out_c1_dp_pp0_w0Periodic_s1_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond="Periodic" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(N, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(1, 1:N - 3) + vl(N, 1:N - 3) - (vl(2, 1:N - 3) + vl(N - 1, 1:N - 3))) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c1_dp_pp0_w0Periodic_s1_sil1

  subroutine t_SLP_out_c1_dp_pp0_w0Free_s0_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_dp, b=1.0_dp, N=N, &
                    p=p, &
                    q=q, &
                    bound_cond="Free" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
  end subroutine t_SLP_out_c1_dp_pp0_w0Free_s0_sil0

  subroutine t_SLP_out_c1_dp_pp0_w0Free_s0_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond="Free" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
  end subroutine t_SLP_out_c1_dp_pp0_w0Free_s0_sil1

  subroutine t_SLP_out_c1_dp_pp0_w0Free_s1_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond="Free" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
  end subroutine t_SLP_out_c1_dp_pp0_w0Free_s1_sil0

  subroutine t_SLP_out_c1_dp_pp0_w0Free_s1_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond="Free" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
    enddo
  end subroutine t_SLP_out_c1_dp_pp0_w0Free_s1_sil1

  subroutine t_SLP_out_c1_dp_pp0_w0Singular_s0_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_dp, b=1.0_dp, N=N, &
                    p=p, &
                    q=q, &
                    bound_cond="Singular" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
  end subroutine t_SLP_out_c1_dp_pp0_w0Singular_s0_sil0

  subroutine t_SLP_out_c1_dp_pp0_w0Singular_s0_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond="Singular" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
  end subroutine t_SLP_out_c1_dp_pp0_w0Singular_s0_sil1

  subroutine t_SLP_out_c1_dp_pp0_w0Singular_s1_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond="Singular" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
  end subroutine t_SLP_out_c1_dp_pp0_w0Singular_s1_sil0

  subroutine t_SLP_out_c1_dp_pp0_w0Singular_s1_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond="Singular" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
    enddo
  end subroutine t_SLP_out_c1_dp_pp0_w0Singular_s1_sil1

  subroutine t_SLP_out_c1_dp_pp0_w1Dirichlet_s0_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_dp, b=1.0_dp, N=N, &
                    p=p, &
                    q=q, &
                    w=w, &
                    bound_cond="Dirichlet" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(1, 1:N - 3)) > tol_dp)) then
      allocate (error)
      return
    endif
    if (any(abs(vl(N, 1:N - 3)) > tol_dp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c1_dp_pp0_w1Dirichlet_s0_sil0

  subroutine t_SLP_out_c1_dp_pp0_w1Dirichlet_s0_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond="Dirichlet" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c1_dp_pp0_w1Dirichlet_s0_sil1

  subroutine t_SLP_out_c1_dp_pp0_w1Dirichlet_s1_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond="Dirichlet" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c1_dp_pp0_w1Dirichlet_s1_sil0

  subroutine t_SLP_out_c1_dp_pp0_w1Dirichlet_s1_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond="Dirichlet" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c1_dp_pp0_w1Dirichlet_s1_sil1

  subroutine t_SLP_out_c1_dp_pp0_w1Neumann_s0_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_dp, b=1.0_dp, N=N, &
                    p=p, &
                    q=q, &
                    w=w, &
                    bound_cond="Neumann" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_dp)) then
      allocate (error)
      return
    endif
    if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_dp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c1_dp_pp0_w1Neumann_s0_sil0

  subroutine t_SLP_out_c1_dp_pp0_w1Neumann_s0_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond="Neumann" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c1_dp_pp0_w1Neumann_s0_sil1

  subroutine t_SLP_out_c1_dp_pp0_w1Neumann_s1_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond="Neumann" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c1_dp_pp0_w1Neumann_s1_sil0

  subroutine t_SLP_out_c1_dp_pp0_w1Neumann_s1_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond="Neumann" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c1_dp_pp0_w1Neumann_s1_sil1

  subroutine t_SLP_out_c1_dp_pp0_w1Mixed_s0_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_dp, b=1.0_dp, N=N, &
                    p=p, &
                    q=q, &
                    w=w, &
                    bound_cond="Mixed" &
                    , mixing_param=1.0_dp &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(1, 1:N - 3) - 1.0_dp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_dp)) then
      allocate (error)
      return
    endif
    if (any(abs(vl(N, 1:N - 3) + 1.0_dp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_dp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c1_dp_pp0_w1Mixed_s0_sil0

  subroutine t_SLP_out_c1_dp_pp0_w1Mixed_s0_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond="Mixed" &
                      , mixing_param=1.0_dp &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - 1.0_dp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) + 1.0_dp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c1_dp_pp0_w1Mixed_s0_sil1

  subroutine t_SLP_out_c1_dp_pp0_w1Mixed_s1_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond="Mixed" &
                      , mixing_param=1.0_dp &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - 1.0_dp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) + 1.0_dp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c1_dp_pp0_w1Mixed_s1_sil0

  subroutine t_SLP_out_c1_dp_pp0_w1Mixed_s1_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond="Mixed" &
                      , mixing_param=1.0_dp &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - 1.0_dp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) + 1.0_dp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c1_dp_pp0_w1Mixed_s1_sil1

  subroutine t_SLP_out_c1_dp_pp0_w1Periodic_s0_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_dp, b=1.0_dp, N=N, &
                    p=p, &
                    q=q, &
                    w=w, &
                    bound_cond="Periodic" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(1, 1:N - 3) - vl(N, 1:N - 3)) > tol_dp)) then
      allocate (error)
      return
    endif
    if (any(abs(vl(1, 1:N - 3) + vl(N, 1:N - 3) - (vl(2, 1:N - 3) + vl(N - 1, 1:N - 3))) > tol_dp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c1_dp_pp0_w1Periodic_s0_sil0

  subroutine t_SLP_out_c1_dp_pp0_w1Periodic_s0_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond="Periodic" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(N, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(1, 1:N - 3) + vl(N, 1:N - 3) - (vl(2, 1:N - 3) + vl(N - 1, 1:N - 3))) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c1_dp_pp0_w1Periodic_s0_sil1

  subroutine t_SLP_out_c1_dp_pp0_w1Periodic_s1_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond="Periodic" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(N, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(1, 1:N - 3) + vl(N, 1:N - 3) - (vl(2, 1:N - 3) + vl(N - 1, 1:N - 3))) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c1_dp_pp0_w1Periodic_s1_sil0

  subroutine t_SLP_out_c1_dp_pp0_w1Periodic_s1_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond="Periodic" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(N, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(1, 1:N - 3) + vl(N, 1:N - 3) - (vl(2, 1:N - 3) + vl(N - 1, 1:N - 3))) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c1_dp_pp0_w1Periodic_s1_sil1

  subroutine t_SLP_out_c1_dp_pp0_w1Free_s0_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_dp, b=1.0_dp, N=N, &
                    p=p, &
                    q=q, &
                    w=w, &
                    bound_cond="Free" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
  end subroutine t_SLP_out_c1_dp_pp0_w1Free_s0_sil0

  subroutine t_SLP_out_c1_dp_pp0_w1Free_s0_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond="Free" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
  end subroutine t_SLP_out_c1_dp_pp0_w1Free_s0_sil1

  subroutine t_SLP_out_c1_dp_pp0_w1Free_s1_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond="Free" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
  end subroutine t_SLP_out_c1_dp_pp0_w1Free_s1_sil0

  subroutine t_SLP_out_c1_dp_pp0_w1Free_s1_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond="Free" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
    enddo
  end subroutine t_SLP_out_c1_dp_pp0_w1Free_s1_sil1

  subroutine t_SLP_out_c1_dp_pp0_w1Singular_s0_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_dp, b=1.0_dp, N=N, &
                    p=p, &
                    q=q, &
                    w=w, &
                    bound_cond="Singular" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
  end subroutine t_SLP_out_c1_dp_pp0_w1Singular_s0_sil0

  subroutine t_SLP_out_c1_dp_pp0_w1Singular_s0_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond="Singular" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
  end subroutine t_SLP_out_c1_dp_pp0_w1Singular_s0_sil1

  subroutine t_SLP_out_c1_dp_pp0_w1Singular_s1_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond="Singular" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
  end subroutine t_SLP_out_c1_dp_pp0_w1Singular_s1_sil0

  subroutine t_SLP_out_c1_dp_pp0_w1Singular_s1_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond="Singular" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
    enddo
  end subroutine t_SLP_out_c1_dp_pp0_w1Singular_s1_sil1

  subroutine t_SLP_out_c1_dp_pp1_w0Dirichlet_s0_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_dp, b=1.0_dp, N=N, &
                    p=p, &
                    pp=pp, &
                    q=q, &
                    bound_cond="Dirichlet" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(1, 1:N - 3)) > tol_dp)) then
      allocate (error)
      return
    endif
    if (any(abs(vl(N, 1:N - 3)) > tol_dp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c1_dp_pp1_w0Dirichlet_s0_sil0

  subroutine t_SLP_out_c1_dp_pp1_w0Dirichlet_s0_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond="Dirichlet" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c1_dp_pp1_w0Dirichlet_s0_sil1

  subroutine t_SLP_out_c1_dp_pp1_w0Dirichlet_s1_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond="Dirichlet" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c1_dp_pp1_w0Dirichlet_s1_sil0

  subroutine t_SLP_out_c1_dp_pp1_w0Dirichlet_s1_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond="Dirichlet" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c1_dp_pp1_w0Dirichlet_s1_sil1

  subroutine t_SLP_out_c1_dp_pp1_w0Neumann_s0_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_dp, b=1.0_dp, N=N, &
                    p=p, &
                    pp=pp, &
                    q=q, &
                    bound_cond="Neumann" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_dp)) then
      allocate (error)
      return
    endif
    if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_dp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c1_dp_pp1_w0Neumann_s0_sil0

  subroutine t_SLP_out_c1_dp_pp1_w0Neumann_s0_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond="Neumann" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c1_dp_pp1_w0Neumann_s0_sil1

  subroutine t_SLP_out_c1_dp_pp1_w0Neumann_s1_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond="Neumann" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c1_dp_pp1_w0Neumann_s1_sil0

  subroutine t_SLP_out_c1_dp_pp1_w0Neumann_s1_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond="Neumann" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c1_dp_pp1_w0Neumann_s1_sil1

  subroutine t_SLP_out_c1_dp_pp1_w0Mixed_s0_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_dp, b=1.0_dp, N=N, &
                    p=p, &
                    pp=pp, &
                    q=q, &
                    bound_cond="Mixed" &
                    , mixing_param=1.0_dp &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(1, 1:N - 3) - 1.0_dp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_dp)) then
      allocate (error)
      return
    endif
    if (any(abs(vl(N, 1:N - 3) + 1.0_dp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_dp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c1_dp_pp1_w0Mixed_s0_sil0

  subroutine t_SLP_out_c1_dp_pp1_w0Mixed_s0_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond="Mixed" &
                      , mixing_param=1.0_dp &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - 1.0_dp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) + 1.0_dp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c1_dp_pp1_w0Mixed_s0_sil1

  subroutine t_SLP_out_c1_dp_pp1_w0Mixed_s1_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond="Mixed" &
                      , mixing_param=1.0_dp &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - 1.0_dp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) + 1.0_dp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c1_dp_pp1_w0Mixed_s1_sil0

  subroutine t_SLP_out_c1_dp_pp1_w0Mixed_s1_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond="Mixed" &
                      , mixing_param=1.0_dp &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - 1.0_dp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) + 1.0_dp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c1_dp_pp1_w0Mixed_s1_sil1

  subroutine t_SLP_out_c1_dp_pp1_w0Periodic_s0_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_dp, b=1.0_dp, N=N, &
                    p=p, &
                    pp=pp, &
                    q=q, &
                    bound_cond="Periodic" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(1, 1:N - 3) - vl(N, 1:N - 3)) > tol_dp)) then
      allocate (error)
      return
    endif
    if (any(abs(vl(1, 1:N - 3) + vl(N, 1:N - 3) - (vl(2, 1:N - 3) + vl(N - 1, 1:N - 3))) > tol_dp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c1_dp_pp1_w0Periodic_s0_sil0

  subroutine t_SLP_out_c1_dp_pp1_w0Periodic_s0_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond="Periodic" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(N, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(1, 1:N - 3) + vl(N, 1:N - 3) - (vl(2, 1:N - 3) + vl(N - 1, 1:N - 3))) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c1_dp_pp1_w0Periodic_s0_sil1

  subroutine t_SLP_out_c1_dp_pp1_w0Periodic_s1_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond="Periodic" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(N, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(1, 1:N - 3) + vl(N, 1:N - 3) - (vl(2, 1:N - 3) + vl(N - 1, 1:N - 3))) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c1_dp_pp1_w0Periodic_s1_sil0

  subroutine t_SLP_out_c1_dp_pp1_w0Periodic_s1_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond="Periodic" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(N, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(1, 1:N - 3) + vl(N, 1:N - 3) - (vl(2, 1:N - 3) + vl(N - 1, 1:N - 3))) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c1_dp_pp1_w0Periodic_s1_sil1

  subroutine t_SLP_out_c1_dp_pp1_w0Free_s0_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_dp, b=1.0_dp, N=N, &
                    p=p, &
                    pp=pp, &
                    q=q, &
                    bound_cond="Free" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
  end subroutine t_SLP_out_c1_dp_pp1_w0Free_s0_sil0

  subroutine t_SLP_out_c1_dp_pp1_w0Free_s0_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond="Free" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
  end subroutine t_SLP_out_c1_dp_pp1_w0Free_s0_sil1

  subroutine t_SLP_out_c1_dp_pp1_w0Free_s1_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond="Free" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
  end subroutine t_SLP_out_c1_dp_pp1_w0Free_s1_sil0

  subroutine t_SLP_out_c1_dp_pp1_w0Free_s1_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond="Free" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
    enddo
  end subroutine t_SLP_out_c1_dp_pp1_w0Free_s1_sil1

  subroutine t_SLP_out_c1_dp_pp1_w0Singular_s0_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_dp, b=1.0_dp, N=N, &
                    p=p, &
                    pp=pp, &
                    q=q, &
                    bound_cond="Singular" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
  end subroutine t_SLP_out_c1_dp_pp1_w0Singular_s0_sil0

  subroutine t_SLP_out_c1_dp_pp1_w0Singular_s0_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond="Singular" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
  end subroutine t_SLP_out_c1_dp_pp1_w0Singular_s0_sil1

  subroutine t_SLP_out_c1_dp_pp1_w0Singular_s1_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond="Singular" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
  end subroutine t_SLP_out_c1_dp_pp1_w0Singular_s1_sil0

  subroutine t_SLP_out_c1_dp_pp1_w0Singular_s1_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond="Singular" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
    enddo
  end subroutine t_SLP_out_c1_dp_pp1_w0Singular_s1_sil1

  subroutine t_SLP_out_c1_dp_pp1_w1Dirichlet_s0_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_dp, b=1.0_dp, N=N, &
                    p=p, &
                    pp=pp, &
                    q=q, &
                    w=w, &
                    bound_cond="Dirichlet" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(1, 1:N - 3)) > tol_dp)) then
      allocate (error)
      return
    endif
    if (any(abs(vl(N, 1:N - 3)) > tol_dp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c1_dp_pp1_w1Dirichlet_s0_sil0

  subroutine t_SLP_out_c1_dp_pp1_w1Dirichlet_s0_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond="Dirichlet" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c1_dp_pp1_w1Dirichlet_s0_sil1

  subroutine t_SLP_out_c1_dp_pp1_w1Dirichlet_s1_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond="Dirichlet" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c1_dp_pp1_w1Dirichlet_s1_sil0

  subroutine t_SLP_out_c1_dp_pp1_w1Dirichlet_s1_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond="Dirichlet" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c1_dp_pp1_w1Dirichlet_s1_sil1

  subroutine t_SLP_out_c1_dp_pp1_w1Neumann_s0_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_dp, b=1.0_dp, N=N, &
                    p=p, &
                    pp=pp, &
                    q=q, &
                    w=w, &
                    bound_cond="Neumann" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_dp)) then
      allocate (error)
      return
    endif
    if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_dp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c1_dp_pp1_w1Neumann_s0_sil0

  subroutine t_SLP_out_c1_dp_pp1_w1Neumann_s0_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond="Neumann" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c1_dp_pp1_w1Neumann_s0_sil1

  subroutine t_SLP_out_c1_dp_pp1_w1Neumann_s1_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond="Neumann" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c1_dp_pp1_w1Neumann_s1_sil0

  subroutine t_SLP_out_c1_dp_pp1_w1Neumann_s1_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond="Neumann" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c1_dp_pp1_w1Neumann_s1_sil1

  subroutine t_SLP_out_c1_dp_pp1_w1Mixed_s0_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_dp, b=1.0_dp, N=N, &
                    p=p, &
                    pp=pp, &
                    q=q, &
                    w=w, &
                    bound_cond="Mixed" &
                    , mixing_param=1.0_dp &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(1, 1:N - 3) - 1.0_dp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_dp)) then
      allocate (error)
      return
    endif
    if (any(abs(vl(N, 1:N - 3) + 1.0_dp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_dp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c1_dp_pp1_w1Mixed_s0_sil0

  subroutine t_SLP_out_c1_dp_pp1_w1Mixed_s0_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond="Mixed" &
                      , mixing_param=1.0_dp &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - 1.0_dp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) + 1.0_dp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c1_dp_pp1_w1Mixed_s0_sil1

  subroutine t_SLP_out_c1_dp_pp1_w1Mixed_s1_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond="Mixed" &
                      , mixing_param=1.0_dp &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - 1.0_dp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) + 1.0_dp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c1_dp_pp1_w1Mixed_s1_sil0

  subroutine t_SLP_out_c1_dp_pp1_w1Mixed_s1_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond="Mixed" &
                      , mixing_param=1.0_dp &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - 1.0_dp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) + 1.0_dp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c1_dp_pp1_w1Mixed_s1_sil1

  subroutine t_SLP_out_c1_dp_pp1_w1Periodic_s0_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_dp, b=1.0_dp, N=N, &
                    p=p, &
                    pp=pp, &
                    q=q, &
                    w=w, &
                    bound_cond="Periodic" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(1, 1:N - 3) - vl(N, 1:N - 3)) > tol_dp)) then
      allocate (error)
      return
    endif
    if (any(abs(vl(1, 1:N - 3) + vl(N, 1:N - 3) - (vl(2, 1:N - 3) + vl(N - 1, 1:N - 3))) > tol_dp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c1_dp_pp1_w1Periodic_s0_sil0

  subroutine t_SLP_out_c1_dp_pp1_w1Periodic_s0_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond="Periodic" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(N, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(1, 1:N - 3) + vl(N, 1:N - 3) - (vl(2, 1:N - 3) + vl(N - 1, 1:N - 3))) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c1_dp_pp1_w1Periodic_s0_sil1

  subroutine t_SLP_out_c1_dp_pp1_w1Periodic_s1_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond="Periodic" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(N, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(1, 1:N - 3) + vl(N, 1:N - 3) - (vl(2, 1:N - 3) + vl(N - 1, 1:N - 3))) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c1_dp_pp1_w1Periodic_s1_sil0

  subroutine t_SLP_out_c1_dp_pp1_w1Periodic_s1_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond="Periodic" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(N, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(1, 1:N - 3) + vl(N, 1:N - 3) - (vl(2, 1:N - 3) + vl(N - 1, 1:N - 3))) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c1_dp_pp1_w1Periodic_s1_sil1

  subroutine t_SLP_out_c1_dp_pp1_w1Free_s0_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_dp, b=1.0_dp, N=N, &
                    p=p, &
                    pp=pp, &
                    q=q, &
                    w=w, &
                    bound_cond="Free" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
  end subroutine t_SLP_out_c1_dp_pp1_w1Free_s0_sil0

  subroutine t_SLP_out_c1_dp_pp1_w1Free_s0_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond="Free" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
  end subroutine t_SLP_out_c1_dp_pp1_w1Free_s0_sil1

  subroutine t_SLP_out_c1_dp_pp1_w1Free_s1_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond="Free" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
  end subroutine t_SLP_out_c1_dp_pp1_w1Free_s1_sil0

  subroutine t_SLP_out_c1_dp_pp1_w1Free_s1_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond="Free" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
    enddo
  end subroutine t_SLP_out_c1_dp_pp1_w1Free_s1_sil1

  subroutine t_SLP_out_c1_dp_pp1_w1Singular_s0_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_dp, b=1.0_dp, N=N, &
                    p=p, &
                    pp=pp, &
                    q=q, &
                    w=w, &
                    bound_cond="Singular" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
  end subroutine t_SLP_out_c1_dp_pp1_w1Singular_s0_sil0

  subroutine t_SLP_out_c1_dp_pp1_w1Singular_s0_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond="Singular" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
  end subroutine t_SLP_out_c1_dp_pp1_w1Singular_s0_sil1

  subroutine t_SLP_out_c1_dp_pp1_w1Singular_s1_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond="Singular" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
  end subroutine t_SLP_out_c1_dp_pp1_w1Singular_s1_sil0

  subroutine t_SLP_out_c1_dp_pp1_w1Singular_s1_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond="Singular" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
    enddo
  end subroutine t_SLP_out_c1_dp_pp1_w1Singular_s1_sil1
  !Calling way #2.

  subroutine t_SLP_out_c2_sp_pp0_w0DirichletDirichlet_s0_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_sp, b=1.0_sp, N=N, &
                    p=p, &
                    q=q, &
                    bound_cond_a="Dirichlet", &
                    bound_cond_b="Dirichlet" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(1, 1:N - 3)) > tol_sp)) then
      allocate (error)
      return
    endif
    if (any(abs(vl(N, 1:N - 3)) > tol_sp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_sp_pp0_w0DirichletDirichlet_s0_sil0

  subroutine t_SLP_out_c2_sp_pp0_w0DirichletDirichlet_s0_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Dirichlet", &
                      bound_cond_b="Dirichlet" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w0DirichletDirichlet_s0_sil1

  subroutine t_SLP_out_c2_sp_pp0_w0DirichletDirichlet_s1_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Dirichlet", &
                      bound_cond_b="Dirichlet" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w0DirichletDirichlet_s1_sil0

  subroutine t_SLP_out_c2_sp_pp0_w0DirichletDirichlet_s1_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Dirichlet", &
                      bound_cond_b="Dirichlet" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w0DirichletDirichlet_s1_sil1

  subroutine t_SLP_out_c2_sp_pp0_w0DirichletNeumann_s0_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_sp, b=1.0_sp, N=N, &
                    p=p, &
                    q=q, &
                    bound_cond_a="Dirichlet", &
                    bound_cond_b="Neumann" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(1, 1:N - 3)) > tol_sp)) then
      allocate (error)
      return
    endif
    if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_sp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_sp_pp0_w0DirichletNeumann_s0_sil0

  subroutine t_SLP_out_c2_sp_pp0_w0DirichletNeumann_s0_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Dirichlet", &
                      bound_cond_b="Neumann" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w0DirichletNeumann_s0_sil1

  subroutine t_SLP_out_c2_sp_pp0_w0DirichletNeumann_s1_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Dirichlet", &
                      bound_cond_b="Neumann" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w0DirichletNeumann_s1_sil0

  subroutine t_SLP_out_c2_sp_pp0_w0DirichletNeumann_s1_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Dirichlet", &
                      bound_cond_b="Neumann" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w0DirichletNeumann_s1_sil1

  subroutine t_SLP_out_c2_sp_pp0_w0DirichletMixed_s0_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_sp, b=1.0_sp, N=N, &
                    p=p, &
                    q=q, &
                    bound_cond_a="Dirichlet", &
                    bound_cond_b="Mixed" &
                    , mixing_param_b=1.0_sp &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(1, 1:N - 3)) > tol_sp)) then
      allocate (error)
      return
    endif
    if (any(abs(vl(N, 1:N - 3) + 1.0_sp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_sp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_sp_pp0_w0DirichletMixed_s0_sil0

  subroutine t_SLP_out_c2_sp_pp0_w0DirichletMixed_s0_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Dirichlet", &
                      bound_cond_b="Mixed" &
                      , mixing_param_b=1.0_sp &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) + 1.0_sp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w0DirichletMixed_s0_sil1

  subroutine t_SLP_out_c2_sp_pp0_w0DirichletMixed_s1_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Dirichlet", &
                      bound_cond_b="Mixed" &
                      , mixing_param_b=1.0_sp &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) + 1.0_sp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w0DirichletMixed_s1_sil0

  subroutine t_SLP_out_c2_sp_pp0_w0DirichletMixed_s1_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Dirichlet", &
                      bound_cond_b="Mixed" &
                      , mixing_param_b=1.0_sp &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) + 1.0_sp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w0DirichletMixed_s1_sil1

  subroutine t_SLP_out_c2_sp_pp0_w0DirichletFree_s0_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_sp, b=1.0_sp, N=N, &
                    p=p, &
                    q=q, &
                    bound_cond_a="Dirichlet", &
                    bound_cond_b="Free" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(1, 1:N - 3)) > tol_sp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_sp_pp0_w0DirichletFree_s0_sil0

  subroutine t_SLP_out_c2_sp_pp0_w0DirichletFree_s0_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Dirichlet", &
                      bound_cond_b="Free" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w0DirichletFree_s0_sil1

  subroutine t_SLP_out_c2_sp_pp0_w0DirichletFree_s1_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Dirichlet", &
                      bound_cond_b="Free" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w0DirichletFree_s1_sil0

  subroutine t_SLP_out_c2_sp_pp0_w0DirichletFree_s1_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Dirichlet", &
                      bound_cond_b="Free" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w0DirichletFree_s1_sil1

  subroutine t_SLP_out_c2_sp_pp0_w0DirichletSingular_s0_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_sp, b=1.0_sp, N=N, &
                    p=p, &
                    q=q, &
                    bound_cond_a="Dirichlet", &
                    bound_cond_b="Singular" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(1, 1:N - 3)) > tol_sp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_sp_pp0_w0DirichletSingular_s0_sil0

  subroutine t_SLP_out_c2_sp_pp0_w0DirichletSingular_s0_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Dirichlet", &
                      bound_cond_b="Singular" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w0DirichletSingular_s0_sil1

  subroutine t_SLP_out_c2_sp_pp0_w0DirichletSingular_s1_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Dirichlet", &
                      bound_cond_b="Singular" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w0DirichletSingular_s1_sil0

  subroutine t_SLP_out_c2_sp_pp0_w0DirichletSingular_s1_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Dirichlet", &
                      bound_cond_b="Singular" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w0DirichletSingular_s1_sil1

  subroutine t_SLP_out_c2_sp_pp0_w0NeumannDirichlet_s0_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_sp, b=1.0_sp, N=N, &
                    p=p, &
                    q=q, &
                    bound_cond_a="Neumann", &
                    bound_cond_b="Dirichlet" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(N, 1:N - 3)) > tol_sp)) then
      allocate (error)
      return
    endif
    if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_sp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_sp_pp0_w0NeumannDirichlet_s0_sil0

  subroutine t_SLP_out_c2_sp_pp0_w0NeumannDirichlet_s0_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Neumann", &
                      bound_cond_b="Dirichlet" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w0NeumannDirichlet_s0_sil1

  subroutine t_SLP_out_c2_sp_pp0_w0NeumannDirichlet_s1_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Neumann", &
                      bound_cond_b="Dirichlet" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w0NeumannDirichlet_s1_sil0

  subroutine t_SLP_out_c2_sp_pp0_w0NeumannDirichlet_s1_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Neumann", &
                      bound_cond_b="Dirichlet" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w0NeumannDirichlet_s1_sil1

  subroutine t_SLP_out_c2_sp_pp0_w0NeumannNeumann_s0_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_sp, b=1.0_sp, N=N, &
                    p=p, &
                    q=q, &
                    bound_cond_a="Neumann", &
                    bound_cond_b="Neumann" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_sp)) then
      allocate (error)
      return
    endif
    if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_sp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_sp_pp0_w0NeumannNeumann_s0_sil0

  subroutine t_SLP_out_c2_sp_pp0_w0NeumannNeumann_s0_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Neumann", &
                      bound_cond_b="Neumann" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w0NeumannNeumann_s0_sil1

  subroutine t_SLP_out_c2_sp_pp0_w0NeumannNeumann_s1_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Neumann", &
                      bound_cond_b="Neumann" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w0NeumannNeumann_s1_sil0

  subroutine t_SLP_out_c2_sp_pp0_w0NeumannNeumann_s1_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Neumann", &
                      bound_cond_b="Neumann" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w0NeumannNeumann_s1_sil1

  subroutine t_SLP_out_c2_sp_pp0_w0NeumannMixed_s0_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_sp, b=1.0_sp, N=N, &
                    p=p, &
                    q=q, &
                    bound_cond_a="Neumann", &
                    bound_cond_b="Mixed" &
                    , mixing_param_b=1.0_sp &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_sp)) then
      allocate (error)
      return
    endif
    if (any(abs(vl(N, 1:N - 3) + 1.0_sp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_sp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_sp_pp0_w0NeumannMixed_s0_sil0

  subroutine t_SLP_out_c2_sp_pp0_w0NeumannMixed_s0_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Neumann", &
                      bound_cond_b="Mixed" &
                      , mixing_param_b=1.0_sp &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) + 1.0_sp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w0NeumannMixed_s0_sil1

  subroutine t_SLP_out_c2_sp_pp0_w0NeumannMixed_s1_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Neumann", &
                      bound_cond_b="Mixed" &
                      , mixing_param_b=1.0_sp &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) + 1.0_sp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w0NeumannMixed_s1_sil0

  subroutine t_SLP_out_c2_sp_pp0_w0NeumannMixed_s1_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Neumann", &
                      bound_cond_b="Mixed" &
                      , mixing_param_b=1.0_sp &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) + 1.0_sp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w0NeumannMixed_s1_sil1

  subroutine t_SLP_out_c2_sp_pp0_w0NeumannFree_s0_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_sp, b=1.0_sp, N=N, &
                    p=p, &
                    q=q, &
                    bound_cond_a="Neumann", &
                    bound_cond_b="Free" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_sp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_sp_pp0_w0NeumannFree_s0_sil0

  subroutine t_SLP_out_c2_sp_pp0_w0NeumannFree_s0_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Neumann", &
                      bound_cond_b="Free" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w0NeumannFree_s0_sil1

  subroutine t_SLP_out_c2_sp_pp0_w0NeumannFree_s1_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Neumann", &
                      bound_cond_b="Free" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w0NeumannFree_s1_sil0

  subroutine t_SLP_out_c2_sp_pp0_w0NeumannFree_s1_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Neumann", &
                      bound_cond_b="Free" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w0NeumannFree_s1_sil1

  subroutine t_SLP_out_c2_sp_pp0_w0NeumannSingular_s0_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_sp, b=1.0_sp, N=N, &
                    p=p, &
                    q=q, &
                    bound_cond_a="Neumann", &
                    bound_cond_b="Singular" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_sp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_sp_pp0_w0NeumannSingular_s0_sil0

  subroutine t_SLP_out_c2_sp_pp0_w0NeumannSingular_s0_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Neumann", &
                      bound_cond_b="Singular" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w0NeumannSingular_s0_sil1

  subroutine t_SLP_out_c2_sp_pp0_w0NeumannSingular_s1_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Neumann", &
                      bound_cond_b="Singular" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w0NeumannSingular_s1_sil0

  subroutine t_SLP_out_c2_sp_pp0_w0NeumannSingular_s1_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Neumann", &
                      bound_cond_b="Singular" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w0NeumannSingular_s1_sil1

  subroutine t_SLP_out_c2_sp_pp0_w0MixedDirichlet_s0_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_sp, b=1.0_sp, N=N, &
                    p=p, &
                    q=q, &
                    bound_cond_a="Mixed", &
                    bound_cond_b="Dirichlet" &
                    , mixing_param_a=1.0_sp &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(N, 1:N - 3)) > tol_sp)) then
      allocate (error)
      return
    endif
    if (any(abs(vl(1, 1:N - 3) - 1.0_sp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_sp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_sp_pp0_w0MixedDirichlet_s0_sil0

  subroutine t_SLP_out_c2_sp_pp0_w0MixedDirichlet_s0_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Mixed", &
                      bound_cond_b="Dirichlet" &
                      , mixing_param_a=1.0_sp &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(1, 1:N - 3) - 1.0_sp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w0MixedDirichlet_s0_sil1

  subroutine t_SLP_out_c2_sp_pp0_w0MixedDirichlet_s1_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Mixed", &
                      bound_cond_b="Dirichlet" &
                      , mixing_param_a=1.0_sp &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(1, 1:N - 3) - 1.0_sp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w0MixedDirichlet_s1_sil0

  subroutine t_SLP_out_c2_sp_pp0_w0MixedDirichlet_s1_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Mixed", &
                      bound_cond_b="Dirichlet" &
                      , mixing_param_a=1.0_sp &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(1, 1:N - 3) - 1.0_sp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w0MixedDirichlet_s1_sil1

  subroutine t_SLP_out_c2_sp_pp0_w0MixedNeumann_s0_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_sp, b=1.0_sp, N=N, &
                    p=p, &
                    q=q, &
                    bound_cond_a="Mixed", &
                    bound_cond_b="Neumann" &
                    , mixing_param_a=1.0_sp &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_sp)) then
      allocate (error)
      return
    endif
    if (any(abs(vl(1, 1:N - 3) - 1.0_sp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_sp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_sp_pp0_w0MixedNeumann_s0_sil0

  subroutine t_SLP_out_c2_sp_pp0_w0MixedNeumann_s0_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Mixed", &
                      bound_cond_b="Neumann" &
                      , mixing_param_a=1.0_sp &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(1, 1:N - 3) - 1.0_sp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w0MixedNeumann_s0_sil1

  subroutine t_SLP_out_c2_sp_pp0_w0MixedNeumann_s1_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Mixed", &
                      bound_cond_b="Neumann" &
                      , mixing_param_a=1.0_sp &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(1, 1:N - 3) - 1.0_sp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w0MixedNeumann_s1_sil0

  subroutine t_SLP_out_c2_sp_pp0_w0MixedNeumann_s1_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Mixed", &
                      bound_cond_b="Neumann" &
                      , mixing_param_a=1.0_sp &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(1, 1:N - 3) - 1.0_sp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w0MixedNeumann_s1_sil1

  subroutine t_SLP_out_c2_sp_pp0_w0MixedMixed_s0_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_sp, b=1.0_sp, N=N, &
                    p=p, &
                    q=q, &
                    bound_cond_a="Mixed", &
                    bound_cond_b="Mixed" &
                    , mixing_param_a=1.0_sp &
                    , mixing_param_b=1.0_sp &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(1, 1:N - 3) - 1.0_sp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_sp)) then
      allocate (error)
      return
    endif
    if (any(abs(vl(N, 1:N - 3) + 1.0_sp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_sp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_sp_pp0_w0MixedMixed_s0_sil0

  subroutine t_SLP_out_c2_sp_pp0_w0MixedMixed_s0_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Mixed", &
                      bound_cond_b="Mixed" &
                      , mixing_param_a=1.0_sp &
                      , mixing_param_b=1.0_sp &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - 1.0_sp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) + 1.0_sp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w0MixedMixed_s0_sil1

  subroutine t_SLP_out_c2_sp_pp0_w0MixedMixed_s1_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Mixed", &
                      bound_cond_b="Mixed" &
                      , mixing_param_a=1.0_sp &
                      , mixing_param_b=1.0_sp &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - 1.0_sp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) + 1.0_sp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w0MixedMixed_s1_sil0

  subroutine t_SLP_out_c2_sp_pp0_w0MixedMixed_s1_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Mixed", &
                      bound_cond_b="Mixed" &
                      , mixing_param_a=1.0_sp &
                      , mixing_param_b=1.0_sp &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - 1.0_sp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) + 1.0_sp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w0MixedMixed_s1_sil1

  subroutine t_SLP_out_c2_sp_pp0_w0MixedFree_s0_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_sp, b=1.0_sp, N=N, &
                    p=p, &
                    q=q, &
                    bound_cond_a="Mixed", &
                    bound_cond_b="Free" &
                    , mixing_param_a=1.0_sp &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(1, 1:N - 3) - 1.0_sp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_sp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_sp_pp0_w0MixedFree_s0_sil0

  subroutine t_SLP_out_c2_sp_pp0_w0MixedFree_s0_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Mixed", &
                      bound_cond_b="Free" &
                      , mixing_param_a=1.0_sp &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - 1.0_sp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w0MixedFree_s0_sil1

  subroutine t_SLP_out_c2_sp_pp0_w0MixedFree_s1_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Mixed", &
                      bound_cond_b="Free" &
                      , mixing_param_a=1.0_sp &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - 1.0_sp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w0MixedFree_s1_sil0

  subroutine t_SLP_out_c2_sp_pp0_w0MixedFree_s1_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Mixed", &
                      bound_cond_b="Free" &
                      , mixing_param_a=1.0_sp &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - 1.0_sp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w0MixedFree_s1_sil1

  subroutine t_SLP_out_c2_sp_pp0_w0MixedSingular_s0_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_sp, b=1.0_sp, N=N, &
                    p=p, &
                    q=q, &
                    bound_cond_a="Mixed", &
                    bound_cond_b="Singular" &
                    , mixing_param_a=1.0_sp &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(1, 1:N - 3) - 1.0_sp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_sp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_sp_pp0_w0MixedSingular_s0_sil0

  subroutine t_SLP_out_c2_sp_pp0_w0MixedSingular_s0_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Mixed", &
                      bound_cond_b="Singular" &
                      , mixing_param_a=1.0_sp &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - 1.0_sp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w0MixedSingular_s0_sil1

  subroutine t_SLP_out_c2_sp_pp0_w0MixedSingular_s1_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Mixed", &
                      bound_cond_b="Singular" &
                      , mixing_param_a=1.0_sp &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - 1.0_sp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w0MixedSingular_s1_sil0

  subroutine t_SLP_out_c2_sp_pp0_w0MixedSingular_s1_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Mixed", &
                      bound_cond_b="Singular" &
                      , mixing_param_a=1.0_sp &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - 1.0_sp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w0MixedSingular_s1_sil1

  subroutine t_SLP_out_c2_sp_pp0_w0FreeDirichlet_s0_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_sp, b=1.0_sp, N=N, &
                    p=p, &
                    q=q, &
                    bound_cond_a="Free", &
                    bound_cond_b="Dirichlet" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(N, 1:N - 3)) > tol_sp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_sp_pp0_w0FreeDirichlet_s0_sil0

  subroutine t_SLP_out_c2_sp_pp0_w0FreeDirichlet_s0_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Free", &
                      bound_cond_b="Dirichlet" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w0FreeDirichlet_s0_sil1

  subroutine t_SLP_out_c2_sp_pp0_w0FreeDirichlet_s1_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Free", &
                      bound_cond_b="Dirichlet" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w0FreeDirichlet_s1_sil0

  subroutine t_SLP_out_c2_sp_pp0_w0FreeDirichlet_s1_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Free", &
                      bound_cond_b="Dirichlet" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w0FreeDirichlet_s1_sil1

  subroutine t_SLP_out_c2_sp_pp0_w0FreeNeumann_s0_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_sp, b=1.0_sp, N=N, &
                    p=p, &
                    q=q, &
                    bound_cond_a="Free", &
                    bound_cond_b="Neumann" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_sp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_sp_pp0_w0FreeNeumann_s0_sil0

  subroutine t_SLP_out_c2_sp_pp0_w0FreeNeumann_s0_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Free", &
                      bound_cond_b="Neumann" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w0FreeNeumann_s0_sil1

  subroutine t_SLP_out_c2_sp_pp0_w0FreeNeumann_s1_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Free", &
                      bound_cond_b="Neumann" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w0FreeNeumann_s1_sil0

  subroutine t_SLP_out_c2_sp_pp0_w0FreeNeumann_s1_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Free", &
                      bound_cond_b="Neumann" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w0FreeNeumann_s1_sil1

  subroutine t_SLP_out_c2_sp_pp0_w0FreeMixed_s0_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_sp, b=1.0_sp, N=N, &
                    p=p, &
                    q=q, &
                    bound_cond_a="Free", &
                    bound_cond_b="Mixed" &
                    , mixing_param_b=1.0_sp &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(N, 1:N - 3) + 1.0_sp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_sp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_sp_pp0_w0FreeMixed_s0_sil0

  subroutine t_SLP_out_c2_sp_pp0_w0FreeMixed_s0_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Free", &
                      bound_cond_b="Mixed" &
                      , mixing_param_b=1.0_sp &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3) + 1.0_sp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w0FreeMixed_s0_sil1

  subroutine t_SLP_out_c2_sp_pp0_w0FreeMixed_s1_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Free", &
                      bound_cond_b="Mixed" &
                      , mixing_param_b=1.0_sp &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3) + 1.0_sp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w0FreeMixed_s1_sil0

  subroutine t_SLP_out_c2_sp_pp0_w0FreeMixed_s1_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Free", &
                      bound_cond_b="Mixed" &
                      , mixing_param_b=1.0_sp &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3) + 1.0_sp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w0FreeMixed_s1_sil1

  subroutine t_SLP_out_c2_sp_pp0_w0FreeFree_s0_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_sp, b=1.0_sp, N=N, &
                    p=p, &
                    q=q, &
                    bound_cond_a="Free", &
                    bound_cond_b="Free" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
  end subroutine t_SLP_out_c2_sp_pp0_w0FreeFree_s0_sil0

  subroutine t_SLP_out_c2_sp_pp0_w0FreeFree_s0_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Free", &
                      bound_cond_b="Free" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w0FreeFree_s0_sil1

  subroutine t_SLP_out_c2_sp_pp0_w0FreeFree_s1_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Free", &
                      bound_cond_b="Free" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w0FreeFree_s1_sil0

  subroutine t_SLP_out_c2_sp_pp0_w0FreeFree_s1_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Free", &
                      bound_cond_b="Free" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w0FreeFree_s1_sil1

  subroutine t_SLP_out_c2_sp_pp0_w0FreeSingular_s0_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_sp, b=1.0_sp, N=N, &
                    p=p, &
                    q=q, &
                    bound_cond_a="Free", &
                    bound_cond_b="Singular" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
  end subroutine t_SLP_out_c2_sp_pp0_w0FreeSingular_s0_sil0

  subroutine t_SLP_out_c2_sp_pp0_w0FreeSingular_s0_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Free", &
                      bound_cond_b="Singular" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w0FreeSingular_s0_sil1

  subroutine t_SLP_out_c2_sp_pp0_w0FreeSingular_s1_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Free", &
                      bound_cond_b="Singular" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w0FreeSingular_s1_sil0

  subroutine t_SLP_out_c2_sp_pp0_w0FreeSingular_s1_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Free", &
                      bound_cond_b="Singular" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w0FreeSingular_s1_sil1

  subroutine t_SLP_out_c2_sp_pp0_w0SingularDirichlet_s0_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_sp, b=1.0_sp, N=N, &
                    p=p, &
                    q=q, &
                    bound_cond_a="Singular", &
                    bound_cond_b="Dirichlet" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(N, 1:N - 3)) > tol_sp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_sp_pp0_w0SingularDirichlet_s0_sil0

  subroutine t_SLP_out_c2_sp_pp0_w0SingularDirichlet_s0_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Singular", &
                      bound_cond_b="Dirichlet" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w0SingularDirichlet_s0_sil1

  subroutine t_SLP_out_c2_sp_pp0_w0SingularDirichlet_s1_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Singular", &
                      bound_cond_b="Dirichlet" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w0SingularDirichlet_s1_sil0

  subroutine t_SLP_out_c2_sp_pp0_w0SingularDirichlet_s1_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Singular", &
                      bound_cond_b="Dirichlet" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w0SingularDirichlet_s1_sil1

  subroutine t_SLP_out_c2_sp_pp0_w0SingularNeumann_s0_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_sp, b=1.0_sp, N=N, &
                    p=p, &
                    q=q, &
                    bound_cond_a="Singular", &
                    bound_cond_b="Neumann" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_sp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_sp_pp0_w0SingularNeumann_s0_sil0

  subroutine t_SLP_out_c2_sp_pp0_w0SingularNeumann_s0_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Singular", &
                      bound_cond_b="Neumann" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w0SingularNeumann_s0_sil1

  subroutine t_SLP_out_c2_sp_pp0_w0SingularNeumann_s1_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Singular", &
                      bound_cond_b="Neumann" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w0SingularNeumann_s1_sil0

  subroutine t_SLP_out_c2_sp_pp0_w0SingularNeumann_s1_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Singular", &
                      bound_cond_b="Neumann" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w0SingularNeumann_s1_sil1

  subroutine t_SLP_out_c2_sp_pp0_w0SingularMixed_s0_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_sp, b=1.0_sp, N=N, &
                    p=p, &
                    q=q, &
                    bound_cond_a="Singular", &
                    bound_cond_b="Mixed" &
                    , mixing_param_b=1.0_sp &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(N, 1:N - 3) + 1.0_sp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_sp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_sp_pp0_w0SingularMixed_s0_sil0

  subroutine t_SLP_out_c2_sp_pp0_w0SingularMixed_s0_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Singular", &
                      bound_cond_b="Mixed" &
                      , mixing_param_b=1.0_sp &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3) + 1.0_sp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w0SingularMixed_s0_sil1

  subroutine t_SLP_out_c2_sp_pp0_w0SingularMixed_s1_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Singular", &
                      bound_cond_b="Mixed" &
                      , mixing_param_b=1.0_sp &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3) + 1.0_sp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w0SingularMixed_s1_sil0

  subroutine t_SLP_out_c2_sp_pp0_w0SingularMixed_s1_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Singular", &
                      bound_cond_b="Mixed" &
                      , mixing_param_b=1.0_sp &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3) + 1.0_sp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w0SingularMixed_s1_sil1

  subroutine t_SLP_out_c2_sp_pp0_w0SingularFree_s0_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_sp, b=1.0_sp, N=N, &
                    p=p, &
                    q=q, &
                    bound_cond_a="Singular", &
                    bound_cond_b="Free" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
  end subroutine t_SLP_out_c2_sp_pp0_w0SingularFree_s0_sil0

  subroutine t_SLP_out_c2_sp_pp0_w0SingularFree_s0_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Singular", &
                      bound_cond_b="Free" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w0SingularFree_s0_sil1

  subroutine t_SLP_out_c2_sp_pp0_w0SingularFree_s1_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Singular", &
                      bound_cond_b="Free" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w0SingularFree_s1_sil0

  subroutine t_SLP_out_c2_sp_pp0_w0SingularFree_s1_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Singular", &
                      bound_cond_b="Free" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w0SingularFree_s1_sil1

  subroutine t_SLP_out_c2_sp_pp0_w0SingularSingular_s0_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_sp, b=1.0_sp, N=N, &
                    p=p, &
                    q=q, &
                    bound_cond_a="Singular", &
                    bound_cond_b="Singular" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
  end subroutine t_SLP_out_c2_sp_pp0_w0SingularSingular_s0_sil0

  subroutine t_SLP_out_c2_sp_pp0_w0SingularSingular_s0_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Singular", &
                      bound_cond_b="Singular" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w0SingularSingular_s0_sil1

  subroutine t_SLP_out_c2_sp_pp0_w0SingularSingular_s1_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Singular", &
                      bound_cond_b="Singular" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w0SingularSingular_s1_sil0

  subroutine t_SLP_out_c2_sp_pp0_w0SingularSingular_s1_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Singular", &
                      bound_cond_b="Singular" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w0SingularSingular_s1_sil1

  subroutine t_SLP_out_c2_sp_pp0_w1DirichletDirichlet_s0_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_sp, b=1.0_sp, N=N, &
                    p=p, &
                    q=q, &
                    w=w, &
                    bound_cond_a="Dirichlet", &
                    bound_cond_b="Dirichlet" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(1, 1:N - 3)) > tol_sp)) then
      allocate (error)
      return
    endif
    if (any(abs(vl(N, 1:N - 3)) > tol_sp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_sp_pp0_w1DirichletDirichlet_s0_sil0

  subroutine t_SLP_out_c2_sp_pp0_w1DirichletDirichlet_s0_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Dirichlet", &
                      bound_cond_b="Dirichlet" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w1DirichletDirichlet_s0_sil1

  subroutine t_SLP_out_c2_sp_pp0_w1DirichletDirichlet_s1_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Dirichlet", &
                      bound_cond_b="Dirichlet" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w1DirichletDirichlet_s1_sil0

  subroutine t_SLP_out_c2_sp_pp0_w1DirichletDirichlet_s1_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Dirichlet", &
                      bound_cond_b="Dirichlet" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w1DirichletDirichlet_s1_sil1

  subroutine t_SLP_out_c2_sp_pp0_w1DirichletNeumann_s0_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_sp, b=1.0_sp, N=N, &
                    p=p, &
                    q=q, &
                    w=w, &
                    bound_cond_a="Dirichlet", &
                    bound_cond_b="Neumann" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(1, 1:N - 3)) > tol_sp)) then
      allocate (error)
      return
    endif
    if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_sp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_sp_pp0_w1DirichletNeumann_s0_sil0

  subroutine t_SLP_out_c2_sp_pp0_w1DirichletNeumann_s0_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Dirichlet", &
                      bound_cond_b="Neumann" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w1DirichletNeumann_s0_sil1

  subroutine t_SLP_out_c2_sp_pp0_w1DirichletNeumann_s1_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Dirichlet", &
                      bound_cond_b="Neumann" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w1DirichletNeumann_s1_sil0

  subroutine t_SLP_out_c2_sp_pp0_w1DirichletNeumann_s1_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Dirichlet", &
                      bound_cond_b="Neumann" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w1DirichletNeumann_s1_sil1

  subroutine t_SLP_out_c2_sp_pp0_w1DirichletMixed_s0_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_sp, b=1.0_sp, N=N, &
                    p=p, &
                    q=q, &
                    w=w, &
                    bound_cond_a="Dirichlet", &
                    bound_cond_b="Mixed" &
                    , mixing_param_b=1.0_sp &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(1, 1:N - 3)) > tol_sp)) then
      allocate (error)
      return
    endif
    if (any(abs(vl(N, 1:N - 3) + 1.0_sp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_sp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_sp_pp0_w1DirichletMixed_s0_sil0

  subroutine t_SLP_out_c2_sp_pp0_w1DirichletMixed_s0_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Dirichlet", &
                      bound_cond_b="Mixed" &
                      , mixing_param_b=1.0_sp &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) + 1.0_sp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w1DirichletMixed_s0_sil1

  subroutine t_SLP_out_c2_sp_pp0_w1DirichletMixed_s1_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Dirichlet", &
                      bound_cond_b="Mixed" &
                      , mixing_param_b=1.0_sp &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) + 1.0_sp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w1DirichletMixed_s1_sil0

  subroutine t_SLP_out_c2_sp_pp0_w1DirichletMixed_s1_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Dirichlet", &
                      bound_cond_b="Mixed" &
                      , mixing_param_b=1.0_sp &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) + 1.0_sp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w1DirichletMixed_s1_sil1

  subroutine t_SLP_out_c2_sp_pp0_w1DirichletFree_s0_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_sp, b=1.0_sp, N=N, &
                    p=p, &
                    q=q, &
                    w=w, &
                    bound_cond_a="Dirichlet", &
                    bound_cond_b="Free" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(1, 1:N - 3)) > tol_sp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_sp_pp0_w1DirichletFree_s0_sil0

  subroutine t_SLP_out_c2_sp_pp0_w1DirichletFree_s0_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Dirichlet", &
                      bound_cond_b="Free" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w1DirichletFree_s0_sil1

  subroutine t_SLP_out_c2_sp_pp0_w1DirichletFree_s1_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Dirichlet", &
                      bound_cond_b="Free" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w1DirichletFree_s1_sil0

  subroutine t_SLP_out_c2_sp_pp0_w1DirichletFree_s1_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Dirichlet", &
                      bound_cond_b="Free" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w1DirichletFree_s1_sil1

  subroutine t_SLP_out_c2_sp_pp0_w1DirichletSingular_s0_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_sp, b=1.0_sp, N=N, &
                    p=p, &
                    q=q, &
                    w=w, &
                    bound_cond_a="Dirichlet", &
                    bound_cond_b="Singular" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(1, 1:N - 3)) > tol_sp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_sp_pp0_w1DirichletSingular_s0_sil0

  subroutine t_SLP_out_c2_sp_pp0_w1DirichletSingular_s0_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Dirichlet", &
                      bound_cond_b="Singular" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w1DirichletSingular_s0_sil1

  subroutine t_SLP_out_c2_sp_pp0_w1DirichletSingular_s1_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Dirichlet", &
                      bound_cond_b="Singular" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w1DirichletSingular_s1_sil0

  subroutine t_SLP_out_c2_sp_pp0_w1DirichletSingular_s1_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Dirichlet", &
                      bound_cond_b="Singular" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w1DirichletSingular_s1_sil1

  subroutine t_SLP_out_c2_sp_pp0_w1NeumannDirichlet_s0_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_sp, b=1.0_sp, N=N, &
                    p=p, &
                    q=q, &
                    w=w, &
                    bound_cond_a="Neumann", &
                    bound_cond_b="Dirichlet" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(N, 1:N - 3)) > tol_sp)) then
      allocate (error)
      return
    endif
    if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_sp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_sp_pp0_w1NeumannDirichlet_s0_sil0

  subroutine t_SLP_out_c2_sp_pp0_w1NeumannDirichlet_s0_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Neumann", &
                      bound_cond_b="Dirichlet" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w1NeumannDirichlet_s0_sil1

  subroutine t_SLP_out_c2_sp_pp0_w1NeumannDirichlet_s1_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Neumann", &
                      bound_cond_b="Dirichlet" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w1NeumannDirichlet_s1_sil0

  subroutine t_SLP_out_c2_sp_pp0_w1NeumannDirichlet_s1_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Neumann", &
                      bound_cond_b="Dirichlet" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w1NeumannDirichlet_s1_sil1

  subroutine t_SLP_out_c2_sp_pp0_w1NeumannNeumann_s0_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_sp, b=1.0_sp, N=N, &
                    p=p, &
                    q=q, &
                    w=w, &
                    bound_cond_a="Neumann", &
                    bound_cond_b="Neumann" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_sp)) then
      allocate (error)
      return
    endif
    if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_sp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_sp_pp0_w1NeumannNeumann_s0_sil0

  subroutine t_SLP_out_c2_sp_pp0_w1NeumannNeumann_s0_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Neumann", &
                      bound_cond_b="Neumann" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w1NeumannNeumann_s0_sil1

  subroutine t_SLP_out_c2_sp_pp0_w1NeumannNeumann_s1_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Neumann", &
                      bound_cond_b="Neumann" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w1NeumannNeumann_s1_sil0

  subroutine t_SLP_out_c2_sp_pp0_w1NeumannNeumann_s1_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Neumann", &
                      bound_cond_b="Neumann" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w1NeumannNeumann_s1_sil1

  subroutine t_SLP_out_c2_sp_pp0_w1NeumannMixed_s0_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_sp, b=1.0_sp, N=N, &
                    p=p, &
                    q=q, &
                    w=w, &
                    bound_cond_a="Neumann", &
                    bound_cond_b="Mixed" &
                    , mixing_param_b=1.0_sp &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_sp)) then
      allocate (error)
      return
    endif
    if (any(abs(vl(N, 1:N - 3) + 1.0_sp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_sp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_sp_pp0_w1NeumannMixed_s0_sil0

  subroutine t_SLP_out_c2_sp_pp0_w1NeumannMixed_s0_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Neumann", &
                      bound_cond_b="Mixed" &
                      , mixing_param_b=1.0_sp &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) + 1.0_sp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w1NeumannMixed_s0_sil1

  subroutine t_SLP_out_c2_sp_pp0_w1NeumannMixed_s1_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Neumann", &
                      bound_cond_b="Mixed" &
                      , mixing_param_b=1.0_sp &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) + 1.0_sp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w1NeumannMixed_s1_sil0

  subroutine t_SLP_out_c2_sp_pp0_w1NeumannMixed_s1_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Neumann", &
                      bound_cond_b="Mixed" &
                      , mixing_param_b=1.0_sp &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) + 1.0_sp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w1NeumannMixed_s1_sil1

  subroutine t_SLP_out_c2_sp_pp0_w1NeumannFree_s0_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_sp, b=1.0_sp, N=N, &
                    p=p, &
                    q=q, &
                    w=w, &
                    bound_cond_a="Neumann", &
                    bound_cond_b="Free" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_sp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_sp_pp0_w1NeumannFree_s0_sil0

  subroutine t_SLP_out_c2_sp_pp0_w1NeumannFree_s0_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Neumann", &
                      bound_cond_b="Free" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w1NeumannFree_s0_sil1

  subroutine t_SLP_out_c2_sp_pp0_w1NeumannFree_s1_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Neumann", &
                      bound_cond_b="Free" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w1NeumannFree_s1_sil0

  subroutine t_SLP_out_c2_sp_pp0_w1NeumannFree_s1_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Neumann", &
                      bound_cond_b="Free" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w1NeumannFree_s1_sil1

  subroutine t_SLP_out_c2_sp_pp0_w1NeumannSingular_s0_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_sp, b=1.0_sp, N=N, &
                    p=p, &
                    q=q, &
                    w=w, &
                    bound_cond_a="Neumann", &
                    bound_cond_b="Singular" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_sp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_sp_pp0_w1NeumannSingular_s0_sil0

  subroutine t_SLP_out_c2_sp_pp0_w1NeumannSingular_s0_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Neumann", &
                      bound_cond_b="Singular" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w1NeumannSingular_s0_sil1

  subroutine t_SLP_out_c2_sp_pp0_w1NeumannSingular_s1_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Neumann", &
                      bound_cond_b="Singular" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w1NeumannSingular_s1_sil0

  subroutine t_SLP_out_c2_sp_pp0_w1NeumannSingular_s1_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Neumann", &
                      bound_cond_b="Singular" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w1NeumannSingular_s1_sil1

  subroutine t_SLP_out_c2_sp_pp0_w1MixedDirichlet_s0_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_sp, b=1.0_sp, N=N, &
                    p=p, &
                    q=q, &
                    w=w, &
                    bound_cond_a="Mixed", &
                    bound_cond_b="Dirichlet" &
                    , mixing_param_a=1.0_sp &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(N, 1:N - 3)) > tol_sp)) then
      allocate (error)
      return
    endif
    if (any(abs(vl(1, 1:N - 3) - 1.0_sp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_sp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_sp_pp0_w1MixedDirichlet_s0_sil0

  subroutine t_SLP_out_c2_sp_pp0_w1MixedDirichlet_s0_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Mixed", &
                      bound_cond_b="Dirichlet" &
                      , mixing_param_a=1.0_sp &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(1, 1:N - 3) - 1.0_sp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w1MixedDirichlet_s0_sil1

  subroutine t_SLP_out_c2_sp_pp0_w1MixedDirichlet_s1_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Mixed", &
                      bound_cond_b="Dirichlet" &
                      , mixing_param_a=1.0_sp &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(1, 1:N - 3) - 1.0_sp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w1MixedDirichlet_s1_sil0

  subroutine t_SLP_out_c2_sp_pp0_w1MixedDirichlet_s1_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Mixed", &
                      bound_cond_b="Dirichlet" &
                      , mixing_param_a=1.0_sp &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(1, 1:N - 3) - 1.0_sp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w1MixedDirichlet_s1_sil1

  subroutine t_SLP_out_c2_sp_pp0_w1MixedNeumann_s0_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_sp, b=1.0_sp, N=N, &
                    p=p, &
                    q=q, &
                    w=w, &
                    bound_cond_a="Mixed", &
                    bound_cond_b="Neumann" &
                    , mixing_param_a=1.0_sp &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_sp)) then
      allocate (error)
      return
    endif
    if (any(abs(vl(1, 1:N - 3) - 1.0_sp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_sp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_sp_pp0_w1MixedNeumann_s0_sil0

  subroutine t_SLP_out_c2_sp_pp0_w1MixedNeumann_s0_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Mixed", &
                      bound_cond_b="Neumann" &
                      , mixing_param_a=1.0_sp &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(1, 1:N - 3) - 1.0_sp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w1MixedNeumann_s0_sil1

  subroutine t_SLP_out_c2_sp_pp0_w1MixedNeumann_s1_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Mixed", &
                      bound_cond_b="Neumann" &
                      , mixing_param_a=1.0_sp &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(1, 1:N - 3) - 1.0_sp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w1MixedNeumann_s1_sil0

  subroutine t_SLP_out_c2_sp_pp0_w1MixedNeumann_s1_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Mixed", &
                      bound_cond_b="Neumann" &
                      , mixing_param_a=1.0_sp &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(1, 1:N - 3) - 1.0_sp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w1MixedNeumann_s1_sil1

  subroutine t_SLP_out_c2_sp_pp0_w1MixedMixed_s0_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_sp, b=1.0_sp, N=N, &
                    p=p, &
                    q=q, &
                    w=w, &
                    bound_cond_a="Mixed", &
                    bound_cond_b="Mixed" &
                    , mixing_param_a=1.0_sp &
                    , mixing_param_b=1.0_sp &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(1, 1:N - 3) - 1.0_sp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_sp)) then
      allocate (error)
      return
    endif
    if (any(abs(vl(N, 1:N - 3) + 1.0_sp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_sp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_sp_pp0_w1MixedMixed_s0_sil0

  subroutine t_SLP_out_c2_sp_pp0_w1MixedMixed_s0_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Mixed", &
                      bound_cond_b="Mixed" &
                      , mixing_param_a=1.0_sp &
                      , mixing_param_b=1.0_sp &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - 1.0_sp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) + 1.0_sp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w1MixedMixed_s0_sil1

  subroutine t_SLP_out_c2_sp_pp0_w1MixedMixed_s1_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Mixed", &
                      bound_cond_b="Mixed" &
                      , mixing_param_a=1.0_sp &
                      , mixing_param_b=1.0_sp &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - 1.0_sp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) + 1.0_sp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w1MixedMixed_s1_sil0

  subroutine t_SLP_out_c2_sp_pp0_w1MixedMixed_s1_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Mixed", &
                      bound_cond_b="Mixed" &
                      , mixing_param_a=1.0_sp &
                      , mixing_param_b=1.0_sp &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - 1.0_sp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) + 1.0_sp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w1MixedMixed_s1_sil1

  subroutine t_SLP_out_c2_sp_pp0_w1MixedFree_s0_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_sp, b=1.0_sp, N=N, &
                    p=p, &
                    q=q, &
                    w=w, &
                    bound_cond_a="Mixed", &
                    bound_cond_b="Free" &
                    , mixing_param_a=1.0_sp &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(1, 1:N - 3) - 1.0_sp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_sp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_sp_pp0_w1MixedFree_s0_sil0

  subroutine t_SLP_out_c2_sp_pp0_w1MixedFree_s0_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Mixed", &
                      bound_cond_b="Free" &
                      , mixing_param_a=1.0_sp &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - 1.0_sp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w1MixedFree_s0_sil1

  subroutine t_SLP_out_c2_sp_pp0_w1MixedFree_s1_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Mixed", &
                      bound_cond_b="Free" &
                      , mixing_param_a=1.0_sp &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - 1.0_sp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w1MixedFree_s1_sil0

  subroutine t_SLP_out_c2_sp_pp0_w1MixedFree_s1_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Mixed", &
                      bound_cond_b="Free" &
                      , mixing_param_a=1.0_sp &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - 1.0_sp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w1MixedFree_s1_sil1

  subroutine t_SLP_out_c2_sp_pp0_w1MixedSingular_s0_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_sp, b=1.0_sp, N=N, &
                    p=p, &
                    q=q, &
                    w=w, &
                    bound_cond_a="Mixed", &
                    bound_cond_b="Singular" &
                    , mixing_param_a=1.0_sp &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(1, 1:N - 3) - 1.0_sp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_sp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_sp_pp0_w1MixedSingular_s0_sil0

  subroutine t_SLP_out_c2_sp_pp0_w1MixedSingular_s0_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Mixed", &
                      bound_cond_b="Singular" &
                      , mixing_param_a=1.0_sp &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - 1.0_sp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w1MixedSingular_s0_sil1

  subroutine t_SLP_out_c2_sp_pp0_w1MixedSingular_s1_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Mixed", &
                      bound_cond_b="Singular" &
                      , mixing_param_a=1.0_sp &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - 1.0_sp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w1MixedSingular_s1_sil0

  subroutine t_SLP_out_c2_sp_pp0_w1MixedSingular_s1_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Mixed", &
                      bound_cond_b="Singular" &
                      , mixing_param_a=1.0_sp &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - 1.0_sp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w1MixedSingular_s1_sil1

  subroutine t_SLP_out_c2_sp_pp0_w1FreeDirichlet_s0_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_sp, b=1.0_sp, N=N, &
                    p=p, &
                    q=q, &
                    w=w, &
                    bound_cond_a="Free", &
                    bound_cond_b="Dirichlet" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(N, 1:N - 3)) > tol_sp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_sp_pp0_w1FreeDirichlet_s0_sil0

  subroutine t_SLP_out_c2_sp_pp0_w1FreeDirichlet_s0_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Free", &
                      bound_cond_b="Dirichlet" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w1FreeDirichlet_s0_sil1

  subroutine t_SLP_out_c2_sp_pp0_w1FreeDirichlet_s1_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Free", &
                      bound_cond_b="Dirichlet" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w1FreeDirichlet_s1_sil0

  subroutine t_SLP_out_c2_sp_pp0_w1FreeDirichlet_s1_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Free", &
                      bound_cond_b="Dirichlet" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w1FreeDirichlet_s1_sil1

  subroutine t_SLP_out_c2_sp_pp0_w1FreeNeumann_s0_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_sp, b=1.0_sp, N=N, &
                    p=p, &
                    q=q, &
                    w=w, &
                    bound_cond_a="Free", &
                    bound_cond_b="Neumann" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_sp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_sp_pp0_w1FreeNeumann_s0_sil0

  subroutine t_SLP_out_c2_sp_pp0_w1FreeNeumann_s0_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Free", &
                      bound_cond_b="Neumann" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w1FreeNeumann_s0_sil1

  subroutine t_SLP_out_c2_sp_pp0_w1FreeNeumann_s1_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Free", &
                      bound_cond_b="Neumann" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w1FreeNeumann_s1_sil0

  subroutine t_SLP_out_c2_sp_pp0_w1FreeNeumann_s1_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Free", &
                      bound_cond_b="Neumann" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w1FreeNeumann_s1_sil1

  subroutine t_SLP_out_c2_sp_pp0_w1FreeMixed_s0_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_sp, b=1.0_sp, N=N, &
                    p=p, &
                    q=q, &
                    w=w, &
                    bound_cond_a="Free", &
                    bound_cond_b="Mixed" &
                    , mixing_param_b=1.0_sp &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(N, 1:N - 3) + 1.0_sp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_sp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_sp_pp0_w1FreeMixed_s0_sil0

  subroutine t_SLP_out_c2_sp_pp0_w1FreeMixed_s0_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Free", &
                      bound_cond_b="Mixed" &
                      , mixing_param_b=1.0_sp &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3) + 1.0_sp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w1FreeMixed_s0_sil1

  subroutine t_SLP_out_c2_sp_pp0_w1FreeMixed_s1_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Free", &
                      bound_cond_b="Mixed" &
                      , mixing_param_b=1.0_sp &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3) + 1.0_sp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w1FreeMixed_s1_sil0

  subroutine t_SLP_out_c2_sp_pp0_w1FreeMixed_s1_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Free", &
                      bound_cond_b="Mixed" &
                      , mixing_param_b=1.0_sp &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3) + 1.0_sp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w1FreeMixed_s1_sil1

  subroutine t_SLP_out_c2_sp_pp0_w1FreeFree_s0_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_sp, b=1.0_sp, N=N, &
                    p=p, &
                    q=q, &
                    w=w, &
                    bound_cond_a="Free", &
                    bound_cond_b="Free" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
  end subroutine t_SLP_out_c2_sp_pp0_w1FreeFree_s0_sil0

  subroutine t_SLP_out_c2_sp_pp0_w1FreeFree_s0_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Free", &
                      bound_cond_b="Free" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w1FreeFree_s0_sil1

  subroutine t_SLP_out_c2_sp_pp0_w1FreeFree_s1_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Free", &
                      bound_cond_b="Free" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w1FreeFree_s1_sil0

  subroutine t_SLP_out_c2_sp_pp0_w1FreeFree_s1_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Free", &
                      bound_cond_b="Free" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w1FreeFree_s1_sil1

  subroutine t_SLP_out_c2_sp_pp0_w1FreeSingular_s0_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_sp, b=1.0_sp, N=N, &
                    p=p, &
                    q=q, &
                    w=w, &
                    bound_cond_a="Free", &
                    bound_cond_b="Singular" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
  end subroutine t_SLP_out_c2_sp_pp0_w1FreeSingular_s0_sil0

  subroutine t_SLP_out_c2_sp_pp0_w1FreeSingular_s0_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Free", &
                      bound_cond_b="Singular" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w1FreeSingular_s0_sil1

  subroutine t_SLP_out_c2_sp_pp0_w1FreeSingular_s1_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Free", &
                      bound_cond_b="Singular" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w1FreeSingular_s1_sil0

  subroutine t_SLP_out_c2_sp_pp0_w1FreeSingular_s1_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Free", &
                      bound_cond_b="Singular" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w1FreeSingular_s1_sil1

  subroutine t_SLP_out_c2_sp_pp0_w1SingularDirichlet_s0_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_sp, b=1.0_sp, N=N, &
                    p=p, &
                    q=q, &
                    w=w, &
                    bound_cond_a="Singular", &
                    bound_cond_b="Dirichlet" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(N, 1:N - 3)) > tol_sp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_sp_pp0_w1SingularDirichlet_s0_sil0

  subroutine t_SLP_out_c2_sp_pp0_w1SingularDirichlet_s0_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Singular", &
                      bound_cond_b="Dirichlet" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w1SingularDirichlet_s0_sil1

  subroutine t_SLP_out_c2_sp_pp0_w1SingularDirichlet_s1_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Singular", &
                      bound_cond_b="Dirichlet" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w1SingularDirichlet_s1_sil0

  subroutine t_SLP_out_c2_sp_pp0_w1SingularDirichlet_s1_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Singular", &
                      bound_cond_b="Dirichlet" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w1SingularDirichlet_s1_sil1

  subroutine t_SLP_out_c2_sp_pp0_w1SingularNeumann_s0_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_sp, b=1.0_sp, N=N, &
                    p=p, &
                    q=q, &
                    w=w, &
                    bound_cond_a="Singular", &
                    bound_cond_b="Neumann" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_sp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_sp_pp0_w1SingularNeumann_s0_sil0

  subroutine t_SLP_out_c2_sp_pp0_w1SingularNeumann_s0_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Singular", &
                      bound_cond_b="Neumann" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w1SingularNeumann_s0_sil1

  subroutine t_SLP_out_c2_sp_pp0_w1SingularNeumann_s1_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Singular", &
                      bound_cond_b="Neumann" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w1SingularNeumann_s1_sil0

  subroutine t_SLP_out_c2_sp_pp0_w1SingularNeumann_s1_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Singular", &
                      bound_cond_b="Neumann" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w1SingularNeumann_s1_sil1

  subroutine t_SLP_out_c2_sp_pp0_w1SingularMixed_s0_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_sp, b=1.0_sp, N=N, &
                    p=p, &
                    q=q, &
                    w=w, &
                    bound_cond_a="Singular", &
                    bound_cond_b="Mixed" &
                    , mixing_param_b=1.0_sp &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(N, 1:N - 3) + 1.0_sp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_sp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_sp_pp0_w1SingularMixed_s0_sil0

  subroutine t_SLP_out_c2_sp_pp0_w1SingularMixed_s0_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Singular", &
                      bound_cond_b="Mixed" &
                      , mixing_param_b=1.0_sp &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3) + 1.0_sp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w1SingularMixed_s0_sil1

  subroutine t_SLP_out_c2_sp_pp0_w1SingularMixed_s1_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Singular", &
                      bound_cond_b="Mixed" &
                      , mixing_param_b=1.0_sp &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3) + 1.0_sp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w1SingularMixed_s1_sil0

  subroutine t_SLP_out_c2_sp_pp0_w1SingularMixed_s1_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Singular", &
                      bound_cond_b="Mixed" &
                      , mixing_param_b=1.0_sp &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3) + 1.0_sp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w1SingularMixed_s1_sil1

  subroutine t_SLP_out_c2_sp_pp0_w1SingularFree_s0_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_sp, b=1.0_sp, N=N, &
                    p=p, &
                    q=q, &
                    w=w, &
                    bound_cond_a="Singular", &
                    bound_cond_b="Free" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
  end subroutine t_SLP_out_c2_sp_pp0_w1SingularFree_s0_sil0

  subroutine t_SLP_out_c2_sp_pp0_w1SingularFree_s0_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Singular", &
                      bound_cond_b="Free" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w1SingularFree_s0_sil1

  subroutine t_SLP_out_c2_sp_pp0_w1SingularFree_s1_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Singular", &
                      bound_cond_b="Free" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w1SingularFree_s1_sil0

  subroutine t_SLP_out_c2_sp_pp0_w1SingularFree_s1_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Singular", &
                      bound_cond_b="Free" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w1SingularFree_s1_sil1

  subroutine t_SLP_out_c2_sp_pp0_w1SingularSingular_s0_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_sp, b=1.0_sp, N=N, &
                    p=p, &
                    q=q, &
                    w=w, &
                    bound_cond_a="Singular", &
                    bound_cond_b="Singular" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
  end subroutine t_SLP_out_c2_sp_pp0_w1SingularSingular_s0_sil0

  subroutine t_SLP_out_c2_sp_pp0_w1SingularSingular_s0_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Singular", &
                      bound_cond_b="Singular" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w1SingularSingular_s0_sil1

  subroutine t_SLP_out_c2_sp_pp0_w1SingularSingular_s1_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Singular", &
                      bound_cond_b="Singular" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w1SingularSingular_s1_sil0

  subroutine t_SLP_out_c2_sp_pp0_w1SingularSingular_s1_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Singular", &
                      bound_cond_b="Singular" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w1SingularSingular_s1_sil1

  subroutine t_SLP_out_c2_sp_pp1_w0DirichletDirichlet_s0_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_sp, b=1.0_sp, N=N, &
                    p=p, &
                    pp=pp, &
                    q=q, &
                    bound_cond_a="Dirichlet", &
                    bound_cond_b="Dirichlet" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(1, 1:N - 3)) > tol_sp)) then
      allocate (error)
      return
    endif
    if (any(abs(vl(N, 1:N - 3)) > tol_sp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_sp_pp1_w0DirichletDirichlet_s0_sil0

  subroutine t_SLP_out_c2_sp_pp1_w0DirichletDirichlet_s0_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Dirichlet", &
                      bound_cond_b="Dirichlet" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w0DirichletDirichlet_s0_sil1

  subroutine t_SLP_out_c2_sp_pp1_w0DirichletDirichlet_s1_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Dirichlet", &
                      bound_cond_b="Dirichlet" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w0DirichletDirichlet_s1_sil0

  subroutine t_SLP_out_c2_sp_pp1_w0DirichletDirichlet_s1_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Dirichlet", &
                      bound_cond_b="Dirichlet" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w0DirichletDirichlet_s1_sil1

  subroutine t_SLP_out_c2_sp_pp1_w0DirichletNeumann_s0_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_sp, b=1.0_sp, N=N, &
                    p=p, &
                    pp=pp, &
                    q=q, &
                    bound_cond_a="Dirichlet", &
                    bound_cond_b="Neumann" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(1, 1:N - 3)) > tol_sp)) then
      allocate (error)
      return
    endif
    if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_sp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_sp_pp1_w0DirichletNeumann_s0_sil0

  subroutine t_SLP_out_c2_sp_pp1_w0DirichletNeumann_s0_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Dirichlet", &
                      bound_cond_b="Neumann" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w0DirichletNeumann_s0_sil1

  subroutine t_SLP_out_c2_sp_pp1_w0DirichletNeumann_s1_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Dirichlet", &
                      bound_cond_b="Neumann" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w0DirichletNeumann_s1_sil0

  subroutine t_SLP_out_c2_sp_pp1_w0DirichletNeumann_s1_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Dirichlet", &
                      bound_cond_b="Neumann" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w0DirichletNeumann_s1_sil1

  subroutine t_SLP_out_c2_sp_pp1_w0DirichletMixed_s0_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_sp, b=1.0_sp, N=N, &
                    p=p, &
                    pp=pp, &
                    q=q, &
                    bound_cond_a="Dirichlet", &
                    bound_cond_b="Mixed" &
                    , mixing_param_b=1.0_sp &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(1, 1:N - 3)) > tol_sp)) then
      allocate (error)
      return
    endif
    if (any(abs(vl(N, 1:N - 3) + 1.0_sp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_sp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_sp_pp1_w0DirichletMixed_s0_sil0

  subroutine t_SLP_out_c2_sp_pp1_w0DirichletMixed_s0_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Dirichlet", &
                      bound_cond_b="Mixed" &
                      , mixing_param_b=1.0_sp &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) + 1.0_sp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w0DirichletMixed_s0_sil1

  subroutine t_SLP_out_c2_sp_pp1_w0DirichletMixed_s1_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Dirichlet", &
                      bound_cond_b="Mixed" &
                      , mixing_param_b=1.0_sp &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) + 1.0_sp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w0DirichletMixed_s1_sil0

  subroutine t_SLP_out_c2_sp_pp1_w0DirichletMixed_s1_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Dirichlet", &
                      bound_cond_b="Mixed" &
                      , mixing_param_b=1.0_sp &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) + 1.0_sp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w0DirichletMixed_s1_sil1

  subroutine t_SLP_out_c2_sp_pp1_w0DirichletFree_s0_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_sp, b=1.0_sp, N=N, &
                    p=p, &
                    pp=pp, &
                    q=q, &
                    bound_cond_a="Dirichlet", &
                    bound_cond_b="Free" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(1, 1:N - 3)) > tol_sp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_sp_pp1_w0DirichletFree_s0_sil0

  subroutine t_SLP_out_c2_sp_pp1_w0DirichletFree_s0_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Dirichlet", &
                      bound_cond_b="Free" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w0DirichletFree_s0_sil1

  subroutine t_SLP_out_c2_sp_pp1_w0DirichletFree_s1_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Dirichlet", &
                      bound_cond_b="Free" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w0DirichletFree_s1_sil0

  subroutine t_SLP_out_c2_sp_pp1_w0DirichletFree_s1_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Dirichlet", &
                      bound_cond_b="Free" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w0DirichletFree_s1_sil1

  subroutine t_SLP_out_c2_sp_pp1_w0DirichletSingular_s0_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_sp, b=1.0_sp, N=N, &
                    p=p, &
                    pp=pp, &
                    q=q, &
                    bound_cond_a="Dirichlet", &
                    bound_cond_b="Singular" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(1, 1:N - 3)) > tol_sp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_sp_pp1_w0DirichletSingular_s0_sil0

  subroutine t_SLP_out_c2_sp_pp1_w0DirichletSingular_s0_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Dirichlet", &
                      bound_cond_b="Singular" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w0DirichletSingular_s0_sil1

  subroutine t_SLP_out_c2_sp_pp1_w0DirichletSingular_s1_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Dirichlet", &
                      bound_cond_b="Singular" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w0DirichletSingular_s1_sil0

  subroutine t_SLP_out_c2_sp_pp1_w0DirichletSingular_s1_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Dirichlet", &
                      bound_cond_b="Singular" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w0DirichletSingular_s1_sil1

  subroutine t_SLP_out_c2_sp_pp1_w0NeumannDirichlet_s0_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_sp, b=1.0_sp, N=N, &
                    p=p, &
                    pp=pp, &
                    q=q, &
                    bound_cond_a="Neumann", &
                    bound_cond_b="Dirichlet" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(N, 1:N - 3)) > tol_sp)) then
      allocate (error)
      return
    endif
    if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_sp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_sp_pp1_w0NeumannDirichlet_s0_sil0

  subroutine t_SLP_out_c2_sp_pp1_w0NeumannDirichlet_s0_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Neumann", &
                      bound_cond_b="Dirichlet" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w0NeumannDirichlet_s0_sil1

  subroutine t_SLP_out_c2_sp_pp1_w0NeumannDirichlet_s1_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Neumann", &
                      bound_cond_b="Dirichlet" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w0NeumannDirichlet_s1_sil0

  subroutine t_SLP_out_c2_sp_pp1_w0NeumannDirichlet_s1_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Neumann", &
                      bound_cond_b="Dirichlet" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w0NeumannDirichlet_s1_sil1

  subroutine t_SLP_out_c2_sp_pp1_w0NeumannNeumann_s0_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_sp, b=1.0_sp, N=N, &
                    p=p, &
                    pp=pp, &
                    q=q, &
                    bound_cond_a="Neumann", &
                    bound_cond_b="Neumann" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_sp)) then
      allocate (error)
      return
    endif
    if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_sp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_sp_pp1_w0NeumannNeumann_s0_sil0

  subroutine t_SLP_out_c2_sp_pp1_w0NeumannNeumann_s0_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Neumann", &
                      bound_cond_b="Neumann" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w0NeumannNeumann_s0_sil1

  subroutine t_SLP_out_c2_sp_pp1_w0NeumannNeumann_s1_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Neumann", &
                      bound_cond_b="Neumann" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w0NeumannNeumann_s1_sil0

  subroutine t_SLP_out_c2_sp_pp1_w0NeumannNeumann_s1_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Neumann", &
                      bound_cond_b="Neumann" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w0NeumannNeumann_s1_sil1

  subroutine t_SLP_out_c2_sp_pp1_w0NeumannMixed_s0_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_sp, b=1.0_sp, N=N, &
                    p=p, &
                    pp=pp, &
                    q=q, &
                    bound_cond_a="Neumann", &
                    bound_cond_b="Mixed" &
                    , mixing_param_b=1.0_sp &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_sp)) then
      allocate (error)
      return
    endif
    if (any(abs(vl(N, 1:N - 3) + 1.0_sp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_sp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_sp_pp1_w0NeumannMixed_s0_sil0

  subroutine t_SLP_out_c2_sp_pp1_w0NeumannMixed_s0_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Neumann", &
                      bound_cond_b="Mixed" &
                      , mixing_param_b=1.0_sp &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) + 1.0_sp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w0NeumannMixed_s0_sil1

  subroutine t_SLP_out_c2_sp_pp1_w0NeumannMixed_s1_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Neumann", &
                      bound_cond_b="Mixed" &
                      , mixing_param_b=1.0_sp &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) + 1.0_sp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w0NeumannMixed_s1_sil0

  subroutine t_SLP_out_c2_sp_pp1_w0NeumannMixed_s1_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Neumann", &
                      bound_cond_b="Mixed" &
                      , mixing_param_b=1.0_sp &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) + 1.0_sp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w0NeumannMixed_s1_sil1

  subroutine t_SLP_out_c2_sp_pp1_w0NeumannFree_s0_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_sp, b=1.0_sp, N=N, &
                    p=p, &
                    pp=pp, &
                    q=q, &
                    bound_cond_a="Neumann", &
                    bound_cond_b="Free" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_sp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_sp_pp1_w0NeumannFree_s0_sil0

  subroutine t_SLP_out_c2_sp_pp1_w0NeumannFree_s0_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Neumann", &
                      bound_cond_b="Free" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w0NeumannFree_s0_sil1

  subroutine t_SLP_out_c2_sp_pp1_w0NeumannFree_s1_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Neumann", &
                      bound_cond_b="Free" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w0NeumannFree_s1_sil0

  subroutine t_SLP_out_c2_sp_pp1_w0NeumannFree_s1_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Neumann", &
                      bound_cond_b="Free" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w0NeumannFree_s1_sil1

  subroutine t_SLP_out_c2_sp_pp1_w0NeumannSingular_s0_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_sp, b=1.0_sp, N=N, &
                    p=p, &
                    pp=pp, &
                    q=q, &
                    bound_cond_a="Neumann", &
                    bound_cond_b="Singular" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_sp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_sp_pp1_w0NeumannSingular_s0_sil0

  subroutine t_SLP_out_c2_sp_pp1_w0NeumannSingular_s0_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Neumann", &
                      bound_cond_b="Singular" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w0NeumannSingular_s0_sil1

  subroutine t_SLP_out_c2_sp_pp1_w0NeumannSingular_s1_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Neumann", &
                      bound_cond_b="Singular" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w0NeumannSingular_s1_sil0

  subroutine t_SLP_out_c2_sp_pp1_w0NeumannSingular_s1_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Neumann", &
                      bound_cond_b="Singular" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w0NeumannSingular_s1_sil1

  subroutine t_SLP_out_c2_sp_pp1_w0MixedDirichlet_s0_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_sp, b=1.0_sp, N=N, &
                    p=p, &
                    pp=pp, &
                    q=q, &
                    bound_cond_a="Mixed", &
                    bound_cond_b="Dirichlet" &
                    , mixing_param_a=1.0_sp &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(N, 1:N - 3)) > tol_sp)) then
      allocate (error)
      return
    endif
    if (any(abs(vl(1, 1:N - 3) - 1.0_sp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_sp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_sp_pp1_w0MixedDirichlet_s0_sil0

  subroutine t_SLP_out_c2_sp_pp1_w0MixedDirichlet_s0_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Mixed", &
                      bound_cond_b="Dirichlet" &
                      , mixing_param_a=1.0_sp &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(1, 1:N - 3) - 1.0_sp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w0MixedDirichlet_s0_sil1

  subroutine t_SLP_out_c2_sp_pp1_w0MixedDirichlet_s1_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Mixed", &
                      bound_cond_b="Dirichlet" &
                      , mixing_param_a=1.0_sp &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(1, 1:N - 3) - 1.0_sp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w0MixedDirichlet_s1_sil0

  subroutine t_SLP_out_c2_sp_pp1_w0MixedDirichlet_s1_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Mixed", &
                      bound_cond_b="Dirichlet" &
                      , mixing_param_a=1.0_sp &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(1, 1:N - 3) - 1.0_sp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w0MixedDirichlet_s1_sil1

  subroutine t_SLP_out_c2_sp_pp1_w0MixedNeumann_s0_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_sp, b=1.0_sp, N=N, &
                    p=p, &
                    pp=pp, &
                    q=q, &
                    bound_cond_a="Mixed", &
                    bound_cond_b="Neumann" &
                    , mixing_param_a=1.0_sp &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_sp)) then
      allocate (error)
      return
    endif
    if (any(abs(vl(1, 1:N - 3) - 1.0_sp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_sp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_sp_pp1_w0MixedNeumann_s0_sil0

  subroutine t_SLP_out_c2_sp_pp1_w0MixedNeumann_s0_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Mixed", &
                      bound_cond_b="Neumann" &
                      , mixing_param_a=1.0_sp &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(1, 1:N - 3) - 1.0_sp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w0MixedNeumann_s0_sil1

  subroutine t_SLP_out_c2_sp_pp1_w0MixedNeumann_s1_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Mixed", &
                      bound_cond_b="Neumann" &
                      , mixing_param_a=1.0_sp &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(1, 1:N - 3) - 1.0_sp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w0MixedNeumann_s1_sil0

  subroutine t_SLP_out_c2_sp_pp1_w0MixedNeumann_s1_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Mixed", &
                      bound_cond_b="Neumann" &
                      , mixing_param_a=1.0_sp &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(1, 1:N - 3) - 1.0_sp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w0MixedNeumann_s1_sil1

  subroutine t_SLP_out_c2_sp_pp1_w0MixedMixed_s0_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_sp, b=1.0_sp, N=N, &
                    p=p, &
                    pp=pp, &
                    q=q, &
                    bound_cond_a="Mixed", &
                    bound_cond_b="Mixed" &
                    , mixing_param_a=1.0_sp &
                    , mixing_param_b=1.0_sp &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(1, 1:N - 3) - 1.0_sp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_sp)) then
      allocate (error)
      return
    endif
    if (any(abs(vl(N, 1:N - 3) + 1.0_sp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_sp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_sp_pp1_w0MixedMixed_s0_sil0

  subroutine t_SLP_out_c2_sp_pp1_w0MixedMixed_s0_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Mixed", &
                      bound_cond_b="Mixed" &
                      , mixing_param_a=1.0_sp &
                      , mixing_param_b=1.0_sp &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - 1.0_sp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) + 1.0_sp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w0MixedMixed_s0_sil1

  subroutine t_SLP_out_c2_sp_pp1_w0MixedMixed_s1_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Mixed", &
                      bound_cond_b="Mixed" &
                      , mixing_param_a=1.0_sp &
                      , mixing_param_b=1.0_sp &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - 1.0_sp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) + 1.0_sp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w0MixedMixed_s1_sil0

  subroutine t_SLP_out_c2_sp_pp1_w0MixedMixed_s1_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Mixed", &
                      bound_cond_b="Mixed" &
                      , mixing_param_a=1.0_sp &
                      , mixing_param_b=1.0_sp &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - 1.0_sp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) + 1.0_sp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w0MixedMixed_s1_sil1

  subroutine t_SLP_out_c2_sp_pp1_w0MixedFree_s0_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_sp, b=1.0_sp, N=N, &
                    p=p, &
                    pp=pp, &
                    q=q, &
                    bound_cond_a="Mixed", &
                    bound_cond_b="Free" &
                    , mixing_param_a=1.0_sp &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(1, 1:N - 3) - 1.0_sp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_sp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_sp_pp1_w0MixedFree_s0_sil0

  subroutine t_SLP_out_c2_sp_pp1_w0MixedFree_s0_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Mixed", &
                      bound_cond_b="Free" &
                      , mixing_param_a=1.0_sp &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - 1.0_sp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w0MixedFree_s0_sil1

  subroutine t_SLP_out_c2_sp_pp1_w0MixedFree_s1_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Mixed", &
                      bound_cond_b="Free" &
                      , mixing_param_a=1.0_sp &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - 1.0_sp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w0MixedFree_s1_sil0

  subroutine t_SLP_out_c2_sp_pp1_w0MixedFree_s1_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Mixed", &
                      bound_cond_b="Free" &
                      , mixing_param_a=1.0_sp &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - 1.0_sp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w0MixedFree_s1_sil1

  subroutine t_SLP_out_c2_sp_pp1_w0MixedSingular_s0_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_sp, b=1.0_sp, N=N, &
                    p=p, &
                    pp=pp, &
                    q=q, &
                    bound_cond_a="Mixed", &
                    bound_cond_b="Singular" &
                    , mixing_param_a=1.0_sp &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(1, 1:N - 3) - 1.0_sp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_sp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_sp_pp1_w0MixedSingular_s0_sil0

  subroutine t_SLP_out_c2_sp_pp1_w0MixedSingular_s0_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Mixed", &
                      bound_cond_b="Singular" &
                      , mixing_param_a=1.0_sp &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - 1.0_sp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w0MixedSingular_s0_sil1

  subroutine t_SLP_out_c2_sp_pp1_w0MixedSingular_s1_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Mixed", &
                      bound_cond_b="Singular" &
                      , mixing_param_a=1.0_sp &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - 1.0_sp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w0MixedSingular_s1_sil0

  subroutine t_SLP_out_c2_sp_pp1_w0MixedSingular_s1_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Mixed", &
                      bound_cond_b="Singular" &
                      , mixing_param_a=1.0_sp &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - 1.0_sp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w0MixedSingular_s1_sil1

  subroutine t_SLP_out_c2_sp_pp1_w0FreeDirichlet_s0_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_sp, b=1.0_sp, N=N, &
                    p=p, &
                    pp=pp, &
                    q=q, &
                    bound_cond_a="Free", &
                    bound_cond_b="Dirichlet" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(N, 1:N - 3)) > tol_sp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_sp_pp1_w0FreeDirichlet_s0_sil0

  subroutine t_SLP_out_c2_sp_pp1_w0FreeDirichlet_s0_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Free", &
                      bound_cond_b="Dirichlet" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w0FreeDirichlet_s0_sil1

  subroutine t_SLP_out_c2_sp_pp1_w0FreeDirichlet_s1_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Free", &
                      bound_cond_b="Dirichlet" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w0FreeDirichlet_s1_sil0

  subroutine t_SLP_out_c2_sp_pp1_w0FreeDirichlet_s1_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Free", &
                      bound_cond_b="Dirichlet" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w0FreeDirichlet_s1_sil1

  subroutine t_SLP_out_c2_sp_pp1_w0FreeNeumann_s0_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_sp, b=1.0_sp, N=N, &
                    p=p, &
                    pp=pp, &
                    q=q, &
                    bound_cond_a="Free", &
                    bound_cond_b="Neumann" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_sp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_sp_pp1_w0FreeNeumann_s0_sil0

  subroutine t_SLP_out_c2_sp_pp1_w0FreeNeumann_s0_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Free", &
                      bound_cond_b="Neumann" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w0FreeNeumann_s0_sil1

  subroutine t_SLP_out_c2_sp_pp1_w0FreeNeumann_s1_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Free", &
                      bound_cond_b="Neumann" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w0FreeNeumann_s1_sil0

  subroutine t_SLP_out_c2_sp_pp1_w0FreeNeumann_s1_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Free", &
                      bound_cond_b="Neumann" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w0FreeNeumann_s1_sil1

  subroutine t_SLP_out_c2_sp_pp1_w0FreeMixed_s0_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_sp, b=1.0_sp, N=N, &
                    p=p, &
                    pp=pp, &
                    q=q, &
                    bound_cond_a="Free", &
                    bound_cond_b="Mixed" &
                    , mixing_param_b=1.0_sp &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(N, 1:N - 3) + 1.0_sp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_sp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_sp_pp1_w0FreeMixed_s0_sil0

  subroutine t_SLP_out_c2_sp_pp1_w0FreeMixed_s0_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Free", &
                      bound_cond_b="Mixed" &
                      , mixing_param_b=1.0_sp &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3) + 1.0_sp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w0FreeMixed_s0_sil1

  subroutine t_SLP_out_c2_sp_pp1_w0FreeMixed_s1_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Free", &
                      bound_cond_b="Mixed" &
                      , mixing_param_b=1.0_sp &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3) + 1.0_sp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w0FreeMixed_s1_sil0

  subroutine t_SLP_out_c2_sp_pp1_w0FreeMixed_s1_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Free", &
                      bound_cond_b="Mixed" &
                      , mixing_param_b=1.0_sp &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3) + 1.0_sp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w0FreeMixed_s1_sil1

  subroutine t_SLP_out_c2_sp_pp1_w0FreeFree_s0_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_sp, b=1.0_sp, N=N, &
                    p=p, &
                    pp=pp, &
                    q=q, &
                    bound_cond_a="Free", &
                    bound_cond_b="Free" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
  end subroutine t_SLP_out_c2_sp_pp1_w0FreeFree_s0_sil0

  subroutine t_SLP_out_c2_sp_pp1_w0FreeFree_s0_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Free", &
                      bound_cond_b="Free" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w0FreeFree_s0_sil1

  subroutine t_SLP_out_c2_sp_pp1_w0FreeFree_s1_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Free", &
                      bound_cond_b="Free" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w0FreeFree_s1_sil0

  subroutine t_SLP_out_c2_sp_pp1_w0FreeFree_s1_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Free", &
                      bound_cond_b="Free" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w0FreeFree_s1_sil1

  subroutine t_SLP_out_c2_sp_pp1_w0FreeSingular_s0_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_sp, b=1.0_sp, N=N, &
                    p=p, &
                    pp=pp, &
                    q=q, &
                    bound_cond_a="Free", &
                    bound_cond_b="Singular" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
  end subroutine t_SLP_out_c2_sp_pp1_w0FreeSingular_s0_sil0

  subroutine t_SLP_out_c2_sp_pp1_w0FreeSingular_s0_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Free", &
                      bound_cond_b="Singular" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w0FreeSingular_s0_sil1

  subroutine t_SLP_out_c2_sp_pp1_w0FreeSingular_s1_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Free", &
                      bound_cond_b="Singular" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w0FreeSingular_s1_sil0

  subroutine t_SLP_out_c2_sp_pp1_w0FreeSingular_s1_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Free", &
                      bound_cond_b="Singular" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w0FreeSingular_s1_sil1

  subroutine t_SLP_out_c2_sp_pp1_w0SingularDirichlet_s0_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_sp, b=1.0_sp, N=N, &
                    p=p, &
                    pp=pp, &
                    q=q, &
                    bound_cond_a="Singular", &
                    bound_cond_b="Dirichlet" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(N, 1:N - 3)) > tol_sp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_sp_pp1_w0SingularDirichlet_s0_sil0

  subroutine t_SLP_out_c2_sp_pp1_w0SingularDirichlet_s0_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Singular", &
                      bound_cond_b="Dirichlet" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w0SingularDirichlet_s0_sil1

  subroutine t_SLP_out_c2_sp_pp1_w0SingularDirichlet_s1_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Singular", &
                      bound_cond_b="Dirichlet" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w0SingularDirichlet_s1_sil0

  subroutine t_SLP_out_c2_sp_pp1_w0SingularDirichlet_s1_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Singular", &
                      bound_cond_b="Dirichlet" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w0SingularDirichlet_s1_sil1

  subroutine t_SLP_out_c2_sp_pp1_w0SingularNeumann_s0_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_sp, b=1.0_sp, N=N, &
                    p=p, &
                    pp=pp, &
                    q=q, &
                    bound_cond_a="Singular", &
                    bound_cond_b="Neumann" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_sp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_sp_pp1_w0SingularNeumann_s0_sil0

  subroutine t_SLP_out_c2_sp_pp1_w0SingularNeumann_s0_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Singular", &
                      bound_cond_b="Neumann" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w0SingularNeumann_s0_sil1

  subroutine t_SLP_out_c2_sp_pp1_w0SingularNeumann_s1_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Singular", &
                      bound_cond_b="Neumann" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w0SingularNeumann_s1_sil0

  subroutine t_SLP_out_c2_sp_pp1_w0SingularNeumann_s1_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Singular", &
                      bound_cond_b="Neumann" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w0SingularNeumann_s1_sil1

  subroutine t_SLP_out_c2_sp_pp1_w0SingularMixed_s0_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_sp, b=1.0_sp, N=N, &
                    p=p, &
                    pp=pp, &
                    q=q, &
                    bound_cond_a="Singular", &
                    bound_cond_b="Mixed" &
                    , mixing_param_b=1.0_sp &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(N, 1:N - 3) + 1.0_sp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_sp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_sp_pp1_w0SingularMixed_s0_sil0

  subroutine t_SLP_out_c2_sp_pp1_w0SingularMixed_s0_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Singular", &
                      bound_cond_b="Mixed" &
                      , mixing_param_b=1.0_sp &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3) + 1.0_sp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w0SingularMixed_s0_sil1

  subroutine t_SLP_out_c2_sp_pp1_w0SingularMixed_s1_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Singular", &
                      bound_cond_b="Mixed" &
                      , mixing_param_b=1.0_sp &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3) + 1.0_sp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w0SingularMixed_s1_sil0

  subroutine t_SLP_out_c2_sp_pp1_w0SingularMixed_s1_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Singular", &
                      bound_cond_b="Mixed" &
                      , mixing_param_b=1.0_sp &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3) + 1.0_sp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w0SingularMixed_s1_sil1

  subroutine t_SLP_out_c2_sp_pp1_w0SingularFree_s0_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_sp, b=1.0_sp, N=N, &
                    p=p, &
                    pp=pp, &
                    q=q, &
                    bound_cond_a="Singular", &
                    bound_cond_b="Free" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
  end subroutine t_SLP_out_c2_sp_pp1_w0SingularFree_s0_sil0

  subroutine t_SLP_out_c2_sp_pp1_w0SingularFree_s0_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Singular", &
                      bound_cond_b="Free" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w0SingularFree_s0_sil1

  subroutine t_SLP_out_c2_sp_pp1_w0SingularFree_s1_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Singular", &
                      bound_cond_b="Free" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w0SingularFree_s1_sil0

  subroutine t_SLP_out_c2_sp_pp1_w0SingularFree_s1_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Singular", &
                      bound_cond_b="Free" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w0SingularFree_s1_sil1

  subroutine t_SLP_out_c2_sp_pp1_w0SingularSingular_s0_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_sp, b=1.0_sp, N=N, &
                    p=p, &
                    pp=pp, &
                    q=q, &
                    bound_cond_a="Singular", &
                    bound_cond_b="Singular" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
  end subroutine t_SLP_out_c2_sp_pp1_w0SingularSingular_s0_sil0

  subroutine t_SLP_out_c2_sp_pp1_w0SingularSingular_s0_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Singular", &
                      bound_cond_b="Singular" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w0SingularSingular_s0_sil1

  subroutine t_SLP_out_c2_sp_pp1_w0SingularSingular_s1_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Singular", &
                      bound_cond_b="Singular" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w0SingularSingular_s1_sil0

  subroutine t_SLP_out_c2_sp_pp1_w0SingularSingular_s1_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Singular", &
                      bound_cond_b="Singular" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w0SingularSingular_s1_sil1

  subroutine t_SLP_out_c2_sp_pp1_w1DirichletDirichlet_s0_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_sp, b=1.0_sp, N=N, &
                    p=p, &
                    pp=pp, &
                    q=q, &
                    w=w, &
                    bound_cond_a="Dirichlet", &
                    bound_cond_b="Dirichlet" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(1, 1:N - 3)) > tol_sp)) then
      allocate (error)
      return
    endif
    if (any(abs(vl(N, 1:N - 3)) > tol_sp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_sp_pp1_w1DirichletDirichlet_s0_sil0

  subroutine t_SLP_out_c2_sp_pp1_w1DirichletDirichlet_s0_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Dirichlet", &
                      bound_cond_b="Dirichlet" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w1DirichletDirichlet_s0_sil1

  subroutine t_SLP_out_c2_sp_pp1_w1DirichletDirichlet_s1_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Dirichlet", &
                      bound_cond_b="Dirichlet" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w1DirichletDirichlet_s1_sil0

  subroutine t_SLP_out_c2_sp_pp1_w1DirichletDirichlet_s1_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Dirichlet", &
                      bound_cond_b="Dirichlet" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w1DirichletDirichlet_s1_sil1

  subroutine t_SLP_out_c2_sp_pp1_w1DirichletNeumann_s0_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_sp, b=1.0_sp, N=N, &
                    p=p, &
                    pp=pp, &
                    q=q, &
                    w=w, &
                    bound_cond_a="Dirichlet", &
                    bound_cond_b="Neumann" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(1, 1:N - 3)) > tol_sp)) then
      allocate (error)
      return
    endif
    if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_sp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_sp_pp1_w1DirichletNeumann_s0_sil0

  subroutine t_SLP_out_c2_sp_pp1_w1DirichletNeumann_s0_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Dirichlet", &
                      bound_cond_b="Neumann" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w1DirichletNeumann_s0_sil1

  subroutine t_SLP_out_c2_sp_pp1_w1DirichletNeumann_s1_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Dirichlet", &
                      bound_cond_b="Neumann" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w1DirichletNeumann_s1_sil0

  subroutine t_SLP_out_c2_sp_pp1_w1DirichletNeumann_s1_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Dirichlet", &
                      bound_cond_b="Neumann" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w1DirichletNeumann_s1_sil1

  subroutine t_SLP_out_c2_sp_pp1_w1DirichletMixed_s0_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_sp, b=1.0_sp, N=N, &
                    p=p, &
                    pp=pp, &
                    q=q, &
                    w=w, &
                    bound_cond_a="Dirichlet", &
                    bound_cond_b="Mixed" &
                    , mixing_param_b=1.0_sp &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(1, 1:N - 3)) > tol_sp)) then
      allocate (error)
      return
    endif
    if (any(abs(vl(N, 1:N - 3) + 1.0_sp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_sp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_sp_pp1_w1DirichletMixed_s0_sil0

  subroutine t_SLP_out_c2_sp_pp1_w1DirichletMixed_s0_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Dirichlet", &
                      bound_cond_b="Mixed" &
                      , mixing_param_b=1.0_sp &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) + 1.0_sp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w1DirichletMixed_s0_sil1

  subroutine t_SLP_out_c2_sp_pp1_w1DirichletMixed_s1_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Dirichlet", &
                      bound_cond_b="Mixed" &
                      , mixing_param_b=1.0_sp &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) + 1.0_sp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w1DirichletMixed_s1_sil0

  subroutine t_SLP_out_c2_sp_pp1_w1DirichletMixed_s1_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Dirichlet", &
                      bound_cond_b="Mixed" &
                      , mixing_param_b=1.0_sp &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) + 1.0_sp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w1DirichletMixed_s1_sil1

  subroutine t_SLP_out_c2_sp_pp1_w1DirichletFree_s0_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_sp, b=1.0_sp, N=N, &
                    p=p, &
                    pp=pp, &
                    q=q, &
                    w=w, &
                    bound_cond_a="Dirichlet", &
                    bound_cond_b="Free" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(1, 1:N - 3)) > tol_sp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_sp_pp1_w1DirichletFree_s0_sil0

  subroutine t_SLP_out_c2_sp_pp1_w1DirichletFree_s0_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Dirichlet", &
                      bound_cond_b="Free" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w1DirichletFree_s0_sil1

  subroutine t_SLP_out_c2_sp_pp1_w1DirichletFree_s1_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Dirichlet", &
                      bound_cond_b="Free" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w1DirichletFree_s1_sil0

  subroutine t_SLP_out_c2_sp_pp1_w1DirichletFree_s1_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Dirichlet", &
                      bound_cond_b="Free" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w1DirichletFree_s1_sil1

  subroutine t_SLP_out_c2_sp_pp1_w1DirichletSingular_s0_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_sp, b=1.0_sp, N=N, &
                    p=p, &
                    pp=pp, &
                    q=q, &
                    w=w, &
                    bound_cond_a="Dirichlet", &
                    bound_cond_b="Singular" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(1, 1:N - 3)) > tol_sp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_sp_pp1_w1DirichletSingular_s0_sil0

  subroutine t_SLP_out_c2_sp_pp1_w1DirichletSingular_s0_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Dirichlet", &
                      bound_cond_b="Singular" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w1DirichletSingular_s0_sil1

  subroutine t_SLP_out_c2_sp_pp1_w1DirichletSingular_s1_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Dirichlet", &
                      bound_cond_b="Singular" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w1DirichletSingular_s1_sil0

  subroutine t_SLP_out_c2_sp_pp1_w1DirichletSingular_s1_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Dirichlet", &
                      bound_cond_b="Singular" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w1DirichletSingular_s1_sil1

  subroutine t_SLP_out_c2_sp_pp1_w1NeumannDirichlet_s0_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_sp, b=1.0_sp, N=N, &
                    p=p, &
                    pp=pp, &
                    q=q, &
                    w=w, &
                    bound_cond_a="Neumann", &
                    bound_cond_b="Dirichlet" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(N, 1:N - 3)) > tol_sp)) then
      allocate (error)
      return
    endif
    if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_sp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_sp_pp1_w1NeumannDirichlet_s0_sil0

  subroutine t_SLP_out_c2_sp_pp1_w1NeumannDirichlet_s0_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Neumann", &
                      bound_cond_b="Dirichlet" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w1NeumannDirichlet_s0_sil1

  subroutine t_SLP_out_c2_sp_pp1_w1NeumannDirichlet_s1_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Neumann", &
                      bound_cond_b="Dirichlet" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w1NeumannDirichlet_s1_sil0

  subroutine t_SLP_out_c2_sp_pp1_w1NeumannDirichlet_s1_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Neumann", &
                      bound_cond_b="Dirichlet" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w1NeumannDirichlet_s1_sil1

  subroutine t_SLP_out_c2_sp_pp1_w1NeumannNeumann_s0_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_sp, b=1.0_sp, N=N, &
                    p=p, &
                    pp=pp, &
                    q=q, &
                    w=w, &
                    bound_cond_a="Neumann", &
                    bound_cond_b="Neumann" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_sp)) then
      allocate (error)
      return
    endif
    if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_sp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_sp_pp1_w1NeumannNeumann_s0_sil0

  subroutine t_SLP_out_c2_sp_pp1_w1NeumannNeumann_s0_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Neumann", &
                      bound_cond_b="Neumann" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w1NeumannNeumann_s0_sil1

  subroutine t_SLP_out_c2_sp_pp1_w1NeumannNeumann_s1_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Neumann", &
                      bound_cond_b="Neumann" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w1NeumannNeumann_s1_sil0

  subroutine t_SLP_out_c2_sp_pp1_w1NeumannNeumann_s1_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Neumann", &
                      bound_cond_b="Neumann" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w1NeumannNeumann_s1_sil1

  subroutine t_SLP_out_c2_sp_pp1_w1NeumannMixed_s0_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_sp, b=1.0_sp, N=N, &
                    p=p, &
                    pp=pp, &
                    q=q, &
                    w=w, &
                    bound_cond_a="Neumann", &
                    bound_cond_b="Mixed" &
                    , mixing_param_b=1.0_sp &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_sp)) then
      allocate (error)
      return
    endif
    if (any(abs(vl(N, 1:N - 3) + 1.0_sp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_sp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_sp_pp1_w1NeumannMixed_s0_sil0

  subroutine t_SLP_out_c2_sp_pp1_w1NeumannMixed_s0_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Neumann", &
                      bound_cond_b="Mixed" &
                      , mixing_param_b=1.0_sp &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) + 1.0_sp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w1NeumannMixed_s0_sil1

  subroutine t_SLP_out_c2_sp_pp1_w1NeumannMixed_s1_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Neumann", &
                      bound_cond_b="Mixed" &
                      , mixing_param_b=1.0_sp &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) + 1.0_sp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w1NeumannMixed_s1_sil0

  subroutine t_SLP_out_c2_sp_pp1_w1NeumannMixed_s1_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Neumann", &
                      bound_cond_b="Mixed" &
                      , mixing_param_b=1.0_sp &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) + 1.0_sp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w1NeumannMixed_s1_sil1

  subroutine t_SLP_out_c2_sp_pp1_w1NeumannFree_s0_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_sp, b=1.0_sp, N=N, &
                    p=p, &
                    pp=pp, &
                    q=q, &
                    w=w, &
                    bound_cond_a="Neumann", &
                    bound_cond_b="Free" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_sp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_sp_pp1_w1NeumannFree_s0_sil0

  subroutine t_SLP_out_c2_sp_pp1_w1NeumannFree_s0_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Neumann", &
                      bound_cond_b="Free" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w1NeumannFree_s0_sil1

  subroutine t_SLP_out_c2_sp_pp1_w1NeumannFree_s1_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Neumann", &
                      bound_cond_b="Free" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w1NeumannFree_s1_sil0

  subroutine t_SLP_out_c2_sp_pp1_w1NeumannFree_s1_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Neumann", &
                      bound_cond_b="Free" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w1NeumannFree_s1_sil1

  subroutine t_SLP_out_c2_sp_pp1_w1NeumannSingular_s0_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_sp, b=1.0_sp, N=N, &
                    p=p, &
                    pp=pp, &
                    q=q, &
                    w=w, &
                    bound_cond_a="Neumann", &
                    bound_cond_b="Singular" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_sp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_sp_pp1_w1NeumannSingular_s0_sil0

  subroutine t_SLP_out_c2_sp_pp1_w1NeumannSingular_s0_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Neumann", &
                      bound_cond_b="Singular" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w1NeumannSingular_s0_sil1

  subroutine t_SLP_out_c2_sp_pp1_w1NeumannSingular_s1_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Neumann", &
                      bound_cond_b="Singular" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w1NeumannSingular_s1_sil0

  subroutine t_SLP_out_c2_sp_pp1_w1NeumannSingular_s1_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Neumann", &
                      bound_cond_b="Singular" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w1NeumannSingular_s1_sil1

  subroutine t_SLP_out_c2_sp_pp1_w1MixedDirichlet_s0_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_sp, b=1.0_sp, N=N, &
                    p=p, &
                    pp=pp, &
                    q=q, &
                    w=w, &
                    bound_cond_a="Mixed", &
                    bound_cond_b="Dirichlet" &
                    , mixing_param_a=1.0_sp &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(N, 1:N - 3)) > tol_sp)) then
      allocate (error)
      return
    endif
    if (any(abs(vl(1, 1:N - 3) - 1.0_sp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_sp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_sp_pp1_w1MixedDirichlet_s0_sil0

  subroutine t_SLP_out_c2_sp_pp1_w1MixedDirichlet_s0_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Mixed", &
                      bound_cond_b="Dirichlet" &
                      , mixing_param_a=1.0_sp &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(1, 1:N - 3) - 1.0_sp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w1MixedDirichlet_s0_sil1

  subroutine t_SLP_out_c2_sp_pp1_w1MixedDirichlet_s1_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Mixed", &
                      bound_cond_b="Dirichlet" &
                      , mixing_param_a=1.0_sp &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(1, 1:N - 3) - 1.0_sp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w1MixedDirichlet_s1_sil0

  subroutine t_SLP_out_c2_sp_pp1_w1MixedDirichlet_s1_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Mixed", &
                      bound_cond_b="Dirichlet" &
                      , mixing_param_a=1.0_sp &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(1, 1:N - 3) - 1.0_sp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w1MixedDirichlet_s1_sil1

  subroutine t_SLP_out_c2_sp_pp1_w1MixedNeumann_s0_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_sp, b=1.0_sp, N=N, &
                    p=p, &
                    pp=pp, &
                    q=q, &
                    w=w, &
                    bound_cond_a="Mixed", &
                    bound_cond_b="Neumann" &
                    , mixing_param_a=1.0_sp &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_sp)) then
      allocate (error)
      return
    endif
    if (any(abs(vl(1, 1:N - 3) - 1.0_sp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_sp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_sp_pp1_w1MixedNeumann_s0_sil0

  subroutine t_SLP_out_c2_sp_pp1_w1MixedNeumann_s0_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Mixed", &
                      bound_cond_b="Neumann" &
                      , mixing_param_a=1.0_sp &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(1, 1:N - 3) - 1.0_sp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w1MixedNeumann_s0_sil1

  subroutine t_SLP_out_c2_sp_pp1_w1MixedNeumann_s1_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Mixed", &
                      bound_cond_b="Neumann" &
                      , mixing_param_a=1.0_sp &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(1, 1:N - 3) - 1.0_sp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w1MixedNeumann_s1_sil0

  subroutine t_SLP_out_c2_sp_pp1_w1MixedNeumann_s1_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Mixed", &
                      bound_cond_b="Neumann" &
                      , mixing_param_a=1.0_sp &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(1, 1:N - 3) - 1.0_sp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w1MixedNeumann_s1_sil1

  subroutine t_SLP_out_c2_sp_pp1_w1MixedMixed_s0_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_sp, b=1.0_sp, N=N, &
                    p=p, &
                    pp=pp, &
                    q=q, &
                    w=w, &
                    bound_cond_a="Mixed", &
                    bound_cond_b="Mixed" &
                    , mixing_param_a=1.0_sp &
                    , mixing_param_b=1.0_sp &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(1, 1:N - 3) - 1.0_sp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_sp)) then
      allocate (error)
      return
    endif
    if (any(abs(vl(N, 1:N - 3) + 1.0_sp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_sp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_sp_pp1_w1MixedMixed_s0_sil0

  subroutine t_SLP_out_c2_sp_pp1_w1MixedMixed_s0_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Mixed", &
                      bound_cond_b="Mixed" &
                      , mixing_param_a=1.0_sp &
                      , mixing_param_b=1.0_sp &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - 1.0_sp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) + 1.0_sp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w1MixedMixed_s0_sil1

  subroutine t_SLP_out_c2_sp_pp1_w1MixedMixed_s1_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Mixed", &
                      bound_cond_b="Mixed" &
                      , mixing_param_a=1.0_sp &
                      , mixing_param_b=1.0_sp &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - 1.0_sp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) + 1.0_sp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w1MixedMixed_s1_sil0

  subroutine t_SLP_out_c2_sp_pp1_w1MixedMixed_s1_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Mixed", &
                      bound_cond_b="Mixed" &
                      , mixing_param_a=1.0_sp &
                      , mixing_param_b=1.0_sp &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - 1.0_sp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) + 1.0_sp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w1MixedMixed_s1_sil1

  subroutine t_SLP_out_c2_sp_pp1_w1MixedFree_s0_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_sp, b=1.0_sp, N=N, &
                    p=p, &
                    pp=pp, &
                    q=q, &
                    w=w, &
                    bound_cond_a="Mixed", &
                    bound_cond_b="Free" &
                    , mixing_param_a=1.0_sp &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(1, 1:N - 3) - 1.0_sp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_sp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_sp_pp1_w1MixedFree_s0_sil0

  subroutine t_SLP_out_c2_sp_pp1_w1MixedFree_s0_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Mixed", &
                      bound_cond_b="Free" &
                      , mixing_param_a=1.0_sp &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - 1.0_sp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w1MixedFree_s0_sil1

  subroutine t_SLP_out_c2_sp_pp1_w1MixedFree_s1_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Mixed", &
                      bound_cond_b="Free" &
                      , mixing_param_a=1.0_sp &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - 1.0_sp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w1MixedFree_s1_sil0

  subroutine t_SLP_out_c2_sp_pp1_w1MixedFree_s1_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Mixed", &
                      bound_cond_b="Free" &
                      , mixing_param_a=1.0_sp &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - 1.0_sp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w1MixedFree_s1_sil1

  subroutine t_SLP_out_c2_sp_pp1_w1MixedSingular_s0_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_sp, b=1.0_sp, N=N, &
                    p=p, &
                    pp=pp, &
                    q=q, &
                    w=w, &
                    bound_cond_a="Mixed", &
                    bound_cond_b="Singular" &
                    , mixing_param_a=1.0_sp &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(1, 1:N - 3) - 1.0_sp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_sp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_sp_pp1_w1MixedSingular_s0_sil0

  subroutine t_SLP_out_c2_sp_pp1_w1MixedSingular_s0_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Mixed", &
                      bound_cond_b="Singular" &
                      , mixing_param_a=1.0_sp &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - 1.0_sp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w1MixedSingular_s0_sil1

  subroutine t_SLP_out_c2_sp_pp1_w1MixedSingular_s1_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Mixed", &
                      bound_cond_b="Singular" &
                      , mixing_param_a=1.0_sp &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - 1.0_sp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w1MixedSingular_s1_sil0

  subroutine t_SLP_out_c2_sp_pp1_w1MixedSingular_s1_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Mixed", &
                      bound_cond_b="Singular" &
                      , mixing_param_a=1.0_sp &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - 1.0_sp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w1MixedSingular_s1_sil1

  subroutine t_SLP_out_c2_sp_pp1_w1FreeDirichlet_s0_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_sp, b=1.0_sp, N=N, &
                    p=p, &
                    pp=pp, &
                    q=q, &
                    w=w, &
                    bound_cond_a="Free", &
                    bound_cond_b="Dirichlet" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(N, 1:N - 3)) > tol_sp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_sp_pp1_w1FreeDirichlet_s0_sil0

  subroutine t_SLP_out_c2_sp_pp1_w1FreeDirichlet_s0_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Free", &
                      bound_cond_b="Dirichlet" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w1FreeDirichlet_s0_sil1

  subroutine t_SLP_out_c2_sp_pp1_w1FreeDirichlet_s1_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Free", &
                      bound_cond_b="Dirichlet" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w1FreeDirichlet_s1_sil0

  subroutine t_SLP_out_c2_sp_pp1_w1FreeDirichlet_s1_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Free", &
                      bound_cond_b="Dirichlet" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w1FreeDirichlet_s1_sil1

  subroutine t_SLP_out_c2_sp_pp1_w1FreeNeumann_s0_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_sp, b=1.0_sp, N=N, &
                    p=p, &
                    pp=pp, &
                    q=q, &
                    w=w, &
                    bound_cond_a="Free", &
                    bound_cond_b="Neumann" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_sp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_sp_pp1_w1FreeNeumann_s0_sil0

  subroutine t_SLP_out_c2_sp_pp1_w1FreeNeumann_s0_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Free", &
                      bound_cond_b="Neumann" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w1FreeNeumann_s0_sil1

  subroutine t_SLP_out_c2_sp_pp1_w1FreeNeumann_s1_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Free", &
                      bound_cond_b="Neumann" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w1FreeNeumann_s1_sil0

  subroutine t_SLP_out_c2_sp_pp1_w1FreeNeumann_s1_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Free", &
                      bound_cond_b="Neumann" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w1FreeNeumann_s1_sil1

  subroutine t_SLP_out_c2_sp_pp1_w1FreeMixed_s0_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_sp, b=1.0_sp, N=N, &
                    p=p, &
                    pp=pp, &
                    q=q, &
                    w=w, &
                    bound_cond_a="Free", &
                    bound_cond_b="Mixed" &
                    , mixing_param_b=1.0_sp &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(N, 1:N - 3) + 1.0_sp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_sp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_sp_pp1_w1FreeMixed_s0_sil0

  subroutine t_SLP_out_c2_sp_pp1_w1FreeMixed_s0_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Free", &
                      bound_cond_b="Mixed" &
                      , mixing_param_b=1.0_sp &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3) + 1.0_sp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w1FreeMixed_s0_sil1

  subroutine t_SLP_out_c2_sp_pp1_w1FreeMixed_s1_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Free", &
                      bound_cond_b="Mixed" &
                      , mixing_param_b=1.0_sp &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3) + 1.0_sp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w1FreeMixed_s1_sil0

  subroutine t_SLP_out_c2_sp_pp1_w1FreeMixed_s1_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Free", &
                      bound_cond_b="Mixed" &
                      , mixing_param_b=1.0_sp &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3) + 1.0_sp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w1FreeMixed_s1_sil1

  subroutine t_SLP_out_c2_sp_pp1_w1FreeFree_s0_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_sp, b=1.0_sp, N=N, &
                    p=p, &
                    pp=pp, &
                    q=q, &
                    w=w, &
                    bound_cond_a="Free", &
                    bound_cond_b="Free" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
  end subroutine t_SLP_out_c2_sp_pp1_w1FreeFree_s0_sil0

  subroutine t_SLP_out_c2_sp_pp1_w1FreeFree_s0_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Free", &
                      bound_cond_b="Free" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w1FreeFree_s0_sil1

  subroutine t_SLP_out_c2_sp_pp1_w1FreeFree_s1_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Free", &
                      bound_cond_b="Free" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w1FreeFree_s1_sil0

  subroutine t_SLP_out_c2_sp_pp1_w1FreeFree_s1_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Free", &
                      bound_cond_b="Free" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w1FreeFree_s1_sil1

  subroutine t_SLP_out_c2_sp_pp1_w1FreeSingular_s0_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_sp, b=1.0_sp, N=N, &
                    p=p, &
                    pp=pp, &
                    q=q, &
                    w=w, &
                    bound_cond_a="Free", &
                    bound_cond_b="Singular" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
  end subroutine t_SLP_out_c2_sp_pp1_w1FreeSingular_s0_sil0

  subroutine t_SLP_out_c2_sp_pp1_w1FreeSingular_s0_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Free", &
                      bound_cond_b="Singular" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w1FreeSingular_s0_sil1

  subroutine t_SLP_out_c2_sp_pp1_w1FreeSingular_s1_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Free", &
                      bound_cond_b="Singular" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w1FreeSingular_s1_sil0

  subroutine t_SLP_out_c2_sp_pp1_w1FreeSingular_s1_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Free", &
                      bound_cond_b="Singular" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w1FreeSingular_s1_sil1

  subroutine t_SLP_out_c2_sp_pp1_w1SingularDirichlet_s0_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_sp, b=1.0_sp, N=N, &
                    p=p, &
                    pp=pp, &
                    q=q, &
                    w=w, &
                    bound_cond_a="Singular", &
                    bound_cond_b="Dirichlet" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(N, 1:N - 3)) > tol_sp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_sp_pp1_w1SingularDirichlet_s0_sil0

  subroutine t_SLP_out_c2_sp_pp1_w1SingularDirichlet_s0_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Singular", &
                      bound_cond_b="Dirichlet" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w1SingularDirichlet_s0_sil1

  subroutine t_SLP_out_c2_sp_pp1_w1SingularDirichlet_s1_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Singular", &
                      bound_cond_b="Dirichlet" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w1SingularDirichlet_s1_sil0

  subroutine t_SLP_out_c2_sp_pp1_w1SingularDirichlet_s1_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Singular", &
                      bound_cond_b="Dirichlet" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w1SingularDirichlet_s1_sil1

  subroutine t_SLP_out_c2_sp_pp1_w1SingularNeumann_s0_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_sp, b=1.0_sp, N=N, &
                    p=p, &
                    pp=pp, &
                    q=q, &
                    w=w, &
                    bound_cond_a="Singular", &
                    bound_cond_b="Neumann" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_sp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_sp_pp1_w1SingularNeumann_s0_sil0

  subroutine t_SLP_out_c2_sp_pp1_w1SingularNeumann_s0_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Singular", &
                      bound_cond_b="Neumann" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w1SingularNeumann_s0_sil1

  subroutine t_SLP_out_c2_sp_pp1_w1SingularNeumann_s1_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Singular", &
                      bound_cond_b="Neumann" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w1SingularNeumann_s1_sil0

  subroutine t_SLP_out_c2_sp_pp1_w1SingularNeumann_s1_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Singular", &
                      bound_cond_b="Neumann" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w1SingularNeumann_s1_sil1

  subroutine t_SLP_out_c2_sp_pp1_w1SingularMixed_s0_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_sp, b=1.0_sp, N=N, &
                    p=p, &
                    pp=pp, &
                    q=q, &
                    w=w, &
                    bound_cond_a="Singular", &
                    bound_cond_b="Mixed" &
                    , mixing_param_b=1.0_sp &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(N, 1:N - 3) + 1.0_sp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_sp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_sp_pp1_w1SingularMixed_s0_sil0

  subroutine t_SLP_out_c2_sp_pp1_w1SingularMixed_s0_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Singular", &
                      bound_cond_b="Mixed" &
                      , mixing_param_b=1.0_sp &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3) + 1.0_sp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w1SingularMixed_s0_sil1

  subroutine t_SLP_out_c2_sp_pp1_w1SingularMixed_s1_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Singular", &
                      bound_cond_b="Mixed" &
                      , mixing_param_b=1.0_sp &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3) + 1.0_sp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w1SingularMixed_s1_sil0

  subroutine t_SLP_out_c2_sp_pp1_w1SingularMixed_s1_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Singular", &
                      bound_cond_b="Mixed" &
                      , mixing_param_b=1.0_sp &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3) + 1.0_sp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w1SingularMixed_s1_sil1

  subroutine t_SLP_out_c2_sp_pp1_w1SingularFree_s0_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_sp, b=1.0_sp, N=N, &
                    p=p, &
                    pp=pp, &
                    q=q, &
                    w=w, &
                    bound_cond_a="Singular", &
                    bound_cond_b="Free" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
  end subroutine t_SLP_out_c2_sp_pp1_w1SingularFree_s0_sil0

  subroutine t_SLP_out_c2_sp_pp1_w1SingularFree_s0_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Singular", &
                      bound_cond_b="Free" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w1SingularFree_s0_sil1

  subroutine t_SLP_out_c2_sp_pp1_w1SingularFree_s1_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Singular", &
                      bound_cond_b="Free" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w1SingularFree_s1_sil0

  subroutine t_SLP_out_c2_sp_pp1_w1SingularFree_s1_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Singular", &
                      bound_cond_b="Free" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w1SingularFree_s1_sil1

  subroutine t_SLP_out_c2_sp_pp1_w1SingularSingular_s0_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_sp, b=1.0_sp, N=N, &
                    p=p, &
                    pp=pp, &
                    q=q, &
                    w=w, &
                    bound_cond_a="Singular", &
                    bound_cond_b="Singular" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
  end subroutine t_SLP_out_c2_sp_pp1_w1SingularSingular_s0_sil0

  subroutine t_SLP_out_c2_sp_pp1_w1SingularSingular_s0_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Singular", &
                      bound_cond_b="Singular" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w1SingularSingular_s0_sil1

  subroutine t_SLP_out_c2_sp_pp1_w1SingularSingular_s1_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Singular", &
                      bound_cond_b="Singular" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w1SingularSingular_s1_sil0

  subroutine t_SLP_out_c2_sp_pp1_w1SingularSingular_s1_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Singular", &
                      bound_cond_b="Singular" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w1SingularSingular_s1_sil1

  subroutine t_SLP_out_c2_dp_pp0_w0DirichletDirichlet_s0_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_dp, b=1.0_dp, N=N, &
                    p=p, &
                    q=q, &
                    bound_cond_a="Dirichlet", &
                    bound_cond_b="Dirichlet" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(1, 1:N - 3)) > tol_dp)) then
      allocate (error)
      return
    endif
    if (any(abs(vl(N, 1:N - 3)) > tol_dp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_dp_pp0_w0DirichletDirichlet_s0_sil0

  subroutine t_SLP_out_c2_dp_pp0_w0DirichletDirichlet_s0_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Dirichlet", &
                      bound_cond_b="Dirichlet" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w0DirichletDirichlet_s0_sil1

  subroutine t_SLP_out_c2_dp_pp0_w0DirichletDirichlet_s1_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Dirichlet", &
                      bound_cond_b="Dirichlet" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w0DirichletDirichlet_s1_sil0

  subroutine t_SLP_out_c2_dp_pp0_w0DirichletDirichlet_s1_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Dirichlet", &
                      bound_cond_b="Dirichlet" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w0DirichletDirichlet_s1_sil1

  subroutine t_SLP_out_c2_dp_pp0_w0DirichletNeumann_s0_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_dp, b=1.0_dp, N=N, &
                    p=p, &
                    q=q, &
                    bound_cond_a="Dirichlet", &
                    bound_cond_b="Neumann" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(1, 1:N - 3)) > tol_dp)) then
      allocate (error)
      return
    endif
    if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_dp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_dp_pp0_w0DirichletNeumann_s0_sil0

  subroutine t_SLP_out_c2_dp_pp0_w0DirichletNeumann_s0_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Dirichlet", &
                      bound_cond_b="Neumann" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w0DirichletNeumann_s0_sil1

  subroutine t_SLP_out_c2_dp_pp0_w0DirichletNeumann_s1_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Dirichlet", &
                      bound_cond_b="Neumann" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w0DirichletNeumann_s1_sil0

  subroutine t_SLP_out_c2_dp_pp0_w0DirichletNeumann_s1_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Dirichlet", &
                      bound_cond_b="Neumann" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w0DirichletNeumann_s1_sil1

  subroutine t_SLP_out_c2_dp_pp0_w0DirichletMixed_s0_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_dp, b=1.0_dp, N=N, &
                    p=p, &
                    q=q, &
                    bound_cond_a="Dirichlet", &
                    bound_cond_b="Mixed" &
                    , mixing_param_b=1.0_dp &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(1, 1:N - 3)) > tol_dp)) then
      allocate (error)
      return
    endif
    if (any(abs(vl(N, 1:N - 3) + 1.0_dp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_dp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_dp_pp0_w0DirichletMixed_s0_sil0

  subroutine t_SLP_out_c2_dp_pp0_w0DirichletMixed_s0_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Dirichlet", &
                      bound_cond_b="Mixed" &
                      , mixing_param_b=1.0_dp &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) + 1.0_dp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w0DirichletMixed_s0_sil1

  subroutine t_SLP_out_c2_dp_pp0_w0DirichletMixed_s1_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Dirichlet", &
                      bound_cond_b="Mixed" &
                      , mixing_param_b=1.0_dp &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) + 1.0_dp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w0DirichletMixed_s1_sil0

  subroutine t_SLP_out_c2_dp_pp0_w0DirichletMixed_s1_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Dirichlet", &
                      bound_cond_b="Mixed" &
                      , mixing_param_b=1.0_dp &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) + 1.0_dp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w0DirichletMixed_s1_sil1

  subroutine t_SLP_out_c2_dp_pp0_w0DirichletFree_s0_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_dp, b=1.0_dp, N=N, &
                    p=p, &
                    q=q, &
                    bound_cond_a="Dirichlet", &
                    bound_cond_b="Free" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(1, 1:N - 3)) > tol_dp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_dp_pp0_w0DirichletFree_s0_sil0

  subroutine t_SLP_out_c2_dp_pp0_w0DirichletFree_s0_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Dirichlet", &
                      bound_cond_b="Free" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w0DirichletFree_s0_sil1

  subroutine t_SLP_out_c2_dp_pp0_w0DirichletFree_s1_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Dirichlet", &
                      bound_cond_b="Free" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w0DirichletFree_s1_sil0

  subroutine t_SLP_out_c2_dp_pp0_w0DirichletFree_s1_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Dirichlet", &
                      bound_cond_b="Free" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w0DirichletFree_s1_sil1

  subroutine t_SLP_out_c2_dp_pp0_w0DirichletSingular_s0_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_dp, b=1.0_dp, N=N, &
                    p=p, &
                    q=q, &
                    bound_cond_a="Dirichlet", &
                    bound_cond_b="Singular" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(1, 1:N - 3)) > tol_dp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_dp_pp0_w0DirichletSingular_s0_sil0

  subroutine t_SLP_out_c2_dp_pp0_w0DirichletSingular_s0_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Dirichlet", &
                      bound_cond_b="Singular" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w0DirichletSingular_s0_sil1

  subroutine t_SLP_out_c2_dp_pp0_w0DirichletSingular_s1_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Dirichlet", &
                      bound_cond_b="Singular" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w0DirichletSingular_s1_sil0

  subroutine t_SLP_out_c2_dp_pp0_w0DirichletSingular_s1_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Dirichlet", &
                      bound_cond_b="Singular" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w0DirichletSingular_s1_sil1

  subroutine t_SLP_out_c2_dp_pp0_w0NeumannDirichlet_s0_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_dp, b=1.0_dp, N=N, &
                    p=p, &
                    q=q, &
                    bound_cond_a="Neumann", &
                    bound_cond_b="Dirichlet" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(N, 1:N - 3)) > tol_dp)) then
      allocate (error)
      return
    endif
    if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_dp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_dp_pp0_w0NeumannDirichlet_s0_sil0

  subroutine t_SLP_out_c2_dp_pp0_w0NeumannDirichlet_s0_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Neumann", &
                      bound_cond_b="Dirichlet" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w0NeumannDirichlet_s0_sil1

  subroutine t_SLP_out_c2_dp_pp0_w0NeumannDirichlet_s1_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Neumann", &
                      bound_cond_b="Dirichlet" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w0NeumannDirichlet_s1_sil0

  subroutine t_SLP_out_c2_dp_pp0_w0NeumannDirichlet_s1_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Neumann", &
                      bound_cond_b="Dirichlet" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w0NeumannDirichlet_s1_sil1

  subroutine t_SLP_out_c2_dp_pp0_w0NeumannNeumann_s0_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_dp, b=1.0_dp, N=N, &
                    p=p, &
                    q=q, &
                    bound_cond_a="Neumann", &
                    bound_cond_b="Neumann" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_dp)) then
      allocate (error)
      return
    endif
    if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_dp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_dp_pp0_w0NeumannNeumann_s0_sil0

  subroutine t_SLP_out_c2_dp_pp0_w0NeumannNeumann_s0_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Neumann", &
                      bound_cond_b="Neumann" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w0NeumannNeumann_s0_sil1

  subroutine t_SLP_out_c2_dp_pp0_w0NeumannNeumann_s1_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Neumann", &
                      bound_cond_b="Neumann" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w0NeumannNeumann_s1_sil0

  subroutine t_SLP_out_c2_dp_pp0_w0NeumannNeumann_s1_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Neumann", &
                      bound_cond_b="Neumann" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w0NeumannNeumann_s1_sil1

  subroutine t_SLP_out_c2_dp_pp0_w0NeumannMixed_s0_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_dp, b=1.0_dp, N=N, &
                    p=p, &
                    q=q, &
                    bound_cond_a="Neumann", &
                    bound_cond_b="Mixed" &
                    , mixing_param_b=1.0_dp &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_dp)) then
      allocate (error)
      return
    endif
    if (any(abs(vl(N, 1:N - 3) + 1.0_dp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_dp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_dp_pp0_w0NeumannMixed_s0_sil0

  subroutine t_SLP_out_c2_dp_pp0_w0NeumannMixed_s0_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Neumann", &
                      bound_cond_b="Mixed" &
                      , mixing_param_b=1.0_dp &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) + 1.0_dp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w0NeumannMixed_s0_sil1

  subroutine t_SLP_out_c2_dp_pp0_w0NeumannMixed_s1_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Neumann", &
                      bound_cond_b="Mixed" &
                      , mixing_param_b=1.0_dp &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) + 1.0_dp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w0NeumannMixed_s1_sil0

  subroutine t_SLP_out_c2_dp_pp0_w0NeumannMixed_s1_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Neumann", &
                      bound_cond_b="Mixed" &
                      , mixing_param_b=1.0_dp &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) + 1.0_dp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w0NeumannMixed_s1_sil1

  subroutine t_SLP_out_c2_dp_pp0_w0NeumannFree_s0_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_dp, b=1.0_dp, N=N, &
                    p=p, &
                    q=q, &
                    bound_cond_a="Neumann", &
                    bound_cond_b="Free" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_dp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_dp_pp0_w0NeumannFree_s0_sil0

  subroutine t_SLP_out_c2_dp_pp0_w0NeumannFree_s0_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Neumann", &
                      bound_cond_b="Free" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w0NeumannFree_s0_sil1

  subroutine t_SLP_out_c2_dp_pp0_w0NeumannFree_s1_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Neumann", &
                      bound_cond_b="Free" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w0NeumannFree_s1_sil0

  subroutine t_SLP_out_c2_dp_pp0_w0NeumannFree_s1_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Neumann", &
                      bound_cond_b="Free" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w0NeumannFree_s1_sil1

  subroutine t_SLP_out_c2_dp_pp0_w0NeumannSingular_s0_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_dp, b=1.0_dp, N=N, &
                    p=p, &
                    q=q, &
                    bound_cond_a="Neumann", &
                    bound_cond_b="Singular" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_dp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_dp_pp0_w0NeumannSingular_s0_sil0

  subroutine t_SLP_out_c2_dp_pp0_w0NeumannSingular_s0_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Neumann", &
                      bound_cond_b="Singular" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w0NeumannSingular_s0_sil1

  subroutine t_SLP_out_c2_dp_pp0_w0NeumannSingular_s1_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Neumann", &
                      bound_cond_b="Singular" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w0NeumannSingular_s1_sil0

  subroutine t_SLP_out_c2_dp_pp0_w0NeumannSingular_s1_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Neumann", &
                      bound_cond_b="Singular" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w0NeumannSingular_s1_sil1

  subroutine t_SLP_out_c2_dp_pp0_w0MixedDirichlet_s0_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_dp, b=1.0_dp, N=N, &
                    p=p, &
                    q=q, &
                    bound_cond_a="Mixed", &
                    bound_cond_b="Dirichlet" &
                    , mixing_param_a=1.0_dp &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(N, 1:N - 3)) > tol_dp)) then
      allocate (error)
      return
    endif
    if (any(abs(vl(1, 1:N - 3) - 1.0_dp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_dp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_dp_pp0_w0MixedDirichlet_s0_sil0

  subroutine t_SLP_out_c2_dp_pp0_w0MixedDirichlet_s0_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Mixed", &
                      bound_cond_b="Dirichlet" &
                      , mixing_param_a=1.0_dp &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(1, 1:N - 3) - 1.0_dp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w0MixedDirichlet_s0_sil1

  subroutine t_SLP_out_c2_dp_pp0_w0MixedDirichlet_s1_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Mixed", &
                      bound_cond_b="Dirichlet" &
                      , mixing_param_a=1.0_dp &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(1, 1:N - 3) - 1.0_dp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w0MixedDirichlet_s1_sil0

  subroutine t_SLP_out_c2_dp_pp0_w0MixedDirichlet_s1_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Mixed", &
                      bound_cond_b="Dirichlet" &
                      , mixing_param_a=1.0_dp &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(1, 1:N - 3) - 1.0_dp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w0MixedDirichlet_s1_sil1

  subroutine t_SLP_out_c2_dp_pp0_w0MixedNeumann_s0_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_dp, b=1.0_dp, N=N, &
                    p=p, &
                    q=q, &
                    bound_cond_a="Mixed", &
                    bound_cond_b="Neumann" &
                    , mixing_param_a=1.0_dp &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_dp)) then
      allocate (error)
      return
    endif
    if (any(abs(vl(1, 1:N - 3) - 1.0_dp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_dp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_dp_pp0_w0MixedNeumann_s0_sil0

  subroutine t_SLP_out_c2_dp_pp0_w0MixedNeumann_s0_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Mixed", &
                      bound_cond_b="Neumann" &
                      , mixing_param_a=1.0_dp &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(1, 1:N - 3) - 1.0_dp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w0MixedNeumann_s0_sil1

  subroutine t_SLP_out_c2_dp_pp0_w0MixedNeumann_s1_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Mixed", &
                      bound_cond_b="Neumann" &
                      , mixing_param_a=1.0_dp &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(1, 1:N - 3) - 1.0_dp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w0MixedNeumann_s1_sil0

  subroutine t_SLP_out_c2_dp_pp0_w0MixedNeumann_s1_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Mixed", &
                      bound_cond_b="Neumann" &
                      , mixing_param_a=1.0_dp &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(1, 1:N - 3) - 1.0_dp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w0MixedNeumann_s1_sil1

  subroutine t_SLP_out_c2_dp_pp0_w0MixedMixed_s0_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_dp, b=1.0_dp, N=N, &
                    p=p, &
                    q=q, &
                    bound_cond_a="Mixed", &
                    bound_cond_b="Mixed" &
                    , mixing_param_a=1.0_dp &
                    , mixing_param_b=1.0_dp &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(1, 1:N - 3) - 1.0_dp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_dp)) then
      allocate (error)
      return
    endif
    if (any(abs(vl(N, 1:N - 3) + 1.0_dp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_dp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_dp_pp0_w0MixedMixed_s0_sil0

  subroutine t_SLP_out_c2_dp_pp0_w0MixedMixed_s0_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Mixed", &
                      bound_cond_b="Mixed" &
                      , mixing_param_a=1.0_dp &
                      , mixing_param_b=1.0_dp &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - 1.0_dp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) + 1.0_dp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w0MixedMixed_s0_sil1

  subroutine t_SLP_out_c2_dp_pp0_w0MixedMixed_s1_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Mixed", &
                      bound_cond_b="Mixed" &
                      , mixing_param_a=1.0_dp &
                      , mixing_param_b=1.0_dp &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - 1.0_dp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) + 1.0_dp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w0MixedMixed_s1_sil0

  subroutine t_SLP_out_c2_dp_pp0_w0MixedMixed_s1_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Mixed", &
                      bound_cond_b="Mixed" &
                      , mixing_param_a=1.0_dp &
                      , mixing_param_b=1.0_dp &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - 1.0_dp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) + 1.0_dp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w0MixedMixed_s1_sil1

  subroutine t_SLP_out_c2_dp_pp0_w0MixedFree_s0_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_dp, b=1.0_dp, N=N, &
                    p=p, &
                    q=q, &
                    bound_cond_a="Mixed", &
                    bound_cond_b="Free" &
                    , mixing_param_a=1.0_dp &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(1, 1:N - 3) - 1.0_dp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_dp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_dp_pp0_w0MixedFree_s0_sil0

  subroutine t_SLP_out_c2_dp_pp0_w0MixedFree_s0_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Mixed", &
                      bound_cond_b="Free" &
                      , mixing_param_a=1.0_dp &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - 1.0_dp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w0MixedFree_s0_sil1

  subroutine t_SLP_out_c2_dp_pp0_w0MixedFree_s1_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Mixed", &
                      bound_cond_b="Free" &
                      , mixing_param_a=1.0_dp &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - 1.0_dp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w0MixedFree_s1_sil0

  subroutine t_SLP_out_c2_dp_pp0_w0MixedFree_s1_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Mixed", &
                      bound_cond_b="Free" &
                      , mixing_param_a=1.0_dp &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - 1.0_dp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w0MixedFree_s1_sil1

  subroutine t_SLP_out_c2_dp_pp0_w0MixedSingular_s0_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_dp, b=1.0_dp, N=N, &
                    p=p, &
                    q=q, &
                    bound_cond_a="Mixed", &
                    bound_cond_b="Singular" &
                    , mixing_param_a=1.0_dp &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(1, 1:N - 3) - 1.0_dp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_dp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_dp_pp0_w0MixedSingular_s0_sil0

  subroutine t_SLP_out_c2_dp_pp0_w0MixedSingular_s0_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Mixed", &
                      bound_cond_b="Singular" &
                      , mixing_param_a=1.0_dp &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - 1.0_dp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w0MixedSingular_s0_sil1

  subroutine t_SLP_out_c2_dp_pp0_w0MixedSingular_s1_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Mixed", &
                      bound_cond_b="Singular" &
                      , mixing_param_a=1.0_dp &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - 1.0_dp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w0MixedSingular_s1_sil0

  subroutine t_SLP_out_c2_dp_pp0_w0MixedSingular_s1_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Mixed", &
                      bound_cond_b="Singular" &
                      , mixing_param_a=1.0_dp &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - 1.0_dp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w0MixedSingular_s1_sil1

  subroutine t_SLP_out_c2_dp_pp0_w0FreeDirichlet_s0_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_dp, b=1.0_dp, N=N, &
                    p=p, &
                    q=q, &
                    bound_cond_a="Free", &
                    bound_cond_b="Dirichlet" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(N, 1:N - 3)) > tol_dp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_dp_pp0_w0FreeDirichlet_s0_sil0

  subroutine t_SLP_out_c2_dp_pp0_w0FreeDirichlet_s0_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Free", &
                      bound_cond_b="Dirichlet" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w0FreeDirichlet_s0_sil1

  subroutine t_SLP_out_c2_dp_pp0_w0FreeDirichlet_s1_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Free", &
                      bound_cond_b="Dirichlet" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w0FreeDirichlet_s1_sil0

  subroutine t_SLP_out_c2_dp_pp0_w0FreeDirichlet_s1_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Free", &
                      bound_cond_b="Dirichlet" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w0FreeDirichlet_s1_sil1

  subroutine t_SLP_out_c2_dp_pp0_w0FreeNeumann_s0_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_dp, b=1.0_dp, N=N, &
                    p=p, &
                    q=q, &
                    bound_cond_a="Free", &
                    bound_cond_b="Neumann" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_dp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_dp_pp0_w0FreeNeumann_s0_sil0

  subroutine t_SLP_out_c2_dp_pp0_w0FreeNeumann_s0_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Free", &
                      bound_cond_b="Neumann" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w0FreeNeumann_s0_sil1

  subroutine t_SLP_out_c2_dp_pp0_w0FreeNeumann_s1_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Free", &
                      bound_cond_b="Neumann" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w0FreeNeumann_s1_sil0

  subroutine t_SLP_out_c2_dp_pp0_w0FreeNeumann_s1_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Free", &
                      bound_cond_b="Neumann" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w0FreeNeumann_s1_sil1

  subroutine t_SLP_out_c2_dp_pp0_w0FreeMixed_s0_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_dp, b=1.0_dp, N=N, &
                    p=p, &
                    q=q, &
                    bound_cond_a="Free", &
                    bound_cond_b="Mixed" &
                    , mixing_param_b=1.0_dp &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(N, 1:N - 3) + 1.0_dp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_dp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_dp_pp0_w0FreeMixed_s0_sil0

  subroutine t_SLP_out_c2_dp_pp0_w0FreeMixed_s0_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Free", &
                      bound_cond_b="Mixed" &
                      , mixing_param_b=1.0_dp &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3) + 1.0_dp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w0FreeMixed_s0_sil1

  subroutine t_SLP_out_c2_dp_pp0_w0FreeMixed_s1_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Free", &
                      bound_cond_b="Mixed" &
                      , mixing_param_b=1.0_dp &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3) + 1.0_dp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w0FreeMixed_s1_sil0

  subroutine t_SLP_out_c2_dp_pp0_w0FreeMixed_s1_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Free", &
                      bound_cond_b="Mixed" &
                      , mixing_param_b=1.0_dp &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3) + 1.0_dp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w0FreeMixed_s1_sil1

  subroutine t_SLP_out_c2_dp_pp0_w0FreeFree_s0_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_dp, b=1.0_dp, N=N, &
                    p=p, &
                    q=q, &
                    bound_cond_a="Free", &
                    bound_cond_b="Free" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
  end subroutine t_SLP_out_c2_dp_pp0_w0FreeFree_s0_sil0

  subroutine t_SLP_out_c2_dp_pp0_w0FreeFree_s0_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Free", &
                      bound_cond_b="Free" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w0FreeFree_s0_sil1

  subroutine t_SLP_out_c2_dp_pp0_w0FreeFree_s1_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Free", &
                      bound_cond_b="Free" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w0FreeFree_s1_sil0

  subroutine t_SLP_out_c2_dp_pp0_w0FreeFree_s1_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Free", &
                      bound_cond_b="Free" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w0FreeFree_s1_sil1

  subroutine t_SLP_out_c2_dp_pp0_w0FreeSingular_s0_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_dp, b=1.0_dp, N=N, &
                    p=p, &
                    q=q, &
                    bound_cond_a="Free", &
                    bound_cond_b="Singular" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
  end subroutine t_SLP_out_c2_dp_pp0_w0FreeSingular_s0_sil0

  subroutine t_SLP_out_c2_dp_pp0_w0FreeSingular_s0_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Free", &
                      bound_cond_b="Singular" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w0FreeSingular_s0_sil1

  subroutine t_SLP_out_c2_dp_pp0_w0FreeSingular_s1_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Free", &
                      bound_cond_b="Singular" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w0FreeSingular_s1_sil0

  subroutine t_SLP_out_c2_dp_pp0_w0FreeSingular_s1_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Free", &
                      bound_cond_b="Singular" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w0FreeSingular_s1_sil1

  subroutine t_SLP_out_c2_dp_pp0_w0SingularDirichlet_s0_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_dp, b=1.0_dp, N=N, &
                    p=p, &
                    q=q, &
                    bound_cond_a="Singular", &
                    bound_cond_b="Dirichlet" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(N, 1:N - 3)) > tol_dp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_dp_pp0_w0SingularDirichlet_s0_sil0

  subroutine t_SLP_out_c2_dp_pp0_w0SingularDirichlet_s0_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Singular", &
                      bound_cond_b="Dirichlet" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w0SingularDirichlet_s0_sil1

  subroutine t_SLP_out_c2_dp_pp0_w0SingularDirichlet_s1_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Singular", &
                      bound_cond_b="Dirichlet" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w0SingularDirichlet_s1_sil0

  subroutine t_SLP_out_c2_dp_pp0_w0SingularDirichlet_s1_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Singular", &
                      bound_cond_b="Dirichlet" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w0SingularDirichlet_s1_sil1

  subroutine t_SLP_out_c2_dp_pp0_w0SingularNeumann_s0_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_dp, b=1.0_dp, N=N, &
                    p=p, &
                    q=q, &
                    bound_cond_a="Singular", &
                    bound_cond_b="Neumann" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_dp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_dp_pp0_w0SingularNeumann_s0_sil0

  subroutine t_SLP_out_c2_dp_pp0_w0SingularNeumann_s0_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Singular", &
                      bound_cond_b="Neumann" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w0SingularNeumann_s0_sil1

  subroutine t_SLP_out_c2_dp_pp0_w0SingularNeumann_s1_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Singular", &
                      bound_cond_b="Neumann" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w0SingularNeumann_s1_sil0

  subroutine t_SLP_out_c2_dp_pp0_w0SingularNeumann_s1_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Singular", &
                      bound_cond_b="Neumann" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w0SingularNeumann_s1_sil1

  subroutine t_SLP_out_c2_dp_pp0_w0SingularMixed_s0_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_dp, b=1.0_dp, N=N, &
                    p=p, &
                    q=q, &
                    bound_cond_a="Singular", &
                    bound_cond_b="Mixed" &
                    , mixing_param_b=1.0_dp &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(N, 1:N - 3) + 1.0_dp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_dp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_dp_pp0_w0SingularMixed_s0_sil0

  subroutine t_SLP_out_c2_dp_pp0_w0SingularMixed_s0_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Singular", &
                      bound_cond_b="Mixed" &
                      , mixing_param_b=1.0_dp &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3) + 1.0_dp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w0SingularMixed_s0_sil1

  subroutine t_SLP_out_c2_dp_pp0_w0SingularMixed_s1_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Singular", &
                      bound_cond_b="Mixed" &
                      , mixing_param_b=1.0_dp &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3) + 1.0_dp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w0SingularMixed_s1_sil0

  subroutine t_SLP_out_c2_dp_pp0_w0SingularMixed_s1_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Singular", &
                      bound_cond_b="Mixed" &
                      , mixing_param_b=1.0_dp &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3) + 1.0_dp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w0SingularMixed_s1_sil1

  subroutine t_SLP_out_c2_dp_pp0_w0SingularFree_s0_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_dp, b=1.0_dp, N=N, &
                    p=p, &
                    q=q, &
                    bound_cond_a="Singular", &
                    bound_cond_b="Free" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
  end subroutine t_SLP_out_c2_dp_pp0_w0SingularFree_s0_sil0

  subroutine t_SLP_out_c2_dp_pp0_w0SingularFree_s0_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Singular", &
                      bound_cond_b="Free" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w0SingularFree_s0_sil1

  subroutine t_SLP_out_c2_dp_pp0_w0SingularFree_s1_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Singular", &
                      bound_cond_b="Free" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w0SingularFree_s1_sil0

  subroutine t_SLP_out_c2_dp_pp0_w0SingularFree_s1_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Singular", &
                      bound_cond_b="Free" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w0SingularFree_s1_sil1

  subroutine t_SLP_out_c2_dp_pp0_w0SingularSingular_s0_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_dp, b=1.0_dp, N=N, &
                    p=p, &
                    q=q, &
                    bound_cond_a="Singular", &
                    bound_cond_b="Singular" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
  end subroutine t_SLP_out_c2_dp_pp0_w0SingularSingular_s0_sil0

  subroutine t_SLP_out_c2_dp_pp0_w0SingularSingular_s0_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Singular", &
                      bound_cond_b="Singular" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w0SingularSingular_s0_sil1

  subroutine t_SLP_out_c2_dp_pp0_w0SingularSingular_s1_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Singular", &
                      bound_cond_b="Singular" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w0SingularSingular_s1_sil0

  subroutine t_SLP_out_c2_dp_pp0_w0SingularSingular_s1_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Singular", &
                      bound_cond_b="Singular" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w0SingularSingular_s1_sil1

  subroutine t_SLP_out_c2_dp_pp0_w1DirichletDirichlet_s0_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_dp, b=1.0_dp, N=N, &
                    p=p, &
                    q=q, &
                    w=w, &
                    bound_cond_a="Dirichlet", &
                    bound_cond_b="Dirichlet" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(1, 1:N - 3)) > tol_dp)) then
      allocate (error)
      return
    endif
    if (any(abs(vl(N, 1:N - 3)) > tol_dp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_dp_pp0_w1DirichletDirichlet_s0_sil0

  subroutine t_SLP_out_c2_dp_pp0_w1DirichletDirichlet_s0_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Dirichlet", &
                      bound_cond_b="Dirichlet" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w1DirichletDirichlet_s0_sil1

  subroutine t_SLP_out_c2_dp_pp0_w1DirichletDirichlet_s1_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Dirichlet", &
                      bound_cond_b="Dirichlet" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w1DirichletDirichlet_s1_sil0

  subroutine t_SLP_out_c2_dp_pp0_w1DirichletDirichlet_s1_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Dirichlet", &
                      bound_cond_b="Dirichlet" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w1DirichletDirichlet_s1_sil1

  subroutine t_SLP_out_c2_dp_pp0_w1DirichletNeumann_s0_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_dp, b=1.0_dp, N=N, &
                    p=p, &
                    q=q, &
                    w=w, &
                    bound_cond_a="Dirichlet", &
                    bound_cond_b="Neumann" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(1, 1:N - 3)) > tol_dp)) then
      allocate (error)
      return
    endif
    if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_dp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_dp_pp0_w1DirichletNeumann_s0_sil0

  subroutine t_SLP_out_c2_dp_pp0_w1DirichletNeumann_s0_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Dirichlet", &
                      bound_cond_b="Neumann" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w1DirichletNeumann_s0_sil1

  subroutine t_SLP_out_c2_dp_pp0_w1DirichletNeumann_s1_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Dirichlet", &
                      bound_cond_b="Neumann" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w1DirichletNeumann_s1_sil0

  subroutine t_SLP_out_c2_dp_pp0_w1DirichletNeumann_s1_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Dirichlet", &
                      bound_cond_b="Neumann" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w1DirichletNeumann_s1_sil1

  subroutine t_SLP_out_c2_dp_pp0_w1DirichletMixed_s0_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_dp, b=1.0_dp, N=N, &
                    p=p, &
                    q=q, &
                    w=w, &
                    bound_cond_a="Dirichlet", &
                    bound_cond_b="Mixed" &
                    , mixing_param_b=1.0_dp &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(1, 1:N - 3)) > tol_dp)) then
      allocate (error)
      return
    endif
    if (any(abs(vl(N, 1:N - 3) + 1.0_dp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_dp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_dp_pp0_w1DirichletMixed_s0_sil0

  subroutine t_SLP_out_c2_dp_pp0_w1DirichletMixed_s0_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Dirichlet", &
                      bound_cond_b="Mixed" &
                      , mixing_param_b=1.0_dp &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) + 1.0_dp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w1DirichletMixed_s0_sil1

  subroutine t_SLP_out_c2_dp_pp0_w1DirichletMixed_s1_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Dirichlet", &
                      bound_cond_b="Mixed" &
                      , mixing_param_b=1.0_dp &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) + 1.0_dp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w1DirichletMixed_s1_sil0

  subroutine t_SLP_out_c2_dp_pp0_w1DirichletMixed_s1_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Dirichlet", &
                      bound_cond_b="Mixed" &
                      , mixing_param_b=1.0_dp &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) + 1.0_dp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w1DirichletMixed_s1_sil1

  subroutine t_SLP_out_c2_dp_pp0_w1DirichletFree_s0_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_dp, b=1.0_dp, N=N, &
                    p=p, &
                    q=q, &
                    w=w, &
                    bound_cond_a="Dirichlet", &
                    bound_cond_b="Free" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(1, 1:N - 3)) > tol_dp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_dp_pp0_w1DirichletFree_s0_sil0

  subroutine t_SLP_out_c2_dp_pp0_w1DirichletFree_s0_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Dirichlet", &
                      bound_cond_b="Free" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w1DirichletFree_s0_sil1

  subroutine t_SLP_out_c2_dp_pp0_w1DirichletFree_s1_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Dirichlet", &
                      bound_cond_b="Free" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w1DirichletFree_s1_sil0

  subroutine t_SLP_out_c2_dp_pp0_w1DirichletFree_s1_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Dirichlet", &
                      bound_cond_b="Free" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w1DirichletFree_s1_sil1

  subroutine t_SLP_out_c2_dp_pp0_w1DirichletSingular_s0_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_dp, b=1.0_dp, N=N, &
                    p=p, &
                    q=q, &
                    w=w, &
                    bound_cond_a="Dirichlet", &
                    bound_cond_b="Singular" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(1, 1:N - 3)) > tol_dp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_dp_pp0_w1DirichletSingular_s0_sil0

  subroutine t_SLP_out_c2_dp_pp0_w1DirichletSingular_s0_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Dirichlet", &
                      bound_cond_b="Singular" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w1DirichletSingular_s0_sil1

  subroutine t_SLP_out_c2_dp_pp0_w1DirichletSingular_s1_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Dirichlet", &
                      bound_cond_b="Singular" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w1DirichletSingular_s1_sil0

  subroutine t_SLP_out_c2_dp_pp0_w1DirichletSingular_s1_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Dirichlet", &
                      bound_cond_b="Singular" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w1DirichletSingular_s1_sil1

  subroutine t_SLP_out_c2_dp_pp0_w1NeumannDirichlet_s0_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_dp, b=1.0_dp, N=N, &
                    p=p, &
                    q=q, &
                    w=w, &
                    bound_cond_a="Neumann", &
                    bound_cond_b="Dirichlet" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(N, 1:N - 3)) > tol_dp)) then
      allocate (error)
      return
    endif
    if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_dp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_dp_pp0_w1NeumannDirichlet_s0_sil0

  subroutine t_SLP_out_c2_dp_pp0_w1NeumannDirichlet_s0_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Neumann", &
                      bound_cond_b="Dirichlet" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w1NeumannDirichlet_s0_sil1

  subroutine t_SLP_out_c2_dp_pp0_w1NeumannDirichlet_s1_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Neumann", &
                      bound_cond_b="Dirichlet" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w1NeumannDirichlet_s1_sil0

  subroutine t_SLP_out_c2_dp_pp0_w1NeumannDirichlet_s1_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Neumann", &
                      bound_cond_b="Dirichlet" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w1NeumannDirichlet_s1_sil1

  subroutine t_SLP_out_c2_dp_pp0_w1NeumannNeumann_s0_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_dp, b=1.0_dp, N=N, &
                    p=p, &
                    q=q, &
                    w=w, &
                    bound_cond_a="Neumann", &
                    bound_cond_b="Neumann" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_dp)) then
      allocate (error)
      return
    endif
    if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_dp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_dp_pp0_w1NeumannNeumann_s0_sil0

  subroutine t_SLP_out_c2_dp_pp0_w1NeumannNeumann_s0_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Neumann", &
                      bound_cond_b="Neumann" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w1NeumannNeumann_s0_sil1

  subroutine t_SLP_out_c2_dp_pp0_w1NeumannNeumann_s1_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Neumann", &
                      bound_cond_b="Neumann" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w1NeumannNeumann_s1_sil0

  subroutine t_SLP_out_c2_dp_pp0_w1NeumannNeumann_s1_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Neumann", &
                      bound_cond_b="Neumann" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w1NeumannNeumann_s1_sil1

  subroutine t_SLP_out_c2_dp_pp0_w1NeumannMixed_s0_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_dp, b=1.0_dp, N=N, &
                    p=p, &
                    q=q, &
                    w=w, &
                    bound_cond_a="Neumann", &
                    bound_cond_b="Mixed" &
                    , mixing_param_b=1.0_dp &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_dp)) then
      allocate (error)
      return
    endif
    if (any(abs(vl(N, 1:N - 3) + 1.0_dp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_dp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_dp_pp0_w1NeumannMixed_s0_sil0

  subroutine t_SLP_out_c2_dp_pp0_w1NeumannMixed_s0_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Neumann", &
                      bound_cond_b="Mixed" &
                      , mixing_param_b=1.0_dp &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) + 1.0_dp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w1NeumannMixed_s0_sil1

  subroutine t_SLP_out_c2_dp_pp0_w1NeumannMixed_s1_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Neumann", &
                      bound_cond_b="Mixed" &
                      , mixing_param_b=1.0_dp &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) + 1.0_dp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w1NeumannMixed_s1_sil0

  subroutine t_SLP_out_c2_dp_pp0_w1NeumannMixed_s1_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Neumann", &
                      bound_cond_b="Mixed" &
                      , mixing_param_b=1.0_dp &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) + 1.0_dp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w1NeumannMixed_s1_sil1

  subroutine t_SLP_out_c2_dp_pp0_w1NeumannFree_s0_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_dp, b=1.0_dp, N=N, &
                    p=p, &
                    q=q, &
                    w=w, &
                    bound_cond_a="Neumann", &
                    bound_cond_b="Free" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_dp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_dp_pp0_w1NeumannFree_s0_sil0

  subroutine t_SLP_out_c2_dp_pp0_w1NeumannFree_s0_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Neumann", &
                      bound_cond_b="Free" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w1NeumannFree_s0_sil1

  subroutine t_SLP_out_c2_dp_pp0_w1NeumannFree_s1_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Neumann", &
                      bound_cond_b="Free" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w1NeumannFree_s1_sil0

  subroutine t_SLP_out_c2_dp_pp0_w1NeumannFree_s1_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Neumann", &
                      bound_cond_b="Free" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w1NeumannFree_s1_sil1

  subroutine t_SLP_out_c2_dp_pp0_w1NeumannSingular_s0_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_dp, b=1.0_dp, N=N, &
                    p=p, &
                    q=q, &
                    w=w, &
                    bound_cond_a="Neumann", &
                    bound_cond_b="Singular" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_dp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_dp_pp0_w1NeumannSingular_s0_sil0

  subroutine t_SLP_out_c2_dp_pp0_w1NeumannSingular_s0_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Neumann", &
                      bound_cond_b="Singular" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w1NeumannSingular_s0_sil1

  subroutine t_SLP_out_c2_dp_pp0_w1NeumannSingular_s1_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Neumann", &
                      bound_cond_b="Singular" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w1NeumannSingular_s1_sil0

  subroutine t_SLP_out_c2_dp_pp0_w1NeumannSingular_s1_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Neumann", &
                      bound_cond_b="Singular" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w1NeumannSingular_s1_sil1

  subroutine t_SLP_out_c2_dp_pp0_w1MixedDirichlet_s0_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_dp, b=1.0_dp, N=N, &
                    p=p, &
                    q=q, &
                    w=w, &
                    bound_cond_a="Mixed", &
                    bound_cond_b="Dirichlet" &
                    , mixing_param_a=1.0_dp &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(N, 1:N - 3)) > tol_dp)) then
      allocate (error)
      return
    endif
    if (any(abs(vl(1, 1:N - 3) - 1.0_dp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_dp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_dp_pp0_w1MixedDirichlet_s0_sil0

  subroutine t_SLP_out_c2_dp_pp0_w1MixedDirichlet_s0_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Mixed", &
                      bound_cond_b="Dirichlet" &
                      , mixing_param_a=1.0_dp &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(1, 1:N - 3) - 1.0_dp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w1MixedDirichlet_s0_sil1

  subroutine t_SLP_out_c2_dp_pp0_w1MixedDirichlet_s1_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Mixed", &
                      bound_cond_b="Dirichlet" &
                      , mixing_param_a=1.0_dp &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(1, 1:N - 3) - 1.0_dp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w1MixedDirichlet_s1_sil0

  subroutine t_SLP_out_c2_dp_pp0_w1MixedDirichlet_s1_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Mixed", &
                      bound_cond_b="Dirichlet" &
                      , mixing_param_a=1.0_dp &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(1, 1:N - 3) - 1.0_dp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w1MixedDirichlet_s1_sil1

  subroutine t_SLP_out_c2_dp_pp0_w1MixedNeumann_s0_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_dp, b=1.0_dp, N=N, &
                    p=p, &
                    q=q, &
                    w=w, &
                    bound_cond_a="Mixed", &
                    bound_cond_b="Neumann" &
                    , mixing_param_a=1.0_dp &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_dp)) then
      allocate (error)
      return
    endif
    if (any(abs(vl(1, 1:N - 3) - 1.0_dp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_dp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_dp_pp0_w1MixedNeumann_s0_sil0

  subroutine t_SLP_out_c2_dp_pp0_w1MixedNeumann_s0_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Mixed", &
                      bound_cond_b="Neumann" &
                      , mixing_param_a=1.0_dp &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(1, 1:N - 3) - 1.0_dp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w1MixedNeumann_s0_sil1

  subroutine t_SLP_out_c2_dp_pp0_w1MixedNeumann_s1_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Mixed", &
                      bound_cond_b="Neumann" &
                      , mixing_param_a=1.0_dp &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(1, 1:N - 3) - 1.0_dp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w1MixedNeumann_s1_sil0

  subroutine t_SLP_out_c2_dp_pp0_w1MixedNeumann_s1_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Mixed", &
                      bound_cond_b="Neumann" &
                      , mixing_param_a=1.0_dp &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(1, 1:N - 3) - 1.0_dp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w1MixedNeumann_s1_sil1

  subroutine t_SLP_out_c2_dp_pp0_w1MixedMixed_s0_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_dp, b=1.0_dp, N=N, &
                    p=p, &
                    q=q, &
                    w=w, &
                    bound_cond_a="Mixed", &
                    bound_cond_b="Mixed" &
                    , mixing_param_a=1.0_dp &
                    , mixing_param_b=1.0_dp &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(1, 1:N - 3) - 1.0_dp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_dp)) then
      allocate (error)
      return
    endif
    if (any(abs(vl(N, 1:N - 3) + 1.0_dp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_dp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_dp_pp0_w1MixedMixed_s0_sil0

  subroutine t_SLP_out_c2_dp_pp0_w1MixedMixed_s0_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Mixed", &
                      bound_cond_b="Mixed" &
                      , mixing_param_a=1.0_dp &
                      , mixing_param_b=1.0_dp &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - 1.0_dp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) + 1.0_dp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w1MixedMixed_s0_sil1

  subroutine t_SLP_out_c2_dp_pp0_w1MixedMixed_s1_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Mixed", &
                      bound_cond_b="Mixed" &
                      , mixing_param_a=1.0_dp &
                      , mixing_param_b=1.0_dp &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - 1.0_dp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) + 1.0_dp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w1MixedMixed_s1_sil0

  subroutine t_SLP_out_c2_dp_pp0_w1MixedMixed_s1_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Mixed", &
                      bound_cond_b="Mixed" &
                      , mixing_param_a=1.0_dp &
                      , mixing_param_b=1.0_dp &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - 1.0_dp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) + 1.0_dp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w1MixedMixed_s1_sil1

  subroutine t_SLP_out_c2_dp_pp0_w1MixedFree_s0_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_dp, b=1.0_dp, N=N, &
                    p=p, &
                    q=q, &
                    w=w, &
                    bound_cond_a="Mixed", &
                    bound_cond_b="Free" &
                    , mixing_param_a=1.0_dp &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(1, 1:N - 3) - 1.0_dp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_dp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_dp_pp0_w1MixedFree_s0_sil0

  subroutine t_SLP_out_c2_dp_pp0_w1MixedFree_s0_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Mixed", &
                      bound_cond_b="Free" &
                      , mixing_param_a=1.0_dp &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - 1.0_dp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w1MixedFree_s0_sil1

  subroutine t_SLP_out_c2_dp_pp0_w1MixedFree_s1_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Mixed", &
                      bound_cond_b="Free" &
                      , mixing_param_a=1.0_dp &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - 1.0_dp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w1MixedFree_s1_sil0

  subroutine t_SLP_out_c2_dp_pp0_w1MixedFree_s1_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Mixed", &
                      bound_cond_b="Free" &
                      , mixing_param_a=1.0_dp &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - 1.0_dp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w1MixedFree_s1_sil1

  subroutine t_SLP_out_c2_dp_pp0_w1MixedSingular_s0_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_dp, b=1.0_dp, N=N, &
                    p=p, &
                    q=q, &
                    w=w, &
                    bound_cond_a="Mixed", &
                    bound_cond_b="Singular" &
                    , mixing_param_a=1.0_dp &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(1, 1:N - 3) - 1.0_dp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_dp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_dp_pp0_w1MixedSingular_s0_sil0

  subroutine t_SLP_out_c2_dp_pp0_w1MixedSingular_s0_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Mixed", &
                      bound_cond_b="Singular" &
                      , mixing_param_a=1.0_dp &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - 1.0_dp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w1MixedSingular_s0_sil1

  subroutine t_SLP_out_c2_dp_pp0_w1MixedSingular_s1_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Mixed", &
                      bound_cond_b="Singular" &
                      , mixing_param_a=1.0_dp &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - 1.0_dp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w1MixedSingular_s1_sil0

  subroutine t_SLP_out_c2_dp_pp0_w1MixedSingular_s1_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Mixed", &
                      bound_cond_b="Singular" &
                      , mixing_param_a=1.0_dp &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - 1.0_dp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w1MixedSingular_s1_sil1

  subroutine t_SLP_out_c2_dp_pp0_w1FreeDirichlet_s0_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_dp, b=1.0_dp, N=N, &
                    p=p, &
                    q=q, &
                    w=w, &
                    bound_cond_a="Free", &
                    bound_cond_b="Dirichlet" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(N, 1:N - 3)) > tol_dp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_dp_pp0_w1FreeDirichlet_s0_sil0

  subroutine t_SLP_out_c2_dp_pp0_w1FreeDirichlet_s0_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Free", &
                      bound_cond_b="Dirichlet" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w1FreeDirichlet_s0_sil1

  subroutine t_SLP_out_c2_dp_pp0_w1FreeDirichlet_s1_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Free", &
                      bound_cond_b="Dirichlet" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w1FreeDirichlet_s1_sil0

  subroutine t_SLP_out_c2_dp_pp0_w1FreeDirichlet_s1_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Free", &
                      bound_cond_b="Dirichlet" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w1FreeDirichlet_s1_sil1

  subroutine t_SLP_out_c2_dp_pp0_w1FreeNeumann_s0_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_dp, b=1.0_dp, N=N, &
                    p=p, &
                    q=q, &
                    w=w, &
                    bound_cond_a="Free", &
                    bound_cond_b="Neumann" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_dp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_dp_pp0_w1FreeNeumann_s0_sil0

  subroutine t_SLP_out_c2_dp_pp0_w1FreeNeumann_s0_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Free", &
                      bound_cond_b="Neumann" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w1FreeNeumann_s0_sil1

  subroutine t_SLP_out_c2_dp_pp0_w1FreeNeumann_s1_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Free", &
                      bound_cond_b="Neumann" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w1FreeNeumann_s1_sil0

  subroutine t_SLP_out_c2_dp_pp0_w1FreeNeumann_s1_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Free", &
                      bound_cond_b="Neumann" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w1FreeNeumann_s1_sil1

  subroutine t_SLP_out_c2_dp_pp0_w1FreeMixed_s0_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_dp, b=1.0_dp, N=N, &
                    p=p, &
                    q=q, &
                    w=w, &
                    bound_cond_a="Free", &
                    bound_cond_b="Mixed" &
                    , mixing_param_b=1.0_dp &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(N, 1:N - 3) + 1.0_dp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_dp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_dp_pp0_w1FreeMixed_s0_sil0

  subroutine t_SLP_out_c2_dp_pp0_w1FreeMixed_s0_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Free", &
                      bound_cond_b="Mixed" &
                      , mixing_param_b=1.0_dp &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3) + 1.0_dp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w1FreeMixed_s0_sil1

  subroutine t_SLP_out_c2_dp_pp0_w1FreeMixed_s1_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Free", &
                      bound_cond_b="Mixed" &
                      , mixing_param_b=1.0_dp &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3) + 1.0_dp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w1FreeMixed_s1_sil0

  subroutine t_SLP_out_c2_dp_pp0_w1FreeMixed_s1_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Free", &
                      bound_cond_b="Mixed" &
                      , mixing_param_b=1.0_dp &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3) + 1.0_dp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w1FreeMixed_s1_sil1

  subroutine t_SLP_out_c2_dp_pp0_w1FreeFree_s0_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_dp, b=1.0_dp, N=N, &
                    p=p, &
                    q=q, &
                    w=w, &
                    bound_cond_a="Free", &
                    bound_cond_b="Free" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
  end subroutine t_SLP_out_c2_dp_pp0_w1FreeFree_s0_sil0

  subroutine t_SLP_out_c2_dp_pp0_w1FreeFree_s0_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Free", &
                      bound_cond_b="Free" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w1FreeFree_s0_sil1

  subroutine t_SLP_out_c2_dp_pp0_w1FreeFree_s1_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Free", &
                      bound_cond_b="Free" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w1FreeFree_s1_sil0

  subroutine t_SLP_out_c2_dp_pp0_w1FreeFree_s1_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Free", &
                      bound_cond_b="Free" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w1FreeFree_s1_sil1

  subroutine t_SLP_out_c2_dp_pp0_w1FreeSingular_s0_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_dp, b=1.0_dp, N=N, &
                    p=p, &
                    q=q, &
                    w=w, &
                    bound_cond_a="Free", &
                    bound_cond_b="Singular" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
  end subroutine t_SLP_out_c2_dp_pp0_w1FreeSingular_s0_sil0

  subroutine t_SLP_out_c2_dp_pp0_w1FreeSingular_s0_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Free", &
                      bound_cond_b="Singular" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w1FreeSingular_s0_sil1

  subroutine t_SLP_out_c2_dp_pp0_w1FreeSingular_s1_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Free", &
                      bound_cond_b="Singular" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w1FreeSingular_s1_sil0

  subroutine t_SLP_out_c2_dp_pp0_w1FreeSingular_s1_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Free", &
                      bound_cond_b="Singular" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w1FreeSingular_s1_sil1

  subroutine t_SLP_out_c2_dp_pp0_w1SingularDirichlet_s0_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_dp, b=1.0_dp, N=N, &
                    p=p, &
                    q=q, &
                    w=w, &
                    bound_cond_a="Singular", &
                    bound_cond_b="Dirichlet" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(N, 1:N - 3)) > tol_dp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_dp_pp0_w1SingularDirichlet_s0_sil0

  subroutine t_SLP_out_c2_dp_pp0_w1SingularDirichlet_s0_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Singular", &
                      bound_cond_b="Dirichlet" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w1SingularDirichlet_s0_sil1

  subroutine t_SLP_out_c2_dp_pp0_w1SingularDirichlet_s1_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Singular", &
                      bound_cond_b="Dirichlet" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w1SingularDirichlet_s1_sil0

  subroutine t_SLP_out_c2_dp_pp0_w1SingularDirichlet_s1_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Singular", &
                      bound_cond_b="Dirichlet" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w1SingularDirichlet_s1_sil1

  subroutine t_SLP_out_c2_dp_pp0_w1SingularNeumann_s0_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_dp, b=1.0_dp, N=N, &
                    p=p, &
                    q=q, &
                    w=w, &
                    bound_cond_a="Singular", &
                    bound_cond_b="Neumann" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_dp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_dp_pp0_w1SingularNeumann_s0_sil0

  subroutine t_SLP_out_c2_dp_pp0_w1SingularNeumann_s0_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Singular", &
                      bound_cond_b="Neumann" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w1SingularNeumann_s0_sil1

  subroutine t_SLP_out_c2_dp_pp0_w1SingularNeumann_s1_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Singular", &
                      bound_cond_b="Neumann" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w1SingularNeumann_s1_sil0

  subroutine t_SLP_out_c2_dp_pp0_w1SingularNeumann_s1_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Singular", &
                      bound_cond_b="Neumann" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w1SingularNeumann_s1_sil1

  subroutine t_SLP_out_c2_dp_pp0_w1SingularMixed_s0_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_dp, b=1.0_dp, N=N, &
                    p=p, &
                    q=q, &
                    w=w, &
                    bound_cond_a="Singular", &
                    bound_cond_b="Mixed" &
                    , mixing_param_b=1.0_dp &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(N, 1:N - 3) + 1.0_dp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_dp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_dp_pp0_w1SingularMixed_s0_sil0

  subroutine t_SLP_out_c2_dp_pp0_w1SingularMixed_s0_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Singular", &
                      bound_cond_b="Mixed" &
                      , mixing_param_b=1.0_dp &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3) + 1.0_dp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w1SingularMixed_s0_sil1

  subroutine t_SLP_out_c2_dp_pp0_w1SingularMixed_s1_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Singular", &
                      bound_cond_b="Mixed" &
                      , mixing_param_b=1.0_dp &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3) + 1.0_dp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w1SingularMixed_s1_sil0

  subroutine t_SLP_out_c2_dp_pp0_w1SingularMixed_s1_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Singular", &
                      bound_cond_b="Mixed" &
                      , mixing_param_b=1.0_dp &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3) + 1.0_dp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w1SingularMixed_s1_sil1

  subroutine t_SLP_out_c2_dp_pp0_w1SingularFree_s0_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_dp, b=1.0_dp, N=N, &
                    p=p, &
                    q=q, &
                    w=w, &
                    bound_cond_a="Singular", &
                    bound_cond_b="Free" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
  end subroutine t_SLP_out_c2_dp_pp0_w1SingularFree_s0_sil0

  subroutine t_SLP_out_c2_dp_pp0_w1SingularFree_s0_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Singular", &
                      bound_cond_b="Free" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w1SingularFree_s0_sil1

  subroutine t_SLP_out_c2_dp_pp0_w1SingularFree_s1_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Singular", &
                      bound_cond_b="Free" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w1SingularFree_s1_sil0

  subroutine t_SLP_out_c2_dp_pp0_w1SingularFree_s1_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Singular", &
                      bound_cond_b="Free" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w1SingularFree_s1_sil1

  subroutine t_SLP_out_c2_dp_pp0_w1SingularSingular_s0_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_dp, b=1.0_dp, N=N, &
                    p=p, &
                    q=q, &
                    w=w, &
                    bound_cond_a="Singular", &
                    bound_cond_b="Singular" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
  end subroutine t_SLP_out_c2_dp_pp0_w1SingularSingular_s0_sil0

  subroutine t_SLP_out_c2_dp_pp0_w1SingularSingular_s0_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Singular", &
                      bound_cond_b="Singular" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w1SingularSingular_s0_sil1

  subroutine t_SLP_out_c2_dp_pp0_w1SingularSingular_s1_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Singular", &
                      bound_cond_b="Singular" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w1SingularSingular_s1_sil0

  subroutine t_SLP_out_c2_dp_pp0_w1SingularSingular_s1_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Singular", &
                      bound_cond_b="Singular" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w1SingularSingular_s1_sil1

  subroutine t_SLP_out_c2_dp_pp1_w0DirichletDirichlet_s0_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_dp, b=1.0_dp, N=N, &
                    p=p, &
                    pp=pp, &
                    q=q, &
                    bound_cond_a="Dirichlet", &
                    bound_cond_b="Dirichlet" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(1, 1:N - 3)) > tol_dp)) then
      allocate (error)
      return
    endif
    if (any(abs(vl(N, 1:N - 3)) > tol_dp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_dp_pp1_w0DirichletDirichlet_s0_sil0

  subroutine t_SLP_out_c2_dp_pp1_w0DirichletDirichlet_s0_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Dirichlet", &
                      bound_cond_b="Dirichlet" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w0DirichletDirichlet_s0_sil1

  subroutine t_SLP_out_c2_dp_pp1_w0DirichletDirichlet_s1_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Dirichlet", &
                      bound_cond_b="Dirichlet" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w0DirichletDirichlet_s1_sil0

  subroutine t_SLP_out_c2_dp_pp1_w0DirichletDirichlet_s1_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Dirichlet", &
                      bound_cond_b="Dirichlet" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w0DirichletDirichlet_s1_sil1

  subroutine t_SLP_out_c2_dp_pp1_w0DirichletNeumann_s0_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_dp, b=1.0_dp, N=N, &
                    p=p, &
                    pp=pp, &
                    q=q, &
                    bound_cond_a="Dirichlet", &
                    bound_cond_b="Neumann" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(1, 1:N - 3)) > tol_dp)) then
      allocate (error)
      return
    endif
    if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_dp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_dp_pp1_w0DirichletNeumann_s0_sil0

  subroutine t_SLP_out_c2_dp_pp1_w0DirichletNeumann_s0_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Dirichlet", &
                      bound_cond_b="Neumann" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w0DirichletNeumann_s0_sil1

  subroutine t_SLP_out_c2_dp_pp1_w0DirichletNeumann_s1_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Dirichlet", &
                      bound_cond_b="Neumann" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w0DirichletNeumann_s1_sil0

  subroutine t_SLP_out_c2_dp_pp1_w0DirichletNeumann_s1_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Dirichlet", &
                      bound_cond_b="Neumann" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w0DirichletNeumann_s1_sil1

  subroutine t_SLP_out_c2_dp_pp1_w0DirichletMixed_s0_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_dp, b=1.0_dp, N=N, &
                    p=p, &
                    pp=pp, &
                    q=q, &
                    bound_cond_a="Dirichlet", &
                    bound_cond_b="Mixed" &
                    , mixing_param_b=1.0_dp &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(1, 1:N - 3)) > tol_dp)) then
      allocate (error)
      return
    endif
    if (any(abs(vl(N, 1:N - 3) + 1.0_dp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_dp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_dp_pp1_w0DirichletMixed_s0_sil0

  subroutine t_SLP_out_c2_dp_pp1_w0DirichletMixed_s0_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Dirichlet", &
                      bound_cond_b="Mixed" &
                      , mixing_param_b=1.0_dp &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) + 1.0_dp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w0DirichletMixed_s0_sil1

  subroutine t_SLP_out_c2_dp_pp1_w0DirichletMixed_s1_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Dirichlet", &
                      bound_cond_b="Mixed" &
                      , mixing_param_b=1.0_dp &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) + 1.0_dp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w0DirichletMixed_s1_sil0

  subroutine t_SLP_out_c2_dp_pp1_w0DirichletMixed_s1_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Dirichlet", &
                      bound_cond_b="Mixed" &
                      , mixing_param_b=1.0_dp &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) + 1.0_dp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w0DirichletMixed_s1_sil1

  subroutine t_SLP_out_c2_dp_pp1_w0DirichletFree_s0_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_dp, b=1.0_dp, N=N, &
                    p=p, &
                    pp=pp, &
                    q=q, &
                    bound_cond_a="Dirichlet", &
                    bound_cond_b="Free" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(1, 1:N - 3)) > tol_dp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_dp_pp1_w0DirichletFree_s0_sil0

  subroutine t_SLP_out_c2_dp_pp1_w0DirichletFree_s0_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Dirichlet", &
                      bound_cond_b="Free" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w0DirichletFree_s0_sil1

  subroutine t_SLP_out_c2_dp_pp1_w0DirichletFree_s1_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Dirichlet", &
                      bound_cond_b="Free" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w0DirichletFree_s1_sil0

  subroutine t_SLP_out_c2_dp_pp1_w0DirichletFree_s1_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Dirichlet", &
                      bound_cond_b="Free" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w0DirichletFree_s1_sil1

  subroutine t_SLP_out_c2_dp_pp1_w0DirichletSingular_s0_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_dp, b=1.0_dp, N=N, &
                    p=p, &
                    pp=pp, &
                    q=q, &
                    bound_cond_a="Dirichlet", &
                    bound_cond_b="Singular" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(1, 1:N - 3)) > tol_dp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_dp_pp1_w0DirichletSingular_s0_sil0

  subroutine t_SLP_out_c2_dp_pp1_w0DirichletSingular_s0_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Dirichlet", &
                      bound_cond_b="Singular" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w0DirichletSingular_s0_sil1

  subroutine t_SLP_out_c2_dp_pp1_w0DirichletSingular_s1_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Dirichlet", &
                      bound_cond_b="Singular" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w0DirichletSingular_s1_sil0

  subroutine t_SLP_out_c2_dp_pp1_w0DirichletSingular_s1_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Dirichlet", &
                      bound_cond_b="Singular" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w0DirichletSingular_s1_sil1

  subroutine t_SLP_out_c2_dp_pp1_w0NeumannDirichlet_s0_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_dp, b=1.0_dp, N=N, &
                    p=p, &
                    pp=pp, &
                    q=q, &
                    bound_cond_a="Neumann", &
                    bound_cond_b="Dirichlet" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(N, 1:N - 3)) > tol_dp)) then
      allocate (error)
      return
    endif
    if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_dp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_dp_pp1_w0NeumannDirichlet_s0_sil0

  subroutine t_SLP_out_c2_dp_pp1_w0NeumannDirichlet_s0_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Neumann", &
                      bound_cond_b="Dirichlet" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w0NeumannDirichlet_s0_sil1

  subroutine t_SLP_out_c2_dp_pp1_w0NeumannDirichlet_s1_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Neumann", &
                      bound_cond_b="Dirichlet" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w0NeumannDirichlet_s1_sil0

  subroutine t_SLP_out_c2_dp_pp1_w0NeumannDirichlet_s1_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Neumann", &
                      bound_cond_b="Dirichlet" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w0NeumannDirichlet_s1_sil1

  subroutine t_SLP_out_c2_dp_pp1_w0NeumannNeumann_s0_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_dp, b=1.0_dp, N=N, &
                    p=p, &
                    pp=pp, &
                    q=q, &
                    bound_cond_a="Neumann", &
                    bound_cond_b="Neumann" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_dp)) then
      allocate (error)
      return
    endif
    if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_dp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_dp_pp1_w0NeumannNeumann_s0_sil0

  subroutine t_SLP_out_c2_dp_pp1_w0NeumannNeumann_s0_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Neumann", &
                      bound_cond_b="Neumann" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w0NeumannNeumann_s0_sil1

  subroutine t_SLP_out_c2_dp_pp1_w0NeumannNeumann_s1_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Neumann", &
                      bound_cond_b="Neumann" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w0NeumannNeumann_s1_sil0

  subroutine t_SLP_out_c2_dp_pp1_w0NeumannNeumann_s1_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Neumann", &
                      bound_cond_b="Neumann" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w0NeumannNeumann_s1_sil1

  subroutine t_SLP_out_c2_dp_pp1_w0NeumannMixed_s0_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_dp, b=1.0_dp, N=N, &
                    p=p, &
                    pp=pp, &
                    q=q, &
                    bound_cond_a="Neumann", &
                    bound_cond_b="Mixed" &
                    , mixing_param_b=1.0_dp &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_dp)) then
      allocate (error)
      return
    endif
    if (any(abs(vl(N, 1:N - 3) + 1.0_dp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_dp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_dp_pp1_w0NeumannMixed_s0_sil0

  subroutine t_SLP_out_c2_dp_pp1_w0NeumannMixed_s0_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Neumann", &
                      bound_cond_b="Mixed" &
                      , mixing_param_b=1.0_dp &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) + 1.0_dp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w0NeumannMixed_s0_sil1

  subroutine t_SLP_out_c2_dp_pp1_w0NeumannMixed_s1_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Neumann", &
                      bound_cond_b="Mixed" &
                      , mixing_param_b=1.0_dp &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) + 1.0_dp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w0NeumannMixed_s1_sil0

  subroutine t_SLP_out_c2_dp_pp1_w0NeumannMixed_s1_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Neumann", &
                      bound_cond_b="Mixed" &
                      , mixing_param_b=1.0_dp &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) + 1.0_dp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w0NeumannMixed_s1_sil1

  subroutine t_SLP_out_c2_dp_pp1_w0NeumannFree_s0_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_dp, b=1.0_dp, N=N, &
                    p=p, &
                    pp=pp, &
                    q=q, &
                    bound_cond_a="Neumann", &
                    bound_cond_b="Free" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_dp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_dp_pp1_w0NeumannFree_s0_sil0

  subroutine t_SLP_out_c2_dp_pp1_w0NeumannFree_s0_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Neumann", &
                      bound_cond_b="Free" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w0NeumannFree_s0_sil1

  subroutine t_SLP_out_c2_dp_pp1_w0NeumannFree_s1_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Neumann", &
                      bound_cond_b="Free" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w0NeumannFree_s1_sil0

  subroutine t_SLP_out_c2_dp_pp1_w0NeumannFree_s1_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Neumann", &
                      bound_cond_b="Free" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w0NeumannFree_s1_sil1

  subroutine t_SLP_out_c2_dp_pp1_w0NeumannSingular_s0_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_dp, b=1.0_dp, N=N, &
                    p=p, &
                    pp=pp, &
                    q=q, &
                    bound_cond_a="Neumann", &
                    bound_cond_b="Singular" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_dp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_dp_pp1_w0NeumannSingular_s0_sil0

  subroutine t_SLP_out_c2_dp_pp1_w0NeumannSingular_s0_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Neumann", &
                      bound_cond_b="Singular" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w0NeumannSingular_s0_sil1

  subroutine t_SLP_out_c2_dp_pp1_w0NeumannSingular_s1_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Neumann", &
                      bound_cond_b="Singular" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w0NeumannSingular_s1_sil0

  subroutine t_SLP_out_c2_dp_pp1_w0NeumannSingular_s1_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Neumann", &
                      bound_cond_b="Singular" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w0NeumannSingular_s1_sil1

  subroutine t_SLP_out_c2_dp_pp1_w0MixedDirichlet_s0_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_dp, b=1.0_dp, N=N, &
                    p=p, &
                    pp=pp, &
                    q=q, &
                    bound_cond_a="Mixed", &
                    bound_cond_b="Dirichlet" &
                    , mixing_param_a=1.0_dp &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(N, 1:N - 3)) > tol_dp)) then
      allocate (error)
      return
    endif
    if (any(abs(vl(1, 1:N - 3) - 1.0_dp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_dp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_dp_pp1_w0MixedDirichlet_s0_sil0

  subroutine t_SLP_out_c2_dp_pp1_w0MixedDirichlet_s0_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Mixed", &
                      bound_cond_b="Dirichlet" &
                      , mixing_param_a=1.0_dp &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(1, 1:N - 3) - 1.0_dp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w0MixedDirichlet_s0_sil1

  subroutine t_SLP_out_c2_dp_pp1_w0MixedDirichlet_s1_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Mixed", &
                      bound_cond_b="Dirichlet" &
                      , mixing_param_a=1.0_dp &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(1, 1:N - 3) - 1.0_dp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w0MixedDirichlet_s1_sil0

  subroutine t_SLP_out_c2_dp_pp1_w0MixedDirichlet_s1_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Mixed", &
                      bound_cond_b="Dirichlet" &
                      , mixing_param_a=1.0_dp &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(1, 1:N - 3) - 1.0_dp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w0MixedDirichlet_s1_sil1

  subroutine t_SLP_out_c2_dp_pp1_w0MixedNeumann_s0_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_dp, b=1.0_dp, N=N, &
                    p=p, &
                    pp=pp, &
                    q=q, &
                    bound_cond_a="Mixed", &
                    bound_cond_b="Neumann" &
                    , mixing_param_a=1.0_dp &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_dp)) then
      allocate (error)
      return
    endif
    if (any(abs(vl(1, 1:N - 3) - 1.0_dp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_dp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_dp_pp1_w0MixedNeumann_s0_sil0

  subroutine t_SLP_out_c2_dp_pp1_w0MixedNeumann_s0_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Mixed", &
                      bound_cond_b="Neumann" &
                      , mixing_param_a=1.0_dp &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(1, 1:N - 3) - 1.0_dp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w0MixedNeumann_s0_sil1

  subroutine t_SLP_out_c2_dp_pp1_w0MixedNeumann_s1_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Mixed", &
                      bound_cond_b="Neumann" &
                      , mixing_param_a=1.0_dp &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(1, 1:N - 3) - 1.0_dp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w0MixedNeumann_s1_sil0

  subroutine t_SLP_out_c2_dp_pp1_w0MixedNeumann_s1_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Mixed", &
                      bound_cond_b="Neumann" &
                      , mixing_param_a=1.0_dp &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(1, 1:N - 3) - 1.0_dp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w0MixedNeumann_s1_sil1

  subroutine t_SLP_out_c2_dp_pp1_w0MixedMixed_s0_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_dp, b=1.0_dp, N=N, &
                    p=p, &
                    pp=pp, &
                    q=q, &
                    bound_cond_a="Mixed", &
                    bound_cond_b="Mixed" &
                    , mixing_param_a=1.0_dp &
                    , mixing_param_b=1.0_dp &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(1, 1:N - 3) - 1.0_dp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_dp)) then
      allocate (error)
      return
    endif
    if (any(abs(vl(N, 1:N - 3) + 1.0_dp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_dp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_dp_pp1_w0MixedMixed_s0_sil0

  subroutine t_SLP_out_c2_dp_pp1_w0MixedMixed_s0_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Mixed", &
                      bound_cond_b="Mixed" &
                      , mixing_param_a=1.0_dp &
                      , mixing_param_b=1.0_dp &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - 1.0_dp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) + 1.0_dp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w0MixedMixed_s0_sil1

  subroutine t_SLP_out_c2_dp_pp1_w0MixedMixed_s1_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Mixed", &
                      bound_cond_b="Mixed" &
                      , mixing_param_a=1.0_dp &
                      , mixing_param_b=1.0_dp &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - 1.0_dp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) + 1.0_dp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w0MixedMixed_s1_sil0

  subroutine t_SLP_out_c2_dp_pp1_w0MixedMixed_s1_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Mixed", &
                      bound_cond_b="Mixed" &
                      , mixing_param_a=1.0_dp &
                      , mixing_param_b=1.0_dp &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - 1.0_dp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) + 1.0_dp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w0MixedMixed_s1_sil1

  subroutine t_SLP_out_c2_dp_pp1_w0MixedFree_s0_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_dp, b=1.0_dp, N=N, &
                    p=p, &
                    pp=pp, &
                    q=q, &
                    bound_cond_a="Mixed", &
                    bound_cond_b="Free" &
                    , mixing_param_a=1.0_dp &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(1, 1:N - 3) - 1.0_dp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_dp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_dp_pp1_w0MixedFree_s0_sil0

  subroutine t_SLP_out_c2_dp_pp1_w0MixedFree_s0_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Mixed", &
                      bound_cond_b="Free" &
                      , mixing_param_a=1.0_dp &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - 1.0_dp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w0MixedFree_s0_sil1

  subroutine t_SLP_out_c2_dp_pp1_w0MixedFree_s1_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Mixed", &
                      bound_cond_b="Free" &
                      , mixing_param_a=1.0_dp &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - 1.0_dp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w0MixedFree_s1_sil0

  subroutine t_SLP_out_c2_dp_pp1_w0MixedFree_s1_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Mixed", &
                      bound_cond_b="Free" &
                      , mixing_param_a=1.0_dp &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - 1.0_dp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w0MixedFree_s1_sil1

  subroutine t_SLP_out_c2_dp_pp1_w0MixedSingular_s0_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_dp, b=1.0_dp, N=N, &
                    p=p, &
                    pp=pp, &
                    q=q, &
                    bound_cond_a="Mixed", &
                    bound_cond_b="Singular" &
                    , mixing_param_a=1.0_dp &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(1, 1:N - 3) - 1.0_dp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_dp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_dp_pp1_w0MixedSingular_s0_sil0

  subroutine t_SLP_out_c2_dp_pp1_w0MixedSingular_s0_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Mixed", &
                      bound_cond_b="Singular" &
                      , mixing_param_a=1.0_dp &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - 1.0_dp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w0MixedSingular_s0_sil1

  subroutine t_SLP_out_c2_dp_pp1_w0MixedSingular_s1_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Mixed", &
                      bound_cond_b="Singular" &
                      , mixing_param_a=1.0_dp &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - 1.0_dp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w0MixedSingular_s1_sil0

  subroutine t_SLP_out_c2_dp_pp1_w0MixedSingular_s1_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Mixed", &
                      bound_cond_b="Singular" &
                      , mixing_param_a=1.0_dp &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - 1.0_dp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w0MixedSingular_s1_sil1

  subroutine t_SLP_out_c2_dp_pp1_w0FreeDirichlet_s0_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_dp, b=1.0_dp, N=N, &
                    p=p, &
                    pp=pp, &
                    q=q, &
                    bound_cond_a="Free", &
                    bound_cond_b="Dirichlet" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(N, 1:N - 3)) > tol_dp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_dp_pp1_w0FreeDirichlet_s0_sil0

  subroutine t_SLP_out_c2_dp_pp1_w0FreeDirichlet_s0_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Free", &
                      bound_cond_b="Dirichlet" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w0FreeDirichlet_s0_sil1

  subroutine t_SLP_out_c2_dp_pp1_w0FreeDirichlet_s1_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Free", &
                      bound_cond_b="Dirichlet" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w0FreeDirichlet_s1_sil0

  subroutine t_SLP_out_c2_dp_pp1_w0FreeDirichlet_s1_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Free", &
                      bound_cond_b="Dirichlet" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w0FreeDirichlet_s1_sil1

  subroutine t_SLP_out_c2_dp_pp1_w0FreeNeumann_s0_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_dp, b=1.0_dp, N=N, &
                    p=p, &
                    pp=pp, &
                    q=q, &
                    bound_cond_a="Free", &
                    bound_cond_b="Neumann" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_dp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_dp_pp1_w0FreeNeumann_s0_sil0

  subroutine t_SLP_out_c2_dp_pp1_w0FreeNeumann_s0_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Free", &
                      bound_cond_b="Neumann" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w0FreeNeumann_s0_sil1

  subroutine t_SLP_out_c2_dp_pp1_w0FreeNeumann_s1_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Free", &
                      bound_cond_b="Neumann" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w0FreeNeumann_s1_sil0

  subroutine t_SLP_out_c2_dp_pp1_w0FreeNeumann_s1_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Free", &
                      bound_cond_b="Neumann" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w0FreeNeumann_s1_sil1

  subroutine t_SLP_out_c2_dp_pp1_w0FreeMixed_s0_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_dp, b=1.0_dp, N=N, &
                    p=p, &
                    pp=pp, &
                    q=q, &
                    bound_cond_a="Free", &
                    bound_cond_b="Mixed" &
                    , mixing_param_b=1.0_dp &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(N, 1:N - 3) + 1.0_dp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_dp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_dp_pp1_w0FreeMixed_s0_sil0

  subroutine t_SLP_out_c2_dp_pp1_w0FreeMixed_s0_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Free", &
                      bound_cond_b="Mixed" &
                      , mixing_param_b=1.0_dp &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3) + 1.0_dp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w0FreeMixed_s0_sil1

  subroutine t_SLP_out_c2_dp_pp1_w0FreeMixed_s1_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Free", &
                      bound_cond_b="Mixed" &
                      , mixing_param_b=1.0_dp &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3) + 1.0_dp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w0FreeMixed_s1_sil0

  subroutine t_SLP_out_c2_dp_pp1_w0FreeMixed_s1_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Free", &
                      bound_cond_b="Mixed" &
                      , mixing_param_b=1.0_dp &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3) + 1.0_dp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w0FreeMixed_s1_sil1

  subroutine t_SLP_out_c2_dp_pp1_w0FreeFree_s0_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_dp, b=1.0_dp, N=N, &
                    p=p, &
                    pp=pp, &
                    q=q, &
                    bound_cond_a="Free", &
                    bound_cond_b="Free" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
  end subroutine t_SLP_out_c2_dp_pp1_w0FreeFree_s0_sil0

  subroutine t_SLP_out_c2_dp_pp1_w0FreeFree_s0_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Free", &
                      bound_cond_b="Free" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w0FreeFree_s0_sil1

  subroutine t_SLP_out_c2_dp_pp1_w0FreeFree_s1_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Free", &
                      bound_cond_b="Free" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w0FreeFree_s1_sil0

  subroutine t_SLP_out_c2_dp_pp1_w0FreeFree_s1_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Free", &
                      bound_cond_b="Free" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w0FreeFree_s1_sil1

  subroutine t_SLP_out_c2_dp_pp1_w0FreeSingular_s0_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_dp, b=1.0_dp, N=N, &
                    p=p, &
                    pp=pp, &
                    q=q, &
                    bound_cond_a="Free", &
                    bound_cond_b="Singular" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
  end subroutine t_SLP_out_c2_dp_pp1_w0FreeSingular_s0_sil0

  subroutine t_SLP_out_c2_dp_pp1_w0FreeSingular_s0_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Free", &
                      bound_cond_b="Singular" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w0FreeSingular_s0_sil1

  subroutine t_SLP_out_c2_dp_pp1_w0FreeSingular_s1_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Free", &
                      bound_cond_b="Singular" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w0FreeSingular_s1_sil0

  subroutine t_SLP_out_c2_dp_pp1_w0FreeSingular_s1_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Free", &
                      bound_cond_b="Singular" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w0FreeSingular_s1_sil1

  subroutine t_SLP_out_c2_dp_pp1_w0SingularDirichlet_s0_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_dp, b=1.0_dp, N=N, &
                    p=p, &
                    pp=pp, &
                    q=q, &
                    bound_cond_a="Singular", &
                    bound_cond_b="Dirichlet" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(N, 1:N - 3)) > tol_dp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_dp_pp1_w0SingularDirichlet_s0_sil0

  subroutine t_SLP_out_c2_dp_pp1_w0SingularDirichlet_s0_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Singular", &
                      bound_cond_b="Dirichlet" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w0SingularDirichlet_s0_sil1

  subroutine t_SLP_out_c2_dp_pp1_w0SingularDirichlet_s1_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Singular", &
                      bound_cond_b="Dirichlet" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w0SingularDirichlet_s1_sil0

  subroutine t_SLP_out_c2_dp_pp1_w0SingularDirichlet_s1_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Singular", &
                      bound_cond_b="Dirichlet" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w0SingularDirichlet_s1_sil1

  subroutine t_SLP_out_c2_dp_pp1_w0SingularNeumann_s0_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_dp, b=1.0_dp, N=N, &
                    p=p, &
                    pp=pp, &
                    q=q, &
                    bound_cond_a="Singular", &
                    bound_cond_b="Neumann" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_dp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_dp_pp1_w0SingularNeumann_s0_sil0

  subroutine t_SLP_out_c2_dp_pp1_w0SingularNeumann_s0_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Singular", &
                      bound_cond_b="Neumann" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w0SingularNeumann_s0_sil1

  subroutine t_SLP_out_c2_dp_pp1_w0SingularNeumann_s1_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Singular", &
                      bound_cond_b="Neumann" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w0SingularNeumann_s1_sil0

  subroutine t_SLP_out_c2_dp_pp1_w0SingularNeumann_s1_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Singular", &
                      bound_cond_b="Neumann" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w0SingularNeumann_s1_sil1

  subroutine t_SLP_out_c2_dp_pp1_w0SingularMixed_s0_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_dp, b=1.0_dp, N=N, &
                    p=p, &
                    pp=pp, &
                    q=q, &
                    bound_cond_a="Singular", &
                    bound_cond_b="Mixed" &
                    , mixing_param_b=1.0_dp &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(N, 1:N - 3) + 1.0_dp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_dp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_dp_pp1_w0SingularMixed_s0_sil0

  subroutine t_SLP_out_c2_dp_pp1_w0SingularMixed_s0_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Singular", &
                      bound_cond_b="Mixed" &
                      , mixing_param_b=1.0_dp &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3) + 1.0_dp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w0SingularMixed_s0_sil1

  subroutine t_SLP_out_c2_dp_pp1_w0SingularMixed_s1_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Singular", &
                      bound_cond_b="Mixed" &
                      , mixing_param_b=1.0_dp &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3) + 1.0_dp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w0SingularMixed_s1_sil0

  subroutine t_SLP_out_c2_dp_pp1_w0SingularMixed_s1_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Singular", &
                      bound_cond_b="Mixed" &
                      , mixing_param_b=1.0_dp &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3) + 1.0_dp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w0SingularMixed_s1_sil1

  subroutine t_SLP_out_c2_dp_pp1_w0SingularFree_s0_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_dp, b=1.0_dp, N=N, &
                    p=p, &
                    pp=pp, &
                    q=q, &
                    bound_cond_a="Singular", &
                    bound_cond_b="Free" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
  end subroutine t_SLP_out_c2_dp_pp1_w0SingularFree_s0_sil0

  subroutine t_SLP_out_c2_dp_pp1_w0SingularFree_s0_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Singular", &
                      bound_cond_b="Free" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w0SingularFree_s0_sil1

  subroutine t_SLP_out_c2_dp_pp1_w0SingularFree_s1_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Singular", &
                      bound_cond_b="Free" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w0SingularFree_s1_sil0

  subroutine t_SLP_out_c2_dp_pp1_w0SingularFree_s1_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Singular", &
                      bound_cond_b="Free" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w0SingularFree_s1_sil1

  subroutine t_SLP_out_c2_dp_pp1_w0SingularSingular_s0_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_dp, b=1.0_dp, N=N, &
                    p=p, &
                    pp=pp, &
                    q=q, &
                    bound_cond_a="Singular", &
                    bound_cond_b="Singular" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
  end subroutine t_SLP_out_c2_dp_pp1_w0SingularSingular_s0_sil0

  subroutine t_SLP_out_c2_dp_pp1_w0SingularSingular_s0_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Singular", &
                      bound_cond_b="Singular" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w0SingularSingular_s0_sil1

  subroutine t_SLP_out_c2_dp_pp1_w0SingularSingular_s1_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Singular", &
                      bound_cond_b="Singular" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w0SingularSingular_s1_sil0

  subroutine t_SLP_out_c2_dp_pp1_w0SingularSingular_s1_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Singular", &
                      bound_cond_b="Singular" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w0SingularSingular_s1_sil1

  subroutine t_SLP_out_c2_dp_pp1_w1DirichletDirichlet_s0_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_dp, b=1.0_dp, N=N, &
                    p=p, &
                    pp=pp, &
                    q=q, &
                    w=w, &
                    bound_cond_a="Dirichlet", &
                    bound_cond_b="Dirichlet" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(1, 1:N - 3)) > tol_dp)) then
      allocate (error)
      return
    endif
    if (any(abs(vl(N, 1:N - 3)) > tol_dp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_dp_pp1_w1DirichletDirichlet_s0_sil0

  subroutine t_SLP_out_c2_dp_pp1_w1DirichletDirichlet_s0_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Dirichlet", &
                      bound_cond_b="Dirichlet" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w1DirichletDirichlet_s0_sil1

  subroutine t_SLP_out_c2_dp_pp1_w1DirichletDirichlet_s1_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Dirichlet", &
                      bound_cond_b="Dirichlet" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w1DirichletDirichlet_s1_sil0

  subroutine t_SLP_out_c2_dp_pp1_w1DirichletDirichlet_s1_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Dirichlet", &
                      bound_cond_b="Dirichlet" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w1DirichletDirichlet_s1_sil1

  subroutine t_SLP_out_c2_dp_pp1_w1DirichletNeumann_s0_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_dp, b=1.0_dp, N=N, &
                    p=p, &
                    pp=pp, &
                    q=q, &
                    w=w, &
                    bound_cond_a="Dirichlet", &
                    bound_cond_b="Neumann" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(1, 1:N - 3)) > tol_dp)) then
      allocate (error)
      return
    endif
    if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_dp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_dp_pp1_w1DirichletNeumann_s0_sil0

  subroutine t_SLP_out_c2_dp_pp1_w1DirichletNeumann_s0_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Dirichlet", &
                      bound_cond_b="Neumann" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w1DirichletNeumann_s0_sil1

  subroutine t_SLP_out_c2_dp_pp1_w1DirichletNeumann_s1_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Dirichlet", &
                      bound_cond_b="Neumann" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w1DirichletNeumann_s1_sil0

  subroutine t_SLP_out_c2_dp_pp1_w1DirichletNeumann_s1_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Dirichlet", &
                      bound_cond_b="Neumann" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w1DirichletNeumann_s1_sil1

  subroutine t_SLP_out_c2_dp_pp1_w1DirichletMixed_s0_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_dp, b=1.0_dp, N=N, &
                    p=p, &
                    pp=pp, &
                    q=q, &
                    w=w, &
                    bound_cond_a="Dirichlet", &
                    bound_cond_b="Mixed" &
                    , mixing_param_b=1.0_dp &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(1, 1:N - 3)) > tol_dp)) then
      allocate (error)
      return
    endif
    if (any(abs(vl(N, 1:N - 3) + 1.0_dp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_dp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_dp_pp1_w1DirichletMixed_s0_sil0

  subroutine t_SLP_out_c2_dp_pp1_w1DirichletMixed_s0_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Dirichlet", &
                      bound_cond_b="Mixed" &
                      , mixing_param_b=1.0_dp &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) + 1.0_dp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w1DirichletMixed_s0_sil1

  subroutine t_SLP_out_c2_dp_pp1_w1DirichletMixed_s1_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Dirichlet", &
                      bound_cond_b="Mixed" &
                      , mixing_param_b=1.0_dp &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) + 1.0_dp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w1DirichletMixed_s1_sil0

  subroutine t_SLP_out_c2_dp_pp1_w1DirichletMixed_s1_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Dirichlet", &
                      bound_cond_b="Mixed" &
                      , mixing_param_b=1.0_dp &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) + 1.0_dp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w1DirichletMixed_s1_sil1

  subroutine t_SLP_out_c2_dp_pp1_w1DirichletFree_s0_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_dp, b=1.0_dp, N=N, &
                    p=p, &
                    pp=pp, &
                    q=q, &
                    w=w, &
                    bound_cond_a="Dirichlet", &
                    bound_cond_b="Free" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(1, 1:N - 3)) > tol_dp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_dp_pp1_w1DirichletFree_s0_sil0

  subroutine t_SLP_out_c2_dp_pp1_w1DirichletFree_s0_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Dirichlet", &
                      bound_cond_b="Free" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w1DirichletFree_s0_sil1

  subroutine t_SLP_out_c2_dp_pp1_w1DirichletFree_s1_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Dirichlet", &
                      bound_cond_b="Free" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w1DirichletFree_s1_sil0

  subroutine t_SLP_out_c2_dp_pp1_w1DirichletFree_s1_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Dirichlet", &
                      bound_cond_b="Free" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w1DirichletFree_s1_sil1

  subroutine t_SLP_out_c2_dp_pp1_w1DirichletSingular_s0_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_dp, b=1.0_dp, N=N, &
                    p=p, &
                    pp=pp, &
                    q=q, &
                    w=w, &
                    bound_cond_a="Dirichlet", &
                    bound_cond_b="Singular" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(1, 1:N - 3)) > tol_dp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_dp_pp1_w1DirichletSingular_s0_sil0

  subroutine t_SLP_out_c2_dp_pp1_w1DirichletSingular_s0_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Dirichlet", &
                      bound_cond_b="Singular" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w1DirichletSingular_s0_sil1

  subroutine t_SLP_out_c2_dp_pp1_w1DirichletSingular_s1_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Dirichlet", &
                      bound_cond_b="Singular" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w1DirichletSingular_s1_sil0

  subroutine t_SLP_out_c2_dp_pp1_w1DirichletSingular_s1_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Dirichlet", &
                      bound_cond_b="Singular" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w1DirichletSingular_s1_sil1

  subroutine t_SLP_out_c2_dp_pp1_w1NeumannDirichlet_s0_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_dp, b=1.0_dp, N=N, &
                    p=p, &
                    pp=pp, &
                    q=q, &
                    w=w, &
                    bound_cond_a="Neumann", &
                    bound_cond_b="Dirichlet" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(N, 1:N - 3)) > tol_dp)) then
      allocate (error)
      return
    endif
    if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_dp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_dp_pp1_w1NeumannDirichlet_s0_sil0

  subroutine t_SLP_out_c2_dp_pp1_w1NeumannDirichlet_s0_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Neumann", &
                      bound_cond_b="Dirichlet" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w1NeumannDirichlet_s0_sil1

  subroutine t_SLP_out_c2_dp_pp1_w1NeumannDirichlet_s1_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Neumann", &
                      bound_cond_b="Dirichlet" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w1NeumannDirichlet_s1_sil0

  subroutine t_SLP_out_c2_dp_pp1_w1NeumannDirichlet_s1_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Neumann", &
                      bound_cond_b="Dirichlet" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w1NeumannDirichlet_s1_sil1

  subroutine t_SLP_out_c2_dp_pp1_w1NeumannNeumann_s0_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_dp, b=1.0_dp, N=N, &
                    p=p, &
                    pp=pp, &
                    q=q, &
                    w=w, &
                    bound_cond_a="Neumann", &
                    bound_cond_b="Neumann" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_dp)) then
      allocate (error)
      return
    endif
    if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_dp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_dp_pp1_w1NeumannNeumann_s0_sil0

  subroutine t_SLP_out_c2_dp_pp1_w1NeumannNeumann_s0_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Neumann", &
                      bound_cond_b="Neumann" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w1NeumannNeumann_s0_sil1

  subroutine t_SLP_out_c2_dp_pp1_w1NeumannNeumann_s1_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Neumann", &
                      bound_cond_b="Neumann" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w1NeumannNeumann_s1_sil0

  subroutine t_SLP_out_c2_dp_pp1_w1NeumannNeumann_s1_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Neumann", &
                      bound_cond_b="Neumann" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w1NeumannNeumann_s1_sil1

  subroutine t_SLP_out_c2_dp_pp1_w1NeumannMixed_s0_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_dp, b=1.0_dp, N=N, &
                    p=p, &
                    pp=pp, &
                    q=q, &
                    w=w, &
                    bound_cond_a="Neumann", &
                    bound_cond_b="Mixed" &
                    , mixing_param_b=1.0_dp &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_dp)) then
      allocate (error)
      return
    endif
    if (any(abs(vl(N, 1:N - 3) + 1.0_dp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_dp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_dp_pp1_w1NeumannMixed_s0_sil0

  subroutine t_SLP_out_c2_dp_pp1_w1NeumannMixed_s0_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Neumann", &
                      bound_cond_b="Mixed" &
                      , mixing_param_b=1.0_dp &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) + 1.0_dp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w1NeumannMixed_s0_sil1

  subroutine t_SLP_out_c2_dp_pp1_w1NeumannMixed_s1_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Neumann", &
                      bound_cond_b="Mixed" &
                      , mixing_param_b=1.0_dp &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) + 1.0_dp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w1NeumannMixed_s1_sil0

  subroutine t_SLP_out_c2_dp_pp1_w1NeumannMixed_s1_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Neumann", &
                      bound_cond_b="Mixed" &
                      , mixing_param_b=1.0_dp &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) + 1.0_dp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w1NeumannMixed_s1_sil1

  subroutine t_SLP_out_c2_dp_pp1_w1NeumannFree_s0_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_dp, b=1.0_dp, N=N, &
                    p=p, &
                    pp=pp, &
                    q=q, &
                    w=w, &
                    bound_cond_a="Neumann", &
                    bound_cond_b="Free" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_dp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_dp_pp1_w1NeumannFree_s0_sil0

  subroutine t_SLP_out_c2_dp_pp1_w1NeumannFree_s0_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Neumann", &
                      bound_cond_b="Free" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w1NeumannFree_s0_sil1

  subroutine t_SLP_out_c2_dp_pp1_w1NeumannFree_s1_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Neumann", &
                      bound_cond_b="Free" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w1NeumannFree_s1_sil0

  subroutine t_SLP_out_c2_dp_pp1_w1NeumannFree_s1_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Neumann", &
                      bound_cond_b="Free" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w1NeumannFree_s1_sil1

  subroutine t_SLP_out_c2_dp_pp1_w1NeumannSingular_s0_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_dp, b=1.0_dp, N=N, &
                    p=p, &
                    pp=pp, &
                    q=q, &
                    w=w, &
                    bound_cond_a="Neumann", &
                    bound_cond_b="Singular" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_dp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_dp_pp1_w1NeumannSingular_s0_sil0

  subroutine t_SLP_out_c2_dp_pp1_w1NeumannSingular_s0_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Neumann", &
                      bound_cond_b="Singular" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w1NeumannSingular_s0_sil1

  subroutine t_SLP_out_c2_dp_pp1_w1NeumannSingular_s1_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Neumann", &
                      bound_cond_b="Singular" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w1NeumannSingular_s1_sil0

  subroutine t_SLP_out_c2_dp_pp1_w1NeumannSingular_s1_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Neumann", &
                      bound_cond_b="Singular" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(2, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w1NeumannSingular_s1_sil1

  subroutine t_SLP_out_c2_dp_pp1_w1MixedDirichlet_s0_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_dp, b=1.0_dp, N=N, &
                    p=p, &
                    pp=pp, &
                    q=q, &
                    w=w, &
                    bound_cond_a="Mixed", &
                    bound_cond_b="Dirichlet" &
                    , mixing_param_a=1.0_dp &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(N, 1:N - 3)) > tol_dp)) then
      allocate (error)
      return
    endif
    if (any(abs(vl(1, 1:N - 3) - 1.0_dp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_dp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_dp_pp1_w1MixedDirichlet_s0_sil0

  subroutine t_SLP_out_c2_dp_pp1_w1MixedDirichlet_s0_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Mixed", &
                      bound_cond_b="Dirichlet" &
                      , mixing_param_a=1.0_dp &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(1, 1:N - 3) - 1.0_dp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w1MixedDirichlet_s0_sil1

  subroutine t_SLP_out_c2_dp_pp1_w1MixedDirichlet_s1_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Mixed", &
                      bound_cond_b="Dirichlet" &
                      , mixing_param_a=1.0_dp &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(1, 1:N - 3) - 1.0_dp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w1MixedDirichlet_s1_sil0

  subroutine t_SLP_out_c2_dp_pp1_w1MixedDirichlet_s1_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Mixed", &
                      bound_cond_b="Dirichlet" &
                      , mixing_param_a=1.0_dp &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(1, 1:N - 3) - 1.0_dp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w1MixedDirichlet_s1_sil1

  subroutine t_SLP_out_c2_dp_pp1_w1MixedNeumann_s0_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_dp, b=1.0_dp, N=N, &
                    p=p, &
                    pp=pp, &
                    q=q, &
                    w=w, &
                    bound_cond_a="Mixed", &
                    bound_cond_b="Neumann" &
                    , mixing_param_a=1.0_dp &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_dp)) then
      allocate (error)
      return
    endif
    if (any(abs(vl(1, 1:N - 3) - 1.0_dp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_dp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_dp_pp1_w1MixedNeumann_s0_sil0

  subroutine t_SLP_out_c2_dp_pp1_w1MixedNeumann_s0_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Mixed", &
                      bound_cond_b="Neumann" &
                      , mixing_param_a=1.0_dp &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(1, 1:N - 3) - 1.0_dp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w1MixedNeumann_s0_sil1

  subroutine t_SLP_out_c2_dp_pp1_w1MixedNeumann_s1_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Mixed", &
                      bound_cond_b="Neumann" &
                      , mixing_param_a=1.0_dp &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(1, 1:N - 3) - 1.0_dp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w1MixedNeumann_s1_sil0

  subroutine t_SLP_out_c2_dp_pp1_w1MixedNeumann_s1_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Mixed", &
                      bound_cond_b="Neumann" &
                      , mixing_param_a=1.0_dp &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(1, 1:N - 3) - 1.0_dp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w1MixedNeumann_s1_sil1

  subroutine t_SLP_out_c2_dp_pp1_w1MixedMixed_s0_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_dp, b=1.0_dp, N=N, &
                    p=p, &
                    pp=pp, &
                    q=q, &
                    w=w, &
                    bound_cond_a="Mixed", &
                    bound_cond_b="Mixed" &
                    , mixing_param_a=1.0_dp &
                    , mixing_param_b=1.0_dp &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(1, 1:N - 3) - 1.0_dp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_dp)) then
      allocate (error)
      return
    endif
    if (any(abs(vl(N, 1:N - 3) + 1.0_dp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_dp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_dp_pp1_w1MixedMixed_s0_sil0

  subroutine t_SLP_out_c2_dp_pp1_w1MixedMixed_s0_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Mixed", &
                      bound_cond_b="Mixed" &
                      , mixing_param_a=1.0_dp &
                      , mixing_param_b=1.0_dp &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - 1.0_dp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) + 1.0_dp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w1MixedMixed_s0_sil1

  subroutine t_SLP_out_c2_dp_pp1_w1MixedMixed_s1_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Mixed", &
                      bound_cond_b="Mixed" &
                      , mixing_param_a=1.0_dp &
                      , mixing_param_b=1.0_dp &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - 1.0_dp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) + 1.0_dp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w1MixedMixed_s1_sil0

  subroutine t_SLP_out_c2_dp_pp1_w1MixedMixed_s1_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Mixed", &
                      bound_cond_b="Mixed" &
                      , mixing_param_a=1.0_dp &
                      , mixing_param_b=1.0_dp &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - 1.0_dp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(N, 1:N - 3) + 1.0_dp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w1MixedMixed_s1_sil1

  subroutine t_SLP_out_c2_dp_pp1_w1MixedFree_s0_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_dp, b=1.0_dp, N=N, &
                    p=p, &
                    pp=pp, &
                    q=q, &
                    w=w, &
                    bound_cond_a="Mixed", &
                    bound_cond_b="Free" &
                    , mixing_param_a=1.0_dp &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(1, 1:N - 3) - 1.0_dp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_dp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_dp_pp1_w1MixedFree_s0_sil0

  subroutine t_SLP_out_c2_dp_pp1_w1MixedFree_s0_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Mixed", &
                      bound_cond_b="Free" &
                      , mixing_param_a=1.0_dp &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - 1.0_dp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w1MixedFree_s0_sil1

  subroutine t_SLP_out_c2_dp_pp1_w1MixedFree_s1_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Mixed", &
                      bound_cond_b="Free" &
                      , mixing_param_a=1.0_dp &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - 1.0_dp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w1MixedFree_s1_sil0

  subroutine t_SLP_out_c2_dp_pp1_w1MixedFree_s1_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Mixed", &
                      bound_cond_b="Free" &
                      , mixing_param_a=1.0_dp &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - 1.0_dp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w1MixedFree_s1_sil1

  subroutine t_SLP_out_c2_dp_pp1_w1MixedSingular_s0_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_dp, b=1.0_dp, N=N, &
                    p=p, &
                    pp=pp, &
                    q=q, &
                    w=w, &
                    bound_cond_a="Mixed", &
                    bound_cond_b="Singular" &
                    , mixing_param_a=1.0_dp &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(1, 1:N - 3) - 1.0_dp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_dp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_dp_pp1_w1MixedSingular_s0_sil0

  subroutine t_SLP_out_c2_dp_pp1_w1MixedSingular_s0_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Mixed", &
                      bound_cond_b="Singular" &
                      , mixing_param_a=1.0_dp &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - 1.0_dp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w1MixedSingular_s0_sil1

  subroutine t_SLP_out_c2_dp_pp1_w1MixedSingular_s1_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Mixed", &
                      bound_cond_b="Singular" &
                      , mixing_param_a=1.0_dp &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - 1.0_dp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w1MixedSingular_s1_sil0

  subroutine t_SLP_out_c2_dp_pp1_w1MixedSingular_s1_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Mixed", &
                      bound_cond_b="Singular" &
                      , mixing_param_a=1.0_dp &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - 1.0_dp*(vl(2, 1:N - 3) - vl(1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w1MixedSingular_s1_sil1

  subroutine t_SLP_out_c2_dp_pp1_w1FreeDirichlet_s0_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_dp, b=1.0_dp, N=N, &
                    p=p, &
                    pp=pp, &
                    q=q, &
                    w=w, &
                    bound_cond_a="Free", &
                    bound_cond_b="Dirichlet" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(N, 1:N - 3)) > tol_dp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_dp_pp1_w1FreeDirichlet_s0_sil0

  subroutine t_SLP_out_c2_dp_pp1_w1FreeDirichlet_s0_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Free", &
                      bound_cond_b="Dirichlet" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w1FreeDirichlet_s0_sil1

  subroutine t_SLP_out_c2_dp_pp1_w1FreeDirichlet_s1_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Free", &
                      bound_cond_b="Dirichlet" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w1FreeDirichlet_s1_sil0

  subroutine t_SLP_out_c2_dp_pp1_w1FreeDirichlet_s1_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Free", &
                      bound_cond_b="Dirichlet" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w1FreeDirichlet_s1_sil1

  subroutine t_SLP_out_c2_dp_pp1_w1FreeNeumann_s0_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_dp, b=1.0_dp, N=N, &
                    p=p, &
                    pp=pp, &
                    q=q, &
                    w=w, &
                    bound_cond_a="Free", &
                    bound_cond_b="Neumann" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_dp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_dp_pp1_w1FreeNeumann_s0_sil0

  subroutine t_SLP_out_c2_dp_pp1_w1FreeNeumann_s0_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Free", &
                      bound_cond_b="Neumann" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w1FreeNeumann_s0_sil1

  subroutine t_SLP_out_c2_dp_pp1_w1FreeNeumann_s1_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Free", &
                      bound_cond_b="Neumann" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w1FreeNeumann_s1_sil0

  subroutine t_SLP_out_c2_dp_pp1_w1FreeNeumann_s1_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Free", &
                      bound_cond_b="Neumann" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w1FreeNeumann_s1_sil1

  subroutine t_SLP_out_c2_dp_pp1_w1FreeMixed_s0_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_dp, b=1.0_dp, N=N, &
                    p=p, &
                    pp=pp, &
                    q=q, &
                    w=w, &
                    bound_cond_a="Free", &
                    bound_cond_b="Mixed" &
                    , mixing_param_b=1.0_dp &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(N, 1:N - 3) + 1.0_dp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_dp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_dp_pp1_w1FreeMixed_s0_sil0

  subroutine t_SLP_out_c2_dp_pp1_w1FreeMixed_s0_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Free", &
                      bound_cond_b="Mixed" &
                      , mixing_param_b=1.0_dp &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3) + 1.0_dp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w1FreeMixed_s0_sil1

  subroutine t_SLP_out_c2_dp_pp1_w1FreeMixed_s1_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Free", &
                      bound_cond_b="Mixed" &
                      , mixing_param_b=1.0_dp &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3) + 1.0_dp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w1FreeMixed_s1_sil0

  subroutine t_SLP_out_c2_dp_pp1_w1FreeMixed_s1_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Free", &
                      bound_cond_b="Mixed" &
                      , mixing_param_b=1.0_dp &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3) + 1.0_dp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w1FreeMixed_s1_sil1

  subroutine t_SLP_out_c2_dp_pp1_w1FreeFree_s0_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_dp, b=1.0_dp, N=N, &
                    p=p, &
                    pp=pp, &
                    q=q, &
                    w=w, &
                    bound_cond_a="Free", &
                    bound_cond_b="Free" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
  end subroutine t_SLP_out_c2_dp_pp1_w1FreeFree_s0_sil0

  subroutine t_SLP_out_c2_dp_pp1_w1FreeFree_s0_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Free", &
                      bound_cond_b="Free" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w1FreeFree_s0_sil1

  subroutine t_SLP_out_c2_dp_pp1_w1FreeFree_s1_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Free", &
                      bound_cond_b="Free" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w1FreeFree_s1_sil0

  subroutine t_SLP_out_c2_dp_pp1_w1FreeFree_s1_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Free", &
                      bound_cond_b="Free" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w1FreeFree_s1_sil1

  subroutine t_SLP_out_c2_dp_pp1_w1FreeSingular_s0_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_dp, b=1.0_dp, N=N, &
                    p=p, &
                    pp=pp, &
                    q=q, &
                    w=w, &
                    bound_cond_a="Free", &
                    bound_cond_b="Singular" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
  end subroutine t_SLP_out_c2_dp_pp1_w1FreeSingular_s0_sil0

  subroutine t_SLP_out_c2_dp_pp1_w1FreeSingular_s0_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Free", &
                      bound_cond_b="Singular" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w1FreeSingular_s0_sil1

  subroutine t_SLP_out_c2_dp_pp1_w1FreeSingular_s1_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Free", &
                      bound_cond_b="Singular" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w1FreeSingular_s1_sil0

  subroutine t_SLP_out_c2_dp_pp1_w1FreeSingular_s1_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Free", &
                      bound_cond_b="Singular" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w1FreeSingular_s1_sil1

  subroutine t_SLP_out_c2_dp_pp1_w1SingularDirichlet_s0_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_dp, b=1.0_dp, N=N, &
                    p=p, &
                    pp=pp, &
                    q=q, &
                    w=w, &
                    bound_cond_a="Singular", &
                    bound_cond_b="Dirichlet" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(N, 1:N - 3)) > tol_dp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_dp_pp1_w1SingularDirichlet_s0_sil0

  subroutine t_SLP_out_c2_dp_pp1_w1SingularDirichlet_s0_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Singular", &
                      bound_cond_b="Dirichlet" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w1SingularDirichlet_s0_sil1

  subroutine t_SLP_out_c2_dp_pp1_w1SingularDirichlet_s1_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Singular", &
                      bound_cond_b="Dirichlet" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w1SingularDirichlet_s1_sil0

  subroutine t_SLP_out_c2_dp_pp1_w1SingularDirichlet_s1_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Singular", &
                      bound_cond_b="Dirichlet" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w1SingularDirichlet_s1_sil1

  subroutine t_SLP_out_c2_dp_pp1_w1SingularNeumann_s0_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_dp, b=1.0_dp, N=N, &
                    p=p, &
                    pp=pp, &
                    q=q, &
                    w=w, &
                    bound_cond_a="Singular", &
                    bound_cond_b="Neumann" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_dp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_dp_pp1_w1SingularNeumann_s0_sil0

  subroutine t_SLP_out_c2_dp_pp1_w1SingularNeumann_s0_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Singular", &
                      bound_cond_b="Neumann" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w1SingularNeumann_s0_sil1

  subroutine t_SLP_out_c2_dp_pp1_w1SingularNeumann_s1_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Singular", &
                      bound_cond_b="Neumann" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w1SingularNeumann_s1_sil0

  subroutine t_SLP_out_c2_dp_pp1_w1SingularNeumann_s1_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Singular", &
                      bound_cond_b="Neumann" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w1SingularNeumann_s1_sil1

  subroutine t_SLP_out_c2_dp_pp1_w1SingularMixed_s0_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_dp, b=1.0_dp, N=N, &
                    p=p, &
                    pp=pp, &
                    q=q, &
                    w=w, &
                    bound_cond_a="Singular", &
                    bound_cond_b="Mixed" &
                    , mixing_param_b=1.0_dp &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(N, 1:N - 3) + 1.0_dp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_dp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_dp_pp1_w1SingularMixed_s0_sil0

  subroutine t_SLP_out_c2_dp_pp1_w1SingularMixed_s0_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Singular", &
                      bound_cond_b="Mixed" &
                      , mixing_param_b=1.0_dp &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3) + 1.0_dp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w1SingularMixed_s0_sil1

  subroutine t_SLP_out_c2_dp_pp1_w1SingularMixed_s1_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Singular", &
                      bound_cond_b="Mixed" &
                      , mixing_param_b=1.0_dp &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3) + 1.0_dp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w1SingularMixed_s1_sil0

  subroutine t_SLP_out_c2_dp_pp1_w1SingularMixed_s1_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Singular", &
                      bound_cond_b="Mixed" &
                      , mixing_param_b=1.0_dp &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(N, 1:N - 3) + 1.0_dp*(vl(N, 1:N - 3) - vl(N - 1, 1:N - 3))/prb%spacing()) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w1SingularMixed_s1_sil1

  subroutine t_SLP_out_c2_dp_pp1_w1SingularFree_s0_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_dp, b=1.0_dp, N=N, &
                    p=p, &
                    pp=pp, &
                    q=q, &
                    w=w, &
                    bound_cond_a="Singular", &
                    bound_cond_b="Free" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
  end subroutine t_SLP_out_c2_dp_pp1_w1SingularFree_s0_sil0

  subroutine t_SLP_out_c2_dp_pp1_w1SingularFree_s0_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Singular", &
                      bound_cond_b="Free" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w1SingularFree_s0_sil1

  subroutine t_SLP_out_c2_dp_pp1_w1SingularFree_s1_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Singular", &
                      bound_cond_b="Free" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w1SingularFree_s1_sil0

  subroutine t_SLP_out_c2_dp_pp1_w1SingularFree_s1_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Singular", &
                      bound_cond_b="Free" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w1SingularFree_s1_sil1

  subroutine t_SLP_out_c2_dp_pp1_w1SingularSingular_s0_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_dp, b=1.0_dp, N=N, &
                    p=p, &
                    pp=pp, &
                    q=q, &
                    w=w, &
                    bound_cond_a="Singular", &
                    bound_cond_b="Singular" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
  end subroutine t_SLP_out_c2_dp_pp1_w1SingularSingular_s0_sil0

  subroutine t_SLP_out_c2_dp_pp1_w1SingularSingular_s0_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Singular", &
                      bound_cond_b="Singular" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w1SingularSingular_s0_sil1

  subroutine t_SLP_out_c2_dp_pp1_w1SingularSingular_s1_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Singular", &
                      bound_cond_b="Singular" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w1SingularSingular_s1_sil0

  subroutine t_SLP_out_c2_dp_pp1_w1SingularSingular_s1_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Singular", &
                      bound_cond_b="Singular" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
    enddo
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w1SingularSingular_s1_sil1

  subroutine t_SLP_out_c2_sp_pp0_w0PeriodicPeriodic_s0_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_sp, b=1.0_sp, N=N, &
                    p=p, &
                    q=q, &
                    bound_cond_a="Periodic", &
                    bound_cond_b="Periodic" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(1, 1:N - 3) - vl(N, 1:N - 3)) > tol_sp)) then
      allocate (error)
      return
    endif
    if (any(abs(vl(1, 1:N - 3) + vl(N, 1:N - 3) - (vl(2, 1:N - 3) + vl(N - 1, 1:N - 3))) > tol_sp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_sp_pp0_w0PeriodicPeriodic_s0_sil0

  subroutine t_SLP_out_c2_sp_pp0_w0PeriodicPeriodic_s0_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Periodic", &
                      bound_cond_b="Periodic" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(N, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(1, 1:N - 3) + vl(N, 1:N - 3) - (vl(2, 1:N - 3) + vl(N - 1, 1:N - 3))) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w0PeriodicPeriodic_s0_sil1

  subroutine t_SLP_out_c2_sp_pp0_w0PeriodicPeriodic_s1_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Periodic", &
                      bound_cond_b="Periodic" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(N, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(1, 1:N - 3) + vl(N, 1:N - 3) - (vl(2, 1:N - 3) + vl(N - 1, 1:N - 3))) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w0PeriodicPeriodic_s1_sil0

  subroutine t_SLP_out_c2_sp_pp0_w0PeriodicPeriodic_s1_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Periodic", &
                      bound_cond_b="Periodic" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(N, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(1, 1:N - 3) + vl(N, 1:N - 3) - (vl(2, 1:N - 3) + vl(N - 1, 1:N - 3))) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w0PeriodicPeriodic_s1_sil1

  subroutine t_SLP_out_c2_sp_pp0_w1PeriodicPeriodic_s0_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_sp, b=1.0_sp, N=N, &
                    p=p, &
                    q=q, &
                    w=w, &
                    bound_cond_a="Periodic", &
                    bound_cond_b="Periodic" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(1, 1:N - 3) - vl(N, 1:N - 3)) > tol_sp)) then
      allocate (error)
      return
    endif
    if (any(abs(vl(1, 1:N - 3) + vl(N, 1:N - 3) - (vl(2, 1:N - 3) + vl(N - 1, 1:N - 3))) > tol_sp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_sp_pp0_w1PeriodicPeriodic_s0_sil0

  subroutine t_SLP_out_c2_sp_pp0_w1PeriodicPeriodic_s0_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Periodic", &
                      bound_cond_b="Periodic" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(N, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(1, 1:N - 3) + vl(N, 1:N - 3) - (vl(2, 1:N - 3) + vl(N - 1, 1:N - 3))) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w1PeriodicPeriodic_s0_sil1

  subroutine t_SLP_out_c2_sp_pp0_w1PeriodicPeriodic_s1_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Periodic", &
                      bound_cond_b="Periodic" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(N, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(1, 1:N - 3) + vl(N, 1:N - 3) - (vl(2, 1:N - 3) + vl(N - 1, 1:N - 3))) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w1PeriodicPeriodic_s1_sil0

  subroutine t_SLP_out_c2_sp_pp0_w1PeriodicPeriodic_s1_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Periodic", &
                      bound_cond_b="Periodic" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(N, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(1, 1:N - 3) + vl(N, 1:N - 3) - (vl(2, 1:N - 3) + vl(N - 1, 1:N - 3))) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_sp_pp0_w1PeriodicPeriodic_s1_sil1

  subroutine t_SLP_out_c2_sp_pp1_w0PeriodicPeriodic_s0_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_sp, b=1.0_sp, N=N, &
                    p=p, &
                    pp=pp, &
                    q=q, &
                    bound_cond_a="Periodic", &
                    bound_cond_b="Periodic" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(1, 1:N - 3) - vl(N, 1:N - 3)) > tol_sp)) then
      allocate (error)
      return
    endif
    if (any(abs(vl(1, 1:N - 3) + vl(N, 1:N - 3) - (vl(2, 1:N - 3) + vl(N - 1, 1:N - 3))) > tol_sp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_sp_pp1_w0PeriodicPeriodic_s0_sil0

  subroutine t_SLP_out_c2_sp_pp1_w0PeriodicPeriodic_s0_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Periodic", &
                      bound_cond_b="Periodic" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(N, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(1, 1:N - 3) + vl(N, 1:N - 3) - (vl(2, 1:N - 3) + vl(N - 1, 1:N - 3))) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w0PeriodicPeriodic_s0_sil1

  subroutine t_SLP_out_c2_sp_pp1_w0PeriodicPeriodic_s1_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Periodic", &
                      bound_cond_b="Periodic" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(N, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(1, 1:N - 3) + vl(N, 1:N - 3) - (vl(2, 1:N - 3) + vl(N - 1, 1:N - 3))) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w0PeriodicPeriodic_s1_sil0

  subroutine t_SLP_out_c2_sp_pp1_w0PeriodicPeriodic_s1_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Periodic", &
                      bound_cond_b="Periodic" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(N, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(1, 1:N - 3) + vl(N, 1:N - 3) - (vl(2, 1:N - 3) + vl(N - 1, 1:N - 3))) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w0PeriodicPeriodic_s1_sil1

  subroutine t_SLP_out_c2_sp_pp1_w1PeriodicPeriodic_s0_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_sp, b=1.0_sp, N=N, &
                    p=p, &
                    pp=pp, &
                    q=q, &
                    w=w, &
                    bound_cond_a="Periodic", &
                    bound_cond_b="Periodic" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(1, 1:N - 3) - vl(N, 1:N - 3)) > tol_sp)) then
      allocate (error)
      return
    endif
    if (any(abs(vl(1, 1:N - 3) + vl(N, 1:N - 3) - (vl(2, 1:N - 3) + vl(N - 1, 1:N - 3))) > tol_sp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_sp_pp1_w1PeriodicPeriodic_s0_sil0

  subroutine t_SLP_out_c2_sp_pp1_w1PeriodicPeriodic_s0_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Periodic", &
                      bound_cond_b="Periodic" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(N, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(1, 1:N - 3) + vl(N, 1:N - 3) - (vl(2, 1:N - 3) + vl(N - 1, 1:N - 3))) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w1PeriodicPeriodic_s0_sil1

  subroutine t_SLP_out_c2_sp_pp1_w1PeriodicPeriodic_s1_sil0(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Periodic", &
                      bound_cond_b="Periodic" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(N, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(1, 1:N - 3) + vl(N, 1:N - 3) - (vl(2, 1:N - 3) + vl(N - 1, 1:N - 3))) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w1PeriodicPeriodic_s1_sil0

  subroutine t_SLP_out_c2_sp_pp1_w1PeriodicPeriodic_s1_sil1(error)
    use SLP_obj, only: SLP_sp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_sp) :: prb
    integer, parameter :: N = 100
    real(sp) :: p(N), pp(N), q(N), w(N)
    real(sp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_sp
    pp = 1.0_sp
    q = 0.0_sp
    w = 1.0_sp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_sp, b=1.0_sp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Periodic", &
                      bound_cond_b="Periodic" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, sp))**(-1.0_sp)) > tol_sp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(N, 1:N - 3)) > tol_sp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(1, 1:N - 3) + vl(N, 1:N - 3) - (vl(2, 1:N - 3) + vl(N - 1, 1:N - 3))) > tol_sp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_sp_pp1_w1PeriodicPeriodic_s1_sil1

  subroutine t_SLP_out_c2_dp_pp0_w0PeriodicPeriodic_s0_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_dp, b=1.0_dp, N=N, &
                    p=p, &
                    q=q, &
                    bound_cond_a="Periodic", &
                    bound_cond_b="Periodic" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(1, 1:N - 3) - vl(N, 1:N - 3)) > tol_dp)) then
      allocate (error)
      return
    endif
    if (any(abs(vl(1, 1:N - 3) + vl(N, 1:N - 3) - (vl(2, 1:N - 3) + vl(N - 1, 1:N - 3))) > tol_dp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_dp_pp0_w0PeriodicPeriodic_s0_sil0

  subroutine t_SLP_out_c2_dp_pp0_w0PeriodicPeriodic_s0_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Periodic", &
                      bound_cond_b="Periodic" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(N, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(1, 1:N - 3) + vl(N, 1:N - 3) - (vl(2, 1:N - 3) + vl(N - 1, 1:N - 3))) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w0PeriodicPeriodic_s0_sil1

  subroutine t_SLP_out_c2_dp_pp0_w0PeriodicPeriodic_s1_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Periodic", &
                      bound_cond_b="Periodic" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(N, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(1, 1:N - 3) + vl(N, 1:N - 3) - (vl(2, 1:N - 3) + vl(N - 1, 1:N - 3))) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w0PeriodicPeriodic_s1_sil0

  subroutine t_SLP_out_c2_dp_pp0_w0PeriodicPeriodic_s1_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      bound_cond_a="Periodic", &
                      bound_cond_b="Periodic" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(N, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(1, 1:N - 3) + vl(N, 1:N - 3) - (vl(2, 1:N - 3) + vl(N - 1, 1:N - 3))) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w0PeriodicPeriodic_s1_sil1

  subroutine t_SLP_out_c2_dp_pp0_w1PeriodicPeriodic_s0_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_dp, b=1.0_dp, N=N, &
                    p=p, &
                    q=q, &
                    w=w, &
                    bound_cond_a="Periodic", &
                    bound_cond_b="Periodic" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(1, 1:N - 3) - vl(N, 1:N - 3)) > tol_dp)) then
      allocate (error)
      return
    endif
    if (any(abs(vl(1, 1:N - 3) + vl(N, 1:N - 3) - (vl(2, 1:N - 3) + vl(N - 1, 1:N - 3))) > tol_dp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_dp_pp0_w1PeriodicPeriodic_s0_sil0

  subroutine t_SLP_out_c2_dp_pp0_w1PeriodicPeriodic_s0_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Periodic", &
                      bound_cond_b="Periodic" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(N, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(1, 1:N - 3) + vl(N, 1:N - 3) - (vl(2, 1:N - 3) + vl(N - 1, 1:N - 3))) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w1PeriodicPeriodic_s0_sil1

  subroutine t_SLP_out_c2_dp_pp0_w1PeriodicPeriodic_s1_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Periodic", &
                      bound_cond_b="Periodic" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(N, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(1, 1:N - 3) + vl(N, 1:N - 3) - (vl(2, 1:N - 3) + vl(N - 1, 1:N - 3))) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w1PeriodicPeriodic_s1_sil0

  subroutine t_SLP_out_c2_dp_pp0_w1PeriodicPeriodic_s1_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Periodic", &
                      bound_cond_b="Periodic" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(N, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(1, 1:N - 3) + vl(N, 1:N - 3) - (vl(2, 1:N - 3) + vl(N - 1, 1:N - 3))) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_dp_pp0_w1PeriodicPeriodic_s1_sil1

  subroutine t_SLP_out_c2_dp_pp1_w0PeriodicPeriodic_s0_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_dp, b=1.0_dp, N=N, &
                    p=p, &
                    pp=pp, &
                    q=q, &
                    bound_cond_a="Periodic", &
                    bound_cond_b="Periodic" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(1, 1:N - 3) - vl(N, 1:N - 3)) > tol_dp)) then
      allocate (error)
      return
    endif
    if (any(abs(vl(1, 1:N - 3) + vl(N, 1:N - 3) - (vl(2, 1:N - 3) + vl(N - 1, 1:N - 3))) > tol_dp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_dp_pp1_w0PeriodicPeriodic_s0_sil0

  subroutine t_SLP_out_c2_dp_pp1_w0PeriodicPeriodic_s0_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Periodic", &
                      bound_cond_b="Periodic" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(N, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(1, 1:N - 3) + vl(N, 1:N - 3) - (vl(2, 1:N - 3) + vl(N - 1, 1:N - 3))) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w0PeriodicPeriodic_s0_sil1

  subroutine t_SLP_out_c2_dp_pp1_w0PeriodicPeriodic_s1_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Periodic", &
                      bound_cond_b="Periodic" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(N, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(1, 1:N - 3) + vl(N, 1:N - 3) - (vl(2, 1:N - 3) + vl(N - 1, 1:N - 3))) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w0PeriodicPeriodic_s1_sil0

  subroutine t_SLP_out_c2_dp_pp1_w0PeriodicPeriodic_s1_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      bound_cond_a="Periodic", &
                      bound_cond_b="Periodic" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(N, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(1, 1:N - 3) + vl(N, 1:N - 3) - (vl(2, 1:N - 3) + vl(N - 1, 1:N - 3))) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w0PeriodicPeriodic_s1_sil1

  subroutine t_SLP_out_c2_dp_pp1_w1PeriodicPeriodic_s0_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%define(name="Test", &
                    a=0.0_dp, b=1.0_dp, N=N, &
                    p=p, &
                    pp=pp, &
                    q=q, &
                    w=w, &
                    bound_cond_a="Periodic", &
                    bound_cond_b="Periodic" &
                    )
    if (prb%name() /= "Test") then
      allocate (error)
      return
    endif
    if (prb%relative_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%absolute_error() > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%Ndsc() /= N) then
      allocate (error)
      return
    endif
    if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    call prb%solve( &
      )
    if (.not. prb%solved()) then
      allocate (error)
      return
    endif
    vl = prb%eivec()
    if (any(abs(vl(1, 1:N - 3) - vl(N, 1:N - 3)) > tol_dp)) then
      allocate (error)
      return
    endif
    if (any(abs(vl(1, 1:N - 3) + vl(N, 1:N - 3) - (vl(2, 1:N - 3) + vl(N - 1, 1:N - 3))) > tol_dp)) then
      allocate (error)
      return
    endif
  end subroutine t_SLP_out_c2_dp_pp1_w1PeriodicPeriodic_s0_sil0

  subroutine t_SLP_out_c2_dp_pp1_w1PeriodicPeriodic_s0_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Periodic", &
                      bound_cond_b="Periodic" &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(N, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(1, 1:N - 3) + vl(N, 1:N - 3) - (vl(2, 1:N - 3) + vl(N - 1, 1:N - 3))) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w1PeriodicPeriodic_s0_sil1

  subroutine t_SLP_out_c2_dp_pp1_w1PeriodicPeriodic_s1_sil0(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Periodic", &
                      bound_cond_b="Periodic" &
                      , enforce_self_adjoint=tb(i) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(N, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(1, 1:N - 3) + vl(N, 1:N - 3) - (vl(2, 1:N - 3) + vl(N - 1, 1:N - 3))) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w1PeriodicPeriodic_s1_sil0

  subroutine t_SLP_out_c2_dp_pp1_w1PeriodicPeriodic_s1_sil1(error)
    use SLP_obj, only: SLP_dp
    type(error_type), allocatable, intent(out) :: error
    type(SLP_dp) :: prb
    integer, parameter :: N = 100
    real(dp) :: p(N), pp(N), q(N), w(N)
    real(dp) :: vl(N, N)
    logical :: tb(2) = [.false., .true.]
    integer :: i, j
    p = 1.0_dp
    pp = 1.0_dp
    q = 0.0_dp
    w = 1.0_dp
    if (prb%initialized()) then
      allocate (error)
      return
    endif
    if (prb%solved()) then
      allocate (error)
      return
    endif
    do i = 1, 2
    do j = 1, 2
      call prb%define(name="Test", &
                      a=0.0_dp, b=1.0_dp, N=N, &
                      p=p, &
                      pp=pp, &
                      q=q, &
                      w=w, &
                      bound_cond_a="Periodic", &
                      bound_cond_b="Periodic" &
                      , enforce_self_adjoint=tb(i) &
                      , silent=tb(j) &
                      )
      if (prb%name() /= "Test") then
        allocate (error)
        return
      endif
      if (prb%relative_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%absolute_error() > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%Ndsc() /= N) then
        allocate (error)
        return
      endif
      if ((prb%spacing() - (real(N - 1, dp))**(-1.0_dp)) > tol_dp) then
        allocate (error)
        return
      endif
      if (prb%solved()) then
        allocate (error)
        return
      endif
      call prb%solve( &
        silent=tb(j) &
        )
      if (.not. prb%solved()) then
        allocate (error)
        return
      endif
      vl = prb%eivec()
      if (any(abs(vl(1, 1:N - 3) - vl(N, 1:N - 3)) > tol_dp)) then
        allocate (error)
        return
      endif
      if (any(abs(vl(1, 1:N - 3) + vl(N, 1:N - 3) - (vl(2, 1:N - 3) + vl(N - 1, 1:N - 3))) > tol_dp)) then
        allocate (error)
        return
      endif
    enddo
    enddo
  end subroutine t_SLP_out_c2_dp_pp1_w1PeriodicPeriodic_s1_sil1

end module Obj_Functionality
